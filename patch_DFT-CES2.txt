Common subdirectories: src/ASPHERE and src_DFT-CES2/ASPHERE
Common subdirectories: src/blur and src_DFT-CES2/blur
diff -uN src/blur.c src_DFT-CES2/blur.c
--- src/blur.c	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/blur.c	2025-02-11 06:42:37.279609891 +0900
@@ -0,0 +1,272 @@
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+#include "time.h"
+#include "mkl_types.h"
+#include "unistd.h"
+
+#include "tagmodels.h"
+#include "computemodels.h"
+#include "fftset.h"
+#include "blur.h"
+
+/* ---------------------------------------------------------------------- */
+
+int main(int argc, char **argv)
+{
+	int i, j, k, dir, rm_index;
+	char potFile[200];
+	double sigma;
+	struct timespec stampParsing1, stampParsing2, \
+		stampCopybyvalue1, stampCopybyvalue2, \
+		stampFFT1, stampFFT2, \
+		stampSave1, stampSave2;
+	double durationParsing, durationCopybyvalue, durationFFT, durationSave;
+
+	// DEBUG PART START
+	/*
+	double test_integral;
+	double idV;
+	*/
+	// DEBUG PART END
+
+	// Argument parsing
+	if (argc == 3) {
+		sprintf(potFile,"%s",argv[1]);
+		if(access(potFile,F_OK) == -1) {
+			printf("File does not exist.\n");
+			return 1;
+		}
+		sigma = atof(argv[2]);
+	}
+	else {
+		printf("Usage: ./blur.o cubefile sigma\n");
+		return 1;
+	}
+
+	// tag_Models: a struct for cubefile data
+	tag_Models *base, *gk;
+
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampParsing1);
+	potParser(&base, potFile);
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampParsing2);
+	durationParsing = (1000.0 * (double)stampParsing2.tv_sec + 1.0e-6 * stampParsing2.tv_nsec) - \
+	(1000.0 * (double)stampParsing1.tv_sec + 1.0e-6 * stampParsing1.tv_nsec);
+
+	potCopywoValue(&base, &gk);
+
+	// Generating normalized real-space Gaussian centered at origin
+	gen_kernel(&gk, sigma);
+	printf("Gaussian sigma: %13.5E\n", sigma);
+
+	// DEBUG PART START
+	//saveCube(&gk, "kernel.cube");
+	/*
+	idV = (base->pGrid[0] * base->pGrid[1] * base->pGrid[2]) / (base->cellParams[0] * base->cellParams[1] * base->cellParams[2]);
+	test_integral = 0.0;
+	for (i = 0; i < base->pGrid[0] * base->pGrid[1] * base->pGrid[2]; i++) {
+		test_integral += base->pValue[i];
+	}
+	test_integral *= idV;
+	printf("3D Integral of the input grid: %13.5E\n", test_integral);
+	*/
+	// DEBUG PART END
+
+	// compute_Models: a struct for cuFFT data
+	compute_Models *compute_info;
+	compute_info = (compute_Models *)malloc(sizeof(compute_Models));
+
+	for (dir = 0; dir < 3; dir++) {
+		compute_info->cell_Bohr[dir] = base->cellParams[dir];
+		compute_info->N[dir] = base->pGrid[dir];
+	}
+
+	compute_info->cplx_gauss = (MKL_Complex8 *)malloc(sizeof(MKL_Complex8) * compute_info->N[0] * compute_info->N[1] * compute_info->N[2]);
+	compute_info->cplx_Ptr = (MKL_Complex8 *)malloc(sizeof(MKL_Complex8) * compute_info->N[0] * compute_info->N[1] * compute_info->N[2]);
+
+	// copying data into host pointers
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampCopybyvalue1);
+	for (i = 0; i < compute_info->N[0]; i++) {
+		for (j = 0; j < compute_info->N[1]; j++) {
+			for (k = 0; k < compute_info->N[2]; k++) {
+				rm_index = k + j * compute_info->N[2] + i * compute_info->N[2] * compute_info->N[1];
+				compute_info->cplx_gauss[rm_index].real = (gk->pValue[rm_index]);
+				compute_info->cplx_gauss[rm_index].imag = 0.0;				
+				compute_info->cplx_Ptr[rm_index].real = base->pValue[rm_index];
+				compute_info->cplx_Ptr[rm_index].imag = 0.0;
+			}
+		}
+	}
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampCopybyvalue2);
+	durationCopybyvalue = (1000.0 * (double)stampCopybyvalue2.tv_sec + 1.0e-6 * stampCopybyvalue2.tv_nsec) - \
+	(1000.0 * (double)stampCopybyvalue1.tv_sec + 1.0e-6 * stampCopybyvalue1.tv_nsec);
+
+	// gaussR2K
+	// Forward discrete Fourier transform for devcplx_gauss
+	gaussR2K(&compute_info);
+
+	// extfield_kernel
+	// Gaussian operation in k-space
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampFFT1);
+	extfield_kernel(&compute_info);
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampFFT2);
+	durationFFT = (1000.0 * (double)stampFFT2.tv_sec + 1.0e-6 * stampFFT2.tv_nsec) - \
+	(1000.0 * (double)stampFFT1.tv_sec + 1.0e-6 * stampFFT1.tv_nsec);
+
+	// copying data from the host pointer to the tag_Models type pointer
+	for (i = 0; i < compute_info->N[0]; i++) {
+		for (j = 0; j < compute_info->N[1]; j++) {
+			for (k = 0; k < compute_info->N[2]; k++) {
+				rm_index = k + j * compute_info->N[2] + i * compute_info->N[2] * compute_info->N[1];
+				base->pValue[rm_index] = compute_info->cplx_Ptr[rm_index].real;
+			}
+		}
+	}
+
+	// DEBUG PART START
+	/*
+	test_integral = 0.0;
+	for (i = 0; i < base->pGrid[0] * base->pGrid[1] * base->pGrid[2]; i++) {
+		test_integral += base->pValue[i];
+	}
+	test_integral *= idV;
+	printf("3D Integral of the blurred grid: %13.5E\n", test_integral);
+	*/
+	// DEBUG PART END
+
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampSave1);
+	saveCube(&base, "blurred.cube");
+	clock_gettime(_POSIX_MONOTONIC_CLOCK, &stampSave2);
+	durationSave = (1000.0 * (double)stampSave2.tv_sec + 1.0e-6 * stampSave2.tv_nsec) - \
+	(1000.0 * (double)stampSave1.tv_sec + 1.0e-6 * stampSave1.tv_nsec);
+
+	printf("\n");
+	printf("Time taken to parse a cube file: %f ms\n", durationParsing);
+	printf("Time taken to copy grid data into a complex array: %f ms\n", durationCopybyvalue);
+	printf("Time taken to perform the gaussian kernel operation (2 FFTs): %f ms\n", durationFFT);
+	printf("Time taken to save a cube file: %f ms\n", durationSave);
+
+	free(compute_info->cplx_gauss);
+	free(compute_info->cplx_Ptr);
+	free(compute_info);
+	potFree(&base);
+	potFree(&gk);
+
+	return 0;
+}
+
+// potParser
+// target cube file: potential, cellParams unit Bohr, pValue in Hartree atomic units,
+// returned tag_Models: potential, cellParams unit Bohr, pValue in Hartree atomic units
+int potParser(tag_Models **output, char *fname)
+{ // LOCPOT parser
+	FILE *fp;
+	char str[2048], *str_ptr;
+	int nline = 0, cnt = 0;
+
+	*output = (tag_Models *)malloc(sizeof(tag_Models));
+
+	printf("###  Grid file info : %s\n", fname);
+
+	fp = fopen(fname, "r");
+	(*output)->nAtoms = 0;
+	(*output)->cellParams[0] = (*output)->cellParams[1] = (*output)->cellParams[2] = (double)0;
+
+	while (fgets(str, sizeof(str), fp) != NULL)
+	{
+		int i, j, *temp, k;
+		double a, b, c, d;
+		nline++;
+
+		if (nline == 3)
+		{
+			sscanf(str, "%d %*f %*f %*f", &(*output)->nAtoms);
+			(*output)->atomN = (int *)malloc((*output)->nAtoms * sizeof(int));
+			(*output)->posX = (double *)malloc((*output)->nAtoms * sizeof(double));
+			(*output)->posY = (double *)malloc((*output)->nAtoms * sizeof(double));
+			(*output)->posZ = (double *)malloc((*output)->nAtoms * sizeof(double));
+		}
+
+		if (nline == 4)
+		{
+			sscanf(str, "%d %lf %*f %*f", &(*output)->pGrid[0], &(*output)->cellParams[0]);
+			(*output)->cellParams[0] = (*output)->pGrid[0] * (*output)->cellParams[0];
+		}
+
+		if (nline == 5)
+		{
+			sscanf(str, "%d %*f %lf %*f", &(*output)->pGrid[1], &(*output)->cellParams[1]);
+			(*output)->cellParams[1] = (*output)->pGrid[1] * (*output)->cellParams[1];
+		}
+
+		if (nline == 6)
+		{
+			sscanf(str, "%d %*f %*f %lf", &(*output)->pGrid[2], &(*output)->cellParams[2]);
+			(*output)->cellParams[2] = (*output)->pGrid[2] * (*output)->cellParams[2];
+		}
+
+		if (nline >= 7 && nline < 7 + (*output)->nAtoms)
+		{
+			sscanf(str, "%d %*f %lf %lf %lf", &(*output)->atomN[nline - 7], &(*output)->posX[nline - 7], &(*output)->posY[nline - 7], &(*output)->posZ[nline - 7]);
+		}
+
+		if (nline == (*output)->nAtoms + 6)
+		{
+			printf("### Cell parameters(A): %f %f %f\n", (*output)->cellParams[0], (*output)->cellParams[1], (*output)->cellParams[2]);
+			printf("### Number of Atoms: %d\n", (*output)->nAtoms);
+			printf("### Grid Dimension: %d %d %d\n", (*output)->pGrid[0], (*output)->pGrid[1], (*output)->pGrid[2]);
+			(*output)->pValue = (double *)malloc((*output)->pGrid[0] * (*output)->pGrid[1] * (*output)->pGrid[2] * sizeof(double));
+		}
+
+		if (nline >= (*output)->nAtoms + 7 && cnt < (*output)->pGrid[0] * (*output)->pGrid[1] * (*output)->pGrid[2])
+		{
+			str_ptr = strtok(str, " ");
+			for (; str_ptr != NULL; cnt++)
+			{
+				sscanf(str_ptr, "%lf", &(*output)->pValue[cnt]);
+				(*output)->pValue[cnt] = (*output)->pValue[cnt];
+				str_ptr = strtok(NULL, " ");
+			}
+		}
+
+	} //while end
+
+	return 0;
+}
+
+// saveCube: saves a tag_Models input into a cube file
+int saveCube(tag_Models **input, char *fname)
+{
+	FILE *fp;
+	int i, j, k, cnt;
+	fp = fopen(fname, "w");
+
+	fprintf(fp, " Gaussian Blurred Cubefile\n");
+	fprintf(fp, " lattice unit Bohr\n");
+	fprintf(fp, "% 5d    0.000000    0.000000    0.000000\n", (*input)->nAtoms);
+	fprintf(fp, "% 5d% 12.6lf    0.000000    0.000000\n", (*input)->pGrid[0], (*input)->cellParams[0] / (*input)->pGrid[0]);
+	fprintf(fp, "% 5d    0.000000% 12.6lf    0.000000\n", (*input)->pGrid[1], (*input)->cellParams[1] / (*input)->pGrid[1]);
+	fprintf(fp, "% 5d    0.000000    0.000000% 12.6lf\n", (*input)->pGrid[2], (*input)->cellParams[2] / (*input)->pGrid[2]);
+	for (i = 0; i < (*input)->nAtoms; i++)
+	{
+		fprintf(fp, "% 5d% 12.6lf% 12.6lf% 12.6lf% 12.6lf\n", (*input)->atomN[i], (double)(*input)->atomN[i], (*input)->posX[i], (*input)->posY[i], (*input)->posZ[i]);
+	}
+	cnt = 0;
+	for (i = 0; i < (*input)->pGrid[0]; i++)
+	{
+		for (j = 0; j < (*input)->pGrid[1]; j++)
+		{
+			for (k = 0; k < (*input)->pGrid[2]; k++)
+			{
+				fprintf(fp, "% 13.5lE", ((*input)->pValue[k + j * (*input)->pGrid[2] + i * (*input)->pGrid[2] * (*input)->pGrid[1]]));
+				if (cnt % 6 == 5)
+					fprintf(fp, "\n");
+				cnt++;
+			}
+		}
+	}
+	fclose(fp);
+	printf("### New cubefile has been saved as %s\n", fname);
+
+	return 0;
+}
diff -uN src/blur.h src_DFT-CES2/blur.h
--- src/blur.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/blur.h	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,10 @@
+#ifndef _MAIN_H
+#define _MAIN_H
+
+#include "tagmodels.h"
+#include "computemodels.h"
+
+int potParser(tag_Models **output, char *fname);
+int saveCube(tag_Models **input, char *fname);
+
+#endif
Common subdirectories: src/BODY and src_DFT-CES2/BODY
Common subdirectories: src/CLASS2 and src_DFT-CES2/CLASS2
Common subdirectories: src/COLLOID and src_DFT-CES2/COLLOID
Common subdirectories: src/COMPRESS and src_DFT-CES2/COMPRESS
diff -uN src/compute_erotate_rigid.cpp src_DFT-CES2/compute_erotate_rigid.cpp
--- src/compute_erotate_rigid.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_erotate_rigid.cpp	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,74 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <mpi.h>
+#include <string.h>
+#include "compute_erotate_rigid.h"
+#include "update.h"
+#include "force.h"
+#include "modify.h"
+#include "fix.h"
+#include "fix_rigid.h"
+#include "fix_rigid_small.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ComputeERotateRigid::ComputeERotateRigid(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg), rfix(NULL)
+{
+  if (narg != 4) error->all(FLERR,"Illegal compute erotate/rigid command");
+
+  scalar_flag = 1;
+  extscalar = 1;
+
+  int n = strlen(arg[3]) + 1;
+  rfix = new char[n];
+  strcpy(rfix,arg[3]);
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputeERotateRigid::~ComputeERotateRigid()
+{
+  delete [] rfix;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeERotateRigid::init()
+{
+  irfix = modify->find_fix(rfix);
+  if (irfix < 0)
+    error->all(FLERR,"Fix ID for compute erotate/rigid does not exist");
+
+  if (strncmp(modify->fix[irfix]->style,"rigid",5))
+    error->all(FLERR,"Compute erotate/rigid with non-rigid fix-ID");
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ComputeERotateRigid::compute_scalar()
+{
+  invoked_scalar = update->ntimestep;
+
+  if (strncmp(modify->fix[irfix]->style,"rigid",5) == 0) {
+    if (strstr(modify->fix[irfix]->style,"/small")) {
+      scalar = ((FixRigidSmall *) modify->fix[irfix])->extract_erotational();
+    } else scalar = ((FixRigid *) modify->fix[irfix])->extract_erotational();
+  }
+  scalar *= force->mvv2e;
+  return scalar;
+}
diff -uN src/compute_erotate_rigid.h src_DFT-CES2/compute_erotate_rigid.h
--- src/compute_erotate_rigid.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_erotate_rigid.h	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,60 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(erotate/rigid,ComputeERotateRigid)
+
+#else
+
+#ifndef LMP_COMPUTE_EROTATE_RIGID_H
+#define LMP_COMPUTE_EROTATE_RIGID_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputeERotateRigid : public Compute {
+ public:
+  ComputeERotateRigid(class LAMMPS *, int, char **);
+  ~ComputeERotateRigid();
+  void init();
+  double compute_scalar();
+
+ private:
+  int irfix;
+  char *rfix;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Fix ID for compute erotate/rigid does not exist
+
+Self-explanatory.
+
+E: Compute erotate/rigid with non-rigid fix-ID
+
+Self-explanatory.
+
+*/
diff -uN src/compute_force_tally.cpp src_DFT-CES2/compute_force_tally.cpp
--- src/compute_force_tally.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_force_tally.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,221 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "compute_force_tally.h"
+#include "atom.h"
+#include "group.h"
+#include "pair.h"
+#include "update.h"
+#include "memory.h"
+#include "error.h"
+#include "force.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ComputeForceTally::ComputeForceTally(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg)
+{
+  if (narg < 4) error->all(FLERR,"Illegal compute force/tally command");
+
+  igroup2 = group->find(arg[3]);
+  if (igroup2 == -1)
+    error->all(FLERR,"Could not find compute force/tally second group ID");
+  groupbit2 = group->bitmask[igroup2];
+
+  scalar_flag = 1;
+  vector_flag = 0;
+  peratom_flag = 1;
+  timeflag = 1;
+
+  comm_reverse = size_peratom_cols = 3;
+  extscalar = 1;
+  peflag = 1;                   // we need Pair::ev_tally() to be run
+
+  did_setup = invoked_peratom = invoked_scalar = -1;
+  nmax = -1;
+  fatom = NULL;
+  vector = new double[size_peratom_cols];
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputeForceTally::~ComputeForceTally()
+{
+  if (force && force->pair) force->pair->del_tally_callback(this);
+  memory->destroy(fatom);
+  delete[] vector;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeForceTally::init()
+{
+  if (force->pair == NULL)
+    error->all(FLERR,"Trying to use compute force/tally without pair style");
+  else
+    force->pair->add_tally_callback(this);
+
+  if (comm->me == 0) {
+    if (force->pair->single_enable == 0 || force->pair->manybody_flag)
+      error->warning(FLERR,"Compute force/tally used with incompatible pair style");
+
+    if (force->bond || force->angle || force->dihedral
+                    || force->improper || force->kspace)
+      error->warning(FLERR,"Compute force/tally only called from pair style");
+  }
+  did_setup = -1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeForceTally::pair_setup_callback(int, int)
+{
+  const int ntotal = atom->nlocal + atom->nghost;
+
+  // grow per-atom storage, if needed
+
+  if (atom->nmax > nmax) {
+    memory->destroy(fatom);
+    nmax = atom->nmax;
+    memory->create(fatom,nmax,size_peratom_cols,"force/tally:fatom");
+    array_atom = fatom;
+  }
+
+  // clear storage
+
+  for (int i=0; i < ntotal; ++i)
+    for (int j=0; j < size_peratom_cols; ++j)
+      fatom[i][j] = 0.0;
+
+  for (int i=0; i < size_peratom_cols; ++i)
+    vector[i] = ftotal[i] = 0.0;
+
+  did_setup = update->ntimestep;
+}
+
+/* ---------------------------------------------------------------------- */
+void ComputeForceTally::pair_tally_callback(int i, int j, int nlocal, int newton,
+                                            double, double, double fpair,
+                                            double dx, double dy, double dz)
+{
+  const int * const mask = atom->mask;
+
+  if ( ((mask[i] & groupbit) && (mask[j] & groupbit2))
+       || ((mask[i] & groupbit2) && (mask[j] & groupbit)) ) {
+
+    if (newton || i < nlocal) {
+      if (mask[i] & groupbit) {
+        ftotal[0] += fpair*dx;
+        ftotal[1] += fpair*dy;
+        ftotal[2] += fpair*dz;
+      }
+      fatom[i][0] += fpair*dx;
+      fatom[i][1] += fpair*dy;
+      fatom[i][2] += fpair*dz;
+    }
+    if (newton || j < nlocal) {
+      if (mask[j] & groupbit) {
+        ftotal[0] -= fpair*dx;
+        ftotal[1] -= fpair*dy;
+        ftotal[2] -= fpair*dz;
+      }
+      fatom[j][0] -= fpair*dx;
+      fatom[j][1] -= fpair*dy;
+      fatom[j][2] -= fpair*dz;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int ComputeForceTally::pack_reverse_comm(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    buf[m++] = fatom[i][0];
+    buf[m++] = fatom[i][1];
+    buf[m++] = fatom[i][2];
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeForceTally::unpack_reverse_comm(int n, int *list, double *buf)
+{
+  int i,j,m;
+
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    fatom[j][0] += buf[m++];
+    fatom[j][1] += buf[m++];
+    fatom[j][2] += buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ComputeForceTally::compute_scalar()
+{
+  invoked_scalar = update->ntimestep;
+  if ((did_setup != invoked_scalar)
+      || (update->eflag_global != invoked_scalar))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // sum accumulated forces across procs
+
+  MPI_Allreduce(ftotal,vector,size_peratom_cols,MPI_DOUBLE,MPI_SUM,world);
+
+  scalar = sqrt(vector[0]*vector[0]+vector[1]*vector[1]+vector[2]*vector[2]);
+  return scalar;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeForceTally::compute_peratom()
+{
+  invoked_peratom = update->ntimestep;
+  if ((did_setup != invoked_peratom)
+      || (update->eflag_global != invoked_peratom))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // collect contributions from ghost atoms
+
+  if (force->newton_pair) {
+    comm->reverse_comm_compute(this);
+
+    // clear out ghost atom data after it has been collected to local atoms
+    const int nall = atom->nlocal + atom->nghost;
+    for (int i = atom->nlocal; i < nall; ++i)
+      for (int j = 0; j < size_peratom_cols; ++j)
+        fatom[i][j] = 0.0;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double ComputeForceTally::memory_usage()
+{
+  double bytes = (nmax < 0) ? 0 : nmax*size_peratom_cols * sizeof(double);
+  return bytes;
+}
+
diff -uN src/compute_force_tally.h src_DFT-CES2/compute_force_tally.h
--- src/compute_force_tally.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_force_tally.h	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,66 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(force/tally,ComputeForceTally)
+
+#else
+
+#ifndef LMP_COMPUTE_FORCE_TALLY_H
+#define LMP_COMPUTE_FORCE_TALLY_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputeForceTally : public Compute {
+
+ public:
+  ComputeForceTally(class LAMMPS *, int, char **);
+  virtual ~ComputeForceTally();
+
+  void init();
+
+  double compute_scalar();
+  void compute_peratom();
+
+  int pack_reverse_comm(int, int, double *);
+  void unpack_reverse_comm(int, int *, double *);
+  double memory_usage();
+
+  void pair_setup_callback(int, int);
+  void pair_tally_callback(int, int, int, int,
+                           double, double, double,
+                           double, double, double);
+ private:
+  bigint did_setup;
+  int nmax,igroup2,groupbit2;
+  double **fatom;
+  double ftotal[3];
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+*/
diff -uN src/compute_heat_flux_tally.cpp src_DFT-CES2/compute_heat_flux_tally.cpp
--- src/compute_heat_flux_tally.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_heat_flux_tally.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,281 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "compute_heat_flux_tally.h"
+#include "atom.h"
+#include "group.h"
+#include "pair.h"
+#include "update.h"
+#include "memory.h"
+#include "error.h"
+#include "force.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ComputeHeatFluxTally::ComputeHeatFluxTally(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg)
+{
+  if (narg < 4) error->all(FLERR,"Illegal compute heat/flux/tally command");
+
+  igroup2 = group->find(arg[3]);
+  if (igroup2 == -1)
+    error->all(FLERR,"Could not find compute heat/flux/tally second group ID");
+  groupbit2 = group->bitmask[igroup2];
+
+  vector_flag = 1;
+  timeflag = 1;
+
+  comm_reverse = 7;
+  extvector = 1;
+  size_vector = 6;
+  peflag = 1;                   // we need Pair::ev_tally() to be run
+
+  did_setup = 0;
+  invoked_peratom = invoked_scalar = -1;
+  nmax = -1;
+  stress = NULL;
+  eatom = NULL;
+  vector = new double[size_vector];
+  heatj = new double[size_vector];
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputeHeatFluxTally::~ComputeHeatFluxTally()
+{
+  if (force && force->pair) force->pair->del_tally_callback(this);
+  memory->destroy(stress);
+  memory->destroy(eatom);
+  delete[] heatj;
+  delete[] vector;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeHeatFluxTally::init()
+{
+  if (force->pair == NULL)
+    error->all(FLERR,"Trying to use compute heat/flux/tally without pair style");
+  else
+    force->pair->add_tally_callback(this);
+
+  if (comm->me == 0) {
+    if (force->pair->single_enable == 0 || force->pair->manybody_flag)
+      error->warning(FLERR,"Compute heat/flux/tally used with incompatible pair style");
+
+    if (force->bond || force->angle || force->dihedral
+                    || force->improper || force->kspace)
+      error->warning(FLERR,"Compute heat/flux/tally only called from pair style");
+  }
+  did_setup = -1;
+}
+
+/* ---------------------------------------------------------------------- */
+void ComputeHeatFluxTally::pair_setup_callback(int, int)
+{
+  const int ntotal = atom->nlocal + atom->nghost;
+
+  // grow per-atom storage, if needed
+
+  if (atom->nmax > nmax) {
+    memory->destroy(stress);
+    memory->destroy(eatom);
+    nmax = atom->nmax;
+    memory->create(stress,nmax,6,"heat/flux/tally:stress");
+    memory->create(eatom,nmax,"heat/flux/tally:eatom");
+  }
+
+  // clear storage
+
+  for (int i=0; i < ntotal; ++i) {
+    eatom[i] = 0.0;
+    stress[i][0] = 0.0;
+    stress[i][1] = 0.0;
+    stress[i][2] = 0.0;
+    stress[i][3] = 0.0;
+    stress[i][4] = 0.0;
+    stress[i][5] = 0.0;
+  }
+
+  for (int i=0; i < size_vector; ++i)
+    vector[i] = heatj[i] = 0.0;
+
+  did_setup = update->ntimestep;
+}
+
+/* ---------------------------------------------------------------------- */
+void ComputeHeatFluxTally::pair_tally_callback(int i, int j, int nlocal, int newton,
+                                             double evdwl, double ecoul, double fpair,
+                                             double dx, double dy, double dz)
+{
+  const int * const mask = atom->mask;
+
+  if ( ((mask[i] & groupbit) && (mask[j] & groupbit2))
+       || ((mask[i] & groupbit2) && (mask[j] & groupbit)) ) {
+
+    const double epairhalf = 0.5 * (evdwl + ecoul);
+    fpair *= 0.5;
+    const double v0 = dx*dx*fpair;  // dx*fpair = Fij_x
+    const double v1 = dy*dy*fpair;
+    const double v2 = dz*dz*fpair;
+    const double v3 = dx*dy*fpair;
+    const double v4 = dx*dz*fpair;
+    const double v5 = dy*dz*fpair;
+
+    if (newton || i < nlocal) {
+      eatom[i] += epairhalf;
+      stress[i][0] += v0;
+      stress[i][1] += v1;
+      stress[i][2] += v2;
+      stress[i][3] += v3;
+      stress[i][4] += v4;
+      stress[i][5] += v5;
+    }
+    if (newton || j < nlocal) {
+      eatom[j] += epairhalf;
+      stress[j][0] += v0;
+      stress[j][1] += v1;
+      stress[j][2] += v2;
+      stress[j][3] += v3;
+      stress[j][4] += v4;
+      stress[j][5] += v5;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int ComputeHeatFluxTally::pack_reverse_comm(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    buf[m++] = eatom[i];
+    buf[m++] = stress[i][0];
+    buf[m++] = stress[i][1];
+    buf[m++] = stress[i][2];
+    buf[m++] = stress[i][3];
+    buf[m++] = stress[i][4];
+    buf[m++] = stress[i][5];
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeHeatFluxTally::unpack_reverse_comm(int n, int *list, double *buf)
+{
+  int i,j,m;
+
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    eatom[j] += buf[m++];
+    stress[j][0] += buf[m++];
+    stress[j][1] += buf[m++];
+    stress[j][2] += buf[m++];
+    stress[j][3] += buf[m++];
+    stress[j][4] += buf[m++];
+    stress[j][5] += buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeHeatFluxTally::compute_vector()
+{
+  invoked_vector = update->ntimestep;
+  if ((did_setup != invoked_vector) || (update->eflag_global != invoked_vector))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // collect contributions from ghost atoms
+
+  if (force->newton_pair) {
+    comm->reverse_comm_compute(this);
+
+    const int nall = atom->nlocal + atom->nghost;
+    for (int i = atom->nlocal; i < nall; ++i) {
+      eatom[i] = 0.0;
+      stress[i][0] = 0.0;
+      stress[i][1] = 0.0;
+      stress[i][2] = 0.0;
+      stress[i][3] = 0.0;
+      stress[i][4] = 0.0;
+      stress[i][5] = 0.0;
+    }
+  }
+
+  // compute heat currents
+  // heat flux vector = jc[3] + jv[3]
+  // jc[3] = convective portion of heat flux = sum_i (ke_i + pe_i) v_i[3]
+  // jv[3] = virial portion of heat flux = sum_i (stress_tensor_i . v_i[3])
+  // normalization by volume is not included
+  // J = sum_i( (0.5*m*v_i^2 + 0.5*(evdwl_i+ecoul_i))*v_i +
+  //              + (F_ij . v_i)*dR_ij/2 )
+
+  int nlocal = atom->nlocal;
+  int *mask = atom->mask;
+  const double pfactor = 0.5 * force->mvv2e;
+  double **v = atom->v;
+  double *mass = atom->mass;
+  double *rmass = atom->rmass;
+  int *type = atom->type;
+
+  double jc[3] = {0.0,0.0,0.0};
+  double jv[3] = {0.0,0.0,0.0};
+
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      const double * const vi = v[i];
+      const double * const si = stress[i];
+      double ke_i;
+
+      if (rmass) ke_i = pfactor * rmass[i];
+      else ke_i = pfactor * mass[type[i]];
+      ke_i *= (vi[0]*vi[0] + vi[1]*vi[1] + vi[2]*vi[2]);
+      ke_i += eatom[i];
+
+      jc[0] += ke_i*vi[0];
+      jc[1] += ke_i*vi[1];
+      jc[2] += ke_i*vi[2];
+      jv[0] += si[0]*vi[0] + si[3]*vi[1] + si[4]*vi[2];
+      jv[1] += si[3]*vi[0] + si[1]*vi[1] + si[5]*vi[2];
+      jv[2] += si[4]*vi[0] + si[5]*vi[1] + si[2]*vi[2];
+    }
+  }
+
+  // sum accumulated heatj across procs
+  heatj[0] = jc[0] + jv[0];
+  heatj[1] = jc[1] + jv[1];
+  heatj[2] = jc[2] + jv[2];
+  heatj[3] = jc[0];
+  heatj[4] = jc[1];
+  heatj[5] = jc[2];
+  MPI_Allreduce(heatj,vector,size_vector,MPI_DOUBLE,MPI_SUM,world);
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double ComputeHeatFluxTally::memory_usage()
+{
+  double bytes = (nmax < 0) ? 0 : nmax*comm_reverse * sizeof(double);
+  return bytes;
+}
+
diff -uN src/compute_heat_flux_tally.h src_DFT-CES2/compute_heat_flux_tally.h
--- src/compute_heat_flux_tally.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_heat_flux_tally.h	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,66 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(heat/flux/tally,ComputeHeatFluxTally)
+
+#else
+
+#ifndef LMP_COMPUTE_HEAT_FLUX_TALLY_H
+#define LMP_COMPUTE_HEAT_FLUX_TALLY_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputeHeatFluxTally : public Compute {
+
+ public:
+  ComputeHeatFluxTally(class LAMMPS *, int, char **);
+  virtual ~ComputeHeatFluxTally();
+
+  void init();
+
+  void compute_vector();
+
+  int pack_reverse_comm(int, int, double *);
+  void unpack_reverse_comm(int, int *, double *);
+  double memory_usage();
+
+  void pair_setup_callback(int, int);
+  void pair_tally_callback(int, int, int, int,
+                           double, double, double,
+                           double, double, double);
+
+ private:
+  bigint did_setup;
+  int nmax,igroup2,groupbit2;
+  double **stress,*eatom;
+  double *heatj;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+*/
diff -uN src/compute_ke_rigid.cpp src_DFT-CES2/compute_ke_rigid.cpp
--- src/compute_ke_rigid.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_ke_rigid.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,73 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <mpi.h>
+#include <string.h>
+#include "compute_ke_rigid.h"
+#include "update.h"
+#include "force.h"
+#include "modify.h"
+#include "fix.h"
+#include "fix_rigid.h"
+#include "fix_rigid_small.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ComputeKERigid::ComputeKERigid(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg), rfix(NULL)
+{
+  if (narg != 4) error->all(FLERR,"Illegal compute ke/rigid command");
+
+  scalar_flag = 1;
+  extscalar = 1;
+
+  int n = strlen(arg[3]) + 1;
+  rfix = new char[n];
+  strcpy(rfix,arg[3]);
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputeKERigid::~ComputeKERigid()
+{
+  delete [] rfix;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeKERigid::init()
+{
+  irfix = modify->find_fix(rfix);
+  if (irfix < 0) error->all(FLERR,"Fix ID for compute ke/rigid does not exist");
+
+  if (strncmp(modify->fix[irfix]->style,"rigid",5))
+    error->all(FLERR,"Compute ke/rigid with non-rigid fix-ID");
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ComputeKERigid::compute_scalar()
+{
+  invoked_scalar = update->ntimestep;
+
+  if (strncmp(modify->fix[irfix]->style,"rigid",5) == 0) {
+    if (strstr(modify->fix[irfix]->style,"/small")) {
+      scalar = ((FixRigidSmall *) modify->fix[irfix])->extract_ke();
+    } else scalar = ((FixRigid *) modify->fix[irfix])->extract_ke();
+  }
+  scalar *= force->mvv2e;
+  return scalar;
+}
diff -uN src/compute_ke_rigid.h src_DFT-CES2/compute_ke_rigid.h
--- src/compute_ke_rigid.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_ke_rigid.h	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,60 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(ke/rigid,ComputeKERigid)
+
+#else
+
+#ifndef LMP_COMPUTE_KE_RIGID_H
+#define LMP_COMPUTE_KE_RIGID_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputeKERigid : public Compute {
+ public:
+  ComputeKERigid(class LAMMPS *, int, char **);
+  ~ComputeKERigid();
+  void init();
+  double compute_scalar();
+
+ private:
+  int irfix;
+  char *rfix;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Fix ID for compute ke/rigid does not exist
+
+Self-explanatory.
+
+E: Compute ke/rigid with non-rigid fix-ID
+
+Self-explanatory.
+
+*/
diff -uN src/computemodels.h src_DFT-CES2/computemodels.h
--- src/computemodels.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/computemodels.h	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,18 @@
+#ifndef _COMPUTEMODELS_H
+#define _COMPUTEMODELS_H
+
+#include "mkl_types.h"
+
+typedef struct
+{
+	// HOST_WORLD, GLOBAL DATA
+	double cell_Bohr[3]; // x, y, and z-directional cell parameters, in atomic unit	
+
+	// HOST_WORLD, GRID DATA
+	int N[3];			 // Global 3-D grid dimensions
+	MKL_Complex8 *cplx_gauss;	// (input) cellParams unit Bohr
+	MKL_Complex8 *cplx_Ptr;
+
+} compute_Models;
+
+#endif
diff -uN src/compute_pe_mol_tally.cpp src_DFT-CES2/compute_pe_mol_tally.cpp
--- src/compute_pe_mol_tally.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_pe_mol_tally.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,129 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "compute_pe_mol_tally.h"
+#include "atom.h"
+#include "group.h"
+#include "pair.h"
+#include "update.h"
+#include "memory.h"
+#include "error.h"
+#include "force.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ComputePEMolTally::ComputePEMolTally(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg)
+{
+  if (narg < 4) error->all(FLERR,"Illegal compute pe/mol/tally command");
+
+  igroup2 = group->find(arg[3]);
+  if (igroup2 == -1)
+    error->all(FLERR,"Could not find compute pe/mol/tally second group ID");
+  groupbit2 = group->bitmask[igroup2];
+
+  vector_flag = 1;
+  size_vector = 4;
+  timeflag = 1;
+
+  extvector = 1;
+  peflag = 1;                   // we need Pair::ev_tally() to be run
+
+  did_setup = invoked_vector = -1;
+  vector = new double[size_vector];
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputePEMolTally::~ComputePEMolTally()
+{
+  if (force && force->pair) force->pair->del_tally_callback(this);
+  delete[] vector;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputePEMolTally::init()
+{
+  if (force->pair == NULL)
+    error->all(FLERR,"Trying to use compute pe/mol/tally without pair style");
+  else
+    force->pair->add_tally_callback(this);
+
+  if (atom->molecule_flag == 0)
+    error->all(FLERR,"Compute pe/mol/tally requires molecule IDs");
+
+  if (comm->me == 0) {
+    if (force->pair->single_enable == 0 || force->pair->manybody_flag)
+      error->warning(FLERR,"Compute pe/mol/tally used with incompatible pair style");
+
+    if (force->bond || force->angle || force->dihedral
+                    || force->improper || force->kspace)
+      error->warning(FLERR,"Compute pe/mol/tally only called from pair style");
+  }
+  did_setup = -1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputePEMolTally::pair_setup_callback(int, int)
+{
+  etotal[0] = etotal[1] = etotal[2] = etotal[3] = 0.0;
+  did_setup = update->ntimestep;
+}
+
+/* ---------------------------------------------------------------------- */
+void ComputePEMolTally::pair_tally_callback(int i, int j, int nlocal, int newton,
+                                         double evdwl, double ecoul, double,
+                                         double, double, double)
+{
+  const int * const mask = atom->mask;
+  const tagint * const molid = atom->molecule;
+
+  if ( ((mask[i] & groupbit) && (mask[j] & groupbit2))
+     || ((mask[i] & groupbit2) && (mask[j] & groupbit)) ){
+
+    evdwl *= 0.5; ecoul *= 0.5;
+    if (newton || i < nlocal) {
+      if (molid[i] == molid[j]) {
+        etotal[0] += evdwl; etotal[1] += ecoul;
+      } else {
+        etotal[2] += evdwl; etotal[3] += ecoul;
+      }
+    }
+    if (newton || j < nlocal) {
+      if (molid[i] == molid[j]) {
+        etotal[0] += evdwl; etotal[1] += ecoul;
+      } else {
+        etotal[2] += evdwl; etotal[3] += ecoul;
+      }
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputePEMolTally::compute_vector()
+{
+  invoked_vector = update->ntimestep;
+  if ((did_setup != invoked_vector) || (update->eflag_global != invoked_vector))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // sum accumulated energies across procs
+
+  MPI_Allreduce(etotal,vector,size_vector,MPI_DOUBLE,MPI_SUM,world);
+}
+
diff -uN src/compute_pe_mol_tally.h src_DFT-CES2/compute_pe_mol_tally.h
--- src/compute_pe_mol_tally.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_pe_mol_tally.h	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,60 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(pe/mol/tally,ComputePEMolTally)
+
+#else
+
+#ifndef LMP_COMPUTE_PE_MOL_TALLY_H
+#define LMP_COMPUTE_PE_MOL_TALLY_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputePEMolTally : public Compute {
+
+ public:
+  ComputePEMolTally(class LAMMPS *, int, char **);
+  virtual ~ComputePEMolTally();
+
+  void init();
+  void compute_vector();
+
+  void pair_setup_callback(int, int);
+  void pair_tally_callback(int, int, int, int,
+                           double, double, double,
+                           double, double, double);
+
+ private:
+  bigint did_setup;
+  int igroup2,groupbit2;
+  double etotal[4];
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+*/
diff -uN src/compute_pe_tally.cpp src_DFT-CES2/compute_pe_tally.cpp
--- src/compute_pe_tally.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_pe_tally.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,205 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "compute_pe_tally.h"
+#include "atom.h"
+#include "group.h"
+#include "pair.h"
+#include "update.h"
+#include "memory.h"
+#include "error.h"
+#include "force.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ComputePETally::ComputePETally(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg)
+{
+  if (narg < 4) error->all(FLERR,"Illegal compute pe/tally command");
+
+  igroup2 = group->find(arg[3]);
+  if (igroup2 == -1)
+    error->all(FLERR,"Could not find compute pe/tally second group ID");
+  groupbit2 = group->bitmask[igroup2];
+
+  scalar_flag = 1;
+  vector_flag = 0;
+  peratom_flag = 1;
+  timeflag = 1;
+
+  comm_reverse = size_peratom_cols = 2;
+  extscalar = 1;
+  peflag = 1;                   // we need Pair::ev_tally() to be run
+
+  did_setup = invoked_peratom = invoked_scalar = -1;
+  nmax = -1;
+  eatom = NULL;
+  vector = new double[size_peratom_cols];
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputePETally::~ComputePETally()
+{
+  if (force && force->pair) force->pair->del_tally_callback(this);
+  memory->destroy(eatom);
+  delete[] vector;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputePETally::init()
+{
+  if (force->pair == NULL)
+    error->all(FLERR,"Trying to use compute pe/tally without a pair style");
+  else
+    force->pair->add_tally_callback(this);
+
+  if (comm->me == 0) {
+    if (force->pair->single_enable == 0 || force->pair->manybody_flag)
+      error->warning(FLERR,"Compute pe/tally used with incompatible pair style");
+
+    if (force->bond || force->angle || force->dihedral
+                    || force->improper || force->kspace)
+      error->warning(FLERR,"Compute pe/tally only called from pair style");
+  }
+  did_setup = -1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputePETally::pair_setup_callback(int, int)
+{
+  const int ntotal = atom->nlocal + atom->nghost;
+
+  // grow per-atom storage, if needed
+
+  if (atom->nmax > nmax) {
+    memory->destroy(eatom);
+    nmax = atom->nmax;
+    memory->create(eatom,nmax,size_peratom_cols,"pe/tally:eatom");
+    array_atom = eatom;
+  }
+
+  // clear storage
+
+  for (int i=0; i < ntotal; ++i)
+    eatom[i][0] = eatom[i][1] = 0.0;
+
+  vector[0] = etotal[0] = vector[1] = etotal[1] = 0.0;
+
+  did_setup = update->ntimestep;
+}
+
+/* ---------------------------------------------------------------------- */
+void ComputePETally::pair_tally_callback(int i, int j, int nlocal, int newton,
+                                         double evdwl, double ecoul, double,
+                                         double, double, double)
+{
+  const int * const mask = atom->mask;
+
+  if ( ((mask[i] & groupbit) && (mask[j] & groupbit2))
+       || ((mask[i] & groupbit2) && (mask[j] & groupbit)) ) {
+
+    evdwl *= 0.5; ecoul *= 0.5;
+    if (newton || i < nlocal) {
+      etotal[0] += evdwl; eatom[i][0] += evdwl;
+      etotal[1] += ecoul; eatom[i][1] += ecoul;
+    }
+    if (newton || j < nlocal) {
+      etotal[0] += evdwl; eatom[j][0] += evdwl;
+      etotal[1] += ecoul; eatom[j][1] += ecoul;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int ComputePETally::pack_reverse_comm(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    buf[m++] = eatom[i][0];
+    buf[m++] = eatom[i][1];
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputePETally::unpack_reverse_comm(int n, int *list, double *buf)
+{
+  int i,j,m;
+
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    eatom[j][0] += buf[m++];
+    eatom[j][1] += buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ComputePETally::compute_scalar()
+{
+  invoked_scalar = update->ntimestep;
+  if ((did_setup != invoked_scalar)
+      || (update->eflag_global != invoked_scalar))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // sum accumulated energies across procs
+
+  MPI_Allreduce(etotal,vector,size_peratom_cols,MPI_DOUBLE,MPI_SUM,world);
+
+  scalar = vector[0]+vector[1];
+  return scalar;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputePETally::compute_peratom()
+{
+  invoked_peratom = update->ntimestep;
+  if ((did_setup != invoked_peratom)
+      || (update->eflag_global != invoked_peratom))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // collect contributions from ghost atoms
+
+  if (force->newton_pair) {
+    comm->reverse_comm_compute(this);
+
+    // clear out ghost atom data after it has been collected to local atoms
+    const int nall = atom->nlocal + atom->nghost;
+    for (int i = atom->nlocal; i < nall; ++i)
+      eatom[i][0] = eatom[i][1] = 0.0;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double ComputePETally::memory_usage()
+{
+  double bytes = (nmax < 0) ? 0 : nmax*size_peratom_cols * sizeof(double);
+  return bytes;
+}
+
diff -uN src/compute_pe_tally.h src_DFT-CES2/compute_pe_tally.h
--- src/compute_pe_tally.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_pe_tally.h	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,67 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(pe/tally,ComputePETally)
+
+#else
+
+#ifndef LMP_COMPUTE_PETALLY_H
+#define LMP_COMPUTE_PETALLY_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputePETally : public Compute {
+
+ public:
+  ComputePETally(class LAMMPS *, int, char **);
+  virtual ~ComputePETally();
+
+  void init();
+
+  double compute_scalar();
+  void compute_peratom();
+
+  int pack_reverse_comm(int, int, double *);
+  void unpack_reverse_comm(int, int *, double *);
+  double memory_usage();
+
+  void pair_setup_callback(int, int);
+  void pair_tally_callback(int, int, int, int,
+                           double, double, double,
+                           double, double, double);
+
+ private:
+  bigint did_setup;
+  int nmax,igroup2,groupbit2;
+  double **eatom;
+  double etotal[2];
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+*/
diff -uN src/compute_rigid_local.cpp src_DFT-CES2/compute_rigid_local.cpp
--- src/compute_rigid_local.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_rigid_local.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,320 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <string.h>
+#include "compute_rigid_local.h"
+#include "atom.h"
+#include "update.h"
+#include "domain.h"
+#include "modify.h"
+#include "fix_rigid_small.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+#define DELTA 10000
+
+enum{ID,MOL,MASS,X,Y,Z,XU,YU,ZU,VX,VY,VZ,FX,FY,FZ,IX,IY,IZ,
+     TQX,TQY,TQZ,OMEGAX,OMEGAY,OMEGAZ,ANGMOMX,ANGMOMY,ANGMOMZ,
+     QUATW,QUATI,QUATJ,QUATK,INERTIAX,INERTIAY,INERTIAZ};
+
+/* ---------------------------------------------------------------------- */
+
+ComputeRigidLocal::ComputeRigidLocal(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg), 
+  rstyle(NULL), idrigid(NULL), fixrigid(NULL), vlocal(NULL), alocal(NULL)
+{
+  if (narg < 5) error->all(FLERR,"Illegal compute rigid/local command");
+
+  local_flag = 1;
+  nvalues = narg - 4;
+  if (nvalues == 1) size_local_cols = 0;
+  else size_local_cols = nvalues;
+
+  int n = strlen(arg[3]) + 1;
+  idrigid = new char[n];
+  strcpy(idrigid,arg[3]);
+
+  rstyle = new int[nvalues];
+
+  nvalues = 0;
+  for (int iarg = 4; iarg < narg; iarg++) {
+    if (strcmp(arg[iarg],"id") == 0) rstyle[nvalues++] = ID;
+    else if (strcmp(arg[iarg],"mol") == 0) rstyle[nvalues++] = MOL;
+    else if (strcmp(arg[iarg],"mass") == 0) rstyle[nvalues++] = MASS;
+    else if (strcmp(arg[iarg],"x") == 0) rstyle[nvalues++] = X;
+    else if (strcmp(arg[iarg],"y") == 0) rstyle[nvalues++] = Y;
+    else if (strcmp(arg[iarg],"z") == 0) rstyle[nvalues++] = Z;
+    else if (strcmp(arg[iarg],"xu") == 0) rstyle[nvalues++] = XU;
+    else if (strcmp(arg[iarg],"yu") == 0) rstyle[nvalues++] = YU;
+    else if (strcmp(arg[iarg],"zu") == 0) rstyle[nvalues++] = ZU;
+    else if (strcmp(arg[iarg],"vx") == 0) rstyle[nvalues++] = VX;
+    else if (strcmp(arg[iarg],"vy") == 0) rstyle[nvalues++] = VY;
+    else if (strcmp(arg[iarg],"vz") == 0) rstyle[nvalues++] = VZ;
+    else if (strcmp(arg[iarg],"fx") == 0) rstyle[nvalues++] = FX;
+    else if (strcmp(arg[iarg],"fy") == 0) rstyle[nvalues++] = FY;
+    else if (strcmp(arg[iarg],"fz") == 0) rstyle[nvalues++] = FZ;
+    else if (strcmp(arg[iarg],"ix") == 0) rstyle[nvalues++] = IX;
+    else if (strcmp(arg[iarg],"iy") == 0) rstyle[nvalues++] = IY;
+    else if (strcmp(arg[iarg],"iz") == 0) rstyle[nvalues++] = IZ;
+    else if (strcmp(arg[iarg],"tqx") == 0) rstyle[nvalues++] = TQX;
+    else if (strcmp(arg[iarg],"tqy") == 0) rstyle[nvalues++] = TQY;
+    else if (strcmp(arg[iarg],"tqz") == 0) rstyle[nvalues++] = TQZ;
+    else if (strcmp(arg[iarg],"omegax") == 0) rstyle[nvalues++] = OMEGAX;
+    else if (strcmp(arg[iarg],"omegay") == 0) rstyle[nvalues++] = OMEGAY;
+    else if (strcmp(arg[iarg],"omegaz") == 0) rstyle[nvalues++] = OMEGAZ;
+    else if (strcmp(arg[iarg],"angmomx") == 0) rstyle[nvalues++] = ANGMOMX;
+    else if (strcmp(arg[iarg],"angmomy") == 0) rstyle[nvalues++] = ANGMOMY;
+    else if (strcmp(arg[iarg],"angmomz") == 0) rstyle[nvalues++] = ANGMOMZ;
+    else if (strcmp(arg[iarg],"quatw") == 0) rstyle[nvalues++] = QUATW;
+    else if (strcmp(arg[iarg],"quati") == 0) rstyle[nvalues++] = QUATI;
+    else if (strcmp(arg[iarg],"quatj") == 0) rstyle[nvalues++] = QUATJ;
+    else if (strcmp(arg[iarg],"quatk") == 0) rstyle[nvalues++] = QUATK;
+    else if (strcmp(arg[iarg],"inertiax") == 0) rstyle[nvalues++] = INERTIAX;
+    else if (strcmp(arg[iarg],"inertiay") == 0) rstyle[nvalues++] = INERTIAY;
+    else if (strcmp(arg[iarg],"inertiaz") == 0) rstyle[nvalues++] = INERTIAZ;
+    else error->all(FLERR,"Invalid keyword in compute rigid/local command");
+  }
+
+  ncount = nmax = 0;
+  vlocal = NULL;
+  alocal = NULL;
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputeRigidLocal::~ComputeRigidLocal()
+{
+  memory->destroy(vlocal);
+  memory->destroy(alocal);
+  delete [] idrigid;
+  delete [] rstyle;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeRigidLocal::init()
+{
+  // set fixrigid
+
+  int ifix = modify->find_fix(idrigid);
+  if (ifix < 0)
+    error->all(FLERR,"FixRigidSmall ID for compute rigid/local does not exist");
+  fixrigid = (FixRigidSmall *) modify->fix[ifix];
+
+  int flag = 0;
+  if (strstr(fixrigid->style,"rigid/") == NULL) flag = 1;
+  if (strstr(fixrigid->style,"/small") == NULL) flag = 1;
+  if (flag)
+    error->all(FLERR,"Compute rigid/local does not use fix rigid/small fix");
+
+  // do initial memory allocation so that memory_usage() is correct
+
+  ncount = compute_rigid(0);
+  if (ncount > nmax) reallocate(ncount);
+  size_local_rows = ncount;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeRigidLocal::compute_local()
+{
+  invoked_local = update->ntimestep;
+
+  // count local entries and compute bond info
+
+  ncount = compute_rigid(0);
+  if (ncount > nmax) reallocate(ncount);
+  size_local_rows = ncount;
+  ncount = compute_rigid(1);
+}
+
+/* ----------------------------------------------------------------------
+   count rigid bodies and compute rigid info on this proc
+   if flag is set, compute requested info about rigid body
+   owning atom of rigid body must be in group
+------------------------------------------------------------------------- */
+
+int ComputeRigidLocal::compute_rigid(int flag)
+{
+  int i,m,n,ibody;
+  double *ptr;
+  FixRigidSmall::Body *body;
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  m = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (!(mask[i] & groupbit)) continue;
+    ibody = fixrigid->bodyown[i];
+    if (ibody < 0) continue;
+    body = &fixrigid->body[ibody];
+
+    if (flag) {
+      if (nvalues == 1) ptr = &vlocal[m];
+      else ptr = alocal[m];
+
+      for (n = 0; n < nvalues; n++) {
+        switch (rstyle[n]) {
+        case ID:
+          ptr[n] = tag[body->ilocal];
+          break;
+        case MOL:
+          ptr[n] = molecule[body->ilocal];
+          break;
+        case MASS:
+          ptr[n] = body->mass;
+          break;
+        case X:
+          ptr[n] = body->xcm[0];
+          break;
+        case Y:
+          ptr[n] = body->xcm[1];
+          break;
+        case Z:
+          ptr[n] = body->xcm[2];
+          break;
+        case XU:
+          ptr[n] = body->xcm[0] + 
+            ((body->image & IMGMASK) - IMGMAX) * xprd;
+          break;
+        case YU:
+          ptr[n] = body->xcm[1] + 
+            ((body->image >> IMGBITS & IMGMASK) - IMGMAX) * yprd;
+          break;
+        case ZU:
+          ptr[n] = body->xcm[2] +
+            ((body->image >> IMG2BITS) - IMGMAX) * zprd;
+          break;
+        case VX:
+          ptr[n] = body->vcm[0];
+          break;
+        case VY:
+          ptr[n] = body->vcm[1];
+          break;
+        case VZ:
+          ptr[n] = body->vcm[2];
+          break;
+        case FX:
+          ptr[n] = body->fcm[0];
+          break;
+        case FY:
+          ptr[n] = body->fcm[1];
+          break;
+        case FZ:
+          ptr[n] = body->fcm[2];
+          break;
+        case IX:
+          ptr[n] = (body->image & IMGMASK) - IMGMAX;
+          break;
+        case IY:
+          ptr[n] = (body->image >> IMGBITS & IMGMASK) - IMGMAX;
+          break;
+        case IZ:
+          ptr[n] = (body->image >> IMG2BITS) - IMGMAX;
+          break;
+        case TQX:
+          ptr[n] = body->torque[0];
+          break;
+        case TQY:
+          ptr[n] = body->torque[1];
+          break;
+        case TQZ:
+          ptr[n] = body->torque[2];
+          break;
+        case OMEGAX:
+          ptr[n] = body->omega[0];
+          break;
+        case OMEGAY:
+          ptr[n] = body->omega[1];
+          break;
+        case OMEGAZ:
+          ptr[n] = body->omega[2];
+          break;
+        case ANGMOMX:
+          ptr[n] = body->angmom[0];
+          break;
+        case ANGMOMY:
+          ptr[n] = body->angmom[1];
+          break;
+        case ANGMOMZ:
+          ptr[n] = body->angmom[2];
+          break;
+        case QUATW:
+          ptr[n] = body->quat[0];
+          break;
+        case QUATI:
+          ptr[n] = body->quat[1];
+          break;
+        case QUATJ:
+          ptr[n] = body->quat[2];
+          break;
+        case QUATK:
+          ptr[n] = body->quat[3];
+          break;
+        case INERTIAX:
+          ptr[n] = body->inertia[0];
+          break;
+        case INERTIAY:
+          ptr[n] = body->inertia[1];
+          break;
+        case INERTIAZ:
+          ptr[n] = body->inertia[2];
+          break;
+        }
+      }
+    }
+
+    m++;
+  }
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeRigidLocal::reallocate(int n)
+{
+  // grow vector_local or array_local
+
+  while (nmax < n) nmax += DELTA;
+
+  if (nvalues == 1) {
+    memory->destroy(vlocal);
+    memory->create(vlocal,nmax,"rigid/local:vector_local");
+    vector_local = vlocal;
+  } else {
+    memory->destroy(alocal);
+    memory->create(alocal,nmax,nvalues,"rigid/local:array_local");
+    array_local = alocal;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local data
+------------------------------------------------------------------------- */
+
+double ComputeRigidLocal::memory_usage()
+{
+  double bytes = nmax*nvalues * sizeof(double);
+  return bytes;
+}
diff -uN src/compute_rigid_local.h src_DFT-CES2/compute_rigid_local.h
--- src/compute_rigid_local.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_rigid_local.h	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,76 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(rigid/local,ComputeRigidLocal)
+
+#else
+
+#ifndef LMP_COMPUTE_RIGID_LOCAL_H
+#define LMP_COMPUTE_RIGID_LOCAL_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputeRigidLocal : public Compute {
+ public:
+  ComputeRigidLocal(class LAMMPS *, int, char **);
+  ~ComputeRigidLocal();
+  void init();
+  void compute_local();
+  double memory_usage();
+
+ private:
+  int nvalues;
+  int ncount;
+  int *rstyle;
+
+  char *idrigid;
+  class FixRigidSmall *fixrigid;
+
+  int nmax;
+  double *vlocal;
+  double **alocal;
+
+  int compute_rigid(int);
+  void reallocate(int);
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Compute bond/local used when bonds are not allowed
+
+The atom style does not support bonds.
+
+E: Invalid keyword in compute bond/local command
+
+Self-explanatory.
+
+E: No bond style is defined for compute bond/local
+
+Self-explanatory.
+
+*/
diff -uN src/compute_stress_tally.cpp src_DFT-CES2/compute_stress_tally.cpp
--- src/compute_stress_tally.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_stress_tally.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,248 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "compute_stress_tally.h"
+#include "atom.h"
+#include "group.h"
+#include "pair.h"
+#include "update.h"
+#include "memory.h"
+#include "error.h"
+#include "force.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ComputeStressTally::ComputeStressTally(LAMMPS *lmp, int narg, char **arg) :
+  Compute(lmp, narg, arg)
+{
+  if (narg < 4) error->all(FLERR,"Illegal compute stress/tally command");
+
+  igroup2 = group->find(arg[3]);
+  if (igroup2 == -1)
+    error->all(FLERR,"Could not find compute stress/tally second group ID");
+  groupbit2 = group->bitmask[igroup2];
+
+  scalar_flag = 1;
+  vector_flag = 0;
+  peratom_flag = 1;
+  timeflag = 1;
+
+  comm_reverse = size_peratom_cols = 6;
+  extscalar = 0;
+  peflag = 1;                   // we need Pair::ev_tally() to be run
+
+  did_setup = invoked_peratom = invoked_scalar = -1;
+  nmax = -1;
+  stress = NULL;
+  vector = new double[size_peratom_cols];
+  virial = new double[size_peratom_cols];
+}
+
+/* ---------------------------------------------------------------------- */
+
+ComputeStressTally::~ComputeStressTally()
+{
+  if (force && force->pair) force->pair->del_tally_callback(this);
+  memory->destroy(stress);
+  delete[] virial;
+  delete[] vector;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeStressTally::init()
+{
+  if (force->pair == NULL)
+    error->all(FLERR,"Trying to use compute stress/tally without pair style");
+  else
+    force->pair->add_tally_callback(this);
+
+  if (comm->me == 0) {
+    if (force->pair->single_enable == 0 || force->pair->manybody_flag)
+      error->warning(FLERR,"Compute stress/tally used with incompatible pair style");
+
+    if (force->bond || force->angle || force->dihedral
+                    || force->improper || force->kspace)
+      error->warning(FLERR,"Compute stress/tally only called from pair style");
+  }
+  did_setup = -1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeStressTally::pair_setup_callback(int, int)
+{
+  const int ntotal = atom->nlocal + atom->nghost;
+
+  // grow per-atom storage, if needed
+
+  if (atom->nmax > nmax) {
+    memory->destroy(stress);
+    nmax = atom->nmax;
+    memory->create(stress,nmax,size_peratom_cols,"stress/tally:stress");
+    array_atom = stress;
+  }
+
+  // clear storage
+
+  for (int i=0; i < ntotal; ++i)
+    for (int j=0; j < size_peratom_cols; ++j)
+      stress[i][j] = 0.0;
+
+  for (int i=0; i < size_peratom_cols; ++i)
+    vector[i] = virial[i] = 0.0;
+
+  did_setup = update->ntimestep;
+}
+
+/* ---------------------------------------------------------------------- */
+void ComputeStressTally::pair_tally_callback(int i, int j, int nlocal, int newton,
+                                             double, double, double fpair,
+                                             double dx, double dy, double dz)
+{
+  const int * const mask = atom->mask;
+
+  if ( ((mask[i] & groupbit) && (mask[j] & groupbit2))
+       || ((mask[i] & groupbit2) && (mask[j] & groupbit)) ) {
+
+    fpair *= 0.5;
+    const double v0 = dx*dx*fpair;
+    const double v1 = dy*dy*fpair;
+    const double v2 = dz*dz*fpair;
+    const double v3 = dx*dy*fpair;
+    const double v4 = dx*dz*fpair;
+    const double v5 = dy*dz*fpair;
+
+    if (newton || i < nlocal) {
+      virial[0] += v0; stress[i][0] += v0;
+      virial[1] += v1; stress[i][1] += v1;
+      virial[2] += v2; stress[i][2] += v2;
+      virial[3] += v3; stress[i][3] += v3;
+      virial[4] += v4; stress[i][4] += v4;
+      virial[5] += v5; stress[i][5] += v5;
+    }
+    if (newton || j < nlocal) {
+      virial[0] += v0; stress[j][0] += v0;
+      virial[1] += v1; stress[j][1] += v1;
+      virial[2] += v2; stress[j][2] += v2;
+      virial[3] += v3; stress[j][3] += v3;
+      virial[4] += v4; stress[j][4] += v4;
+      virial[5] += v5; stress[j][5] += v5;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int ComputeStressTally::pack_reverse_comm(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    buf[m++] = stress[i][0];
+    buf[m++] = stress[i][1];
+    buf[m++] = stress[i][2];
+    buf[m++] = stress[i][3];
+    buf[m++] = stress[i][4];
+    buf[m++] = stress[i][5];
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeStressTally::unpack_reverse_comm(int n, int *list, double *buf)
+{
+  int i,j,m;
+
+  m = 0;
+  for (i = 0; i < n; i++) {
+    j = list[i];
+    stress[j][0] += buf[m++];
+    stress[j][1] += buf[m++];
+    stress[j][2] += buf[m++];
+    stress[j][3] += buf[m++];
+    stress[j][4] += buf[m++];
+    stress[j][5] += buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ComputeStressTally::compute_scalar()
+{
+  invoked_scalar = update->ntimestep;
+  if ((did_setup != invoked_scalar)
+      || (update->eflag_global != invoked_scalar))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // sum accumulated forces across procs
+
+  MPI_Allreduce(virial,vector,size_peratom_cols,MPI_DOUBLE,MPI_SUM,world);
+
+  if (domain->dimension == 3)
+    scalar = (vector[0]+vector[1]+vector[2])/3.0;
+  else
+    scalar = (vector[0]+vector[1])/2.0;
+
+  return scalar;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ComputeStressTally::compute_peratom()
+{
+  invoked_peratom = update->ntimestep;
+  if ((did_setup != invoked_peratom)
+      || (update->eflag_global != invoked_peratom))
+    error->all(FLERR,"Energy was not tallied on needed timestep");
+
+  // collect contributions from ghost atoms
+
+  if (force->newton_pair) {
+    comm->reverse_comm_compute(this);
+
+    const int nall = atom->nlocal + atom->nghost;
+    for (int i = atom->nlocal; i < nall; ++i)
+      for (int j = 0; j < size_peratom_cols; ++j)
+        stress[i][j] = 0.0;
+  }
+
+  // convert to stress*volume units = -pressure*volume
+
+  const double nktv2p = -force->nktv2p;
+  for (int i = 0; i < atom->nlocal; i++) {
+    stress[i][0] *= nktv2p;
+    stress[i][1] *= nktv2p;
+    stress[i][2] *= nktv2p;
+    stress[i][3] *= nktv2p;
+    stress[i][4] *= nktv2p;
+    stress[i][5] *= nktv2p;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based array
+------------------------------------------------------------------------- */
+
+double ComputeStressTally::memory_usage()
+{
+  double bytes = (nmax < 0) ? 0 : nmax*size_peratom_cols * sizeof(double);
+  return bytes;
+}
+
diff -uN src/compute_stress_tally.h src_DFT-CES2/compute_stress_tally.h
--- src/compute_stress_tally.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/compute_stress_tally.h	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,67 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef COMPUTE_CLASS
+
+ComputeStyle(stress/tally,ComputeStressTally)
+
+#else
+
+#ifndef LMP_COMPUTE_STRESS_TALLY_H
+#define LMP_COMPUTE_STRESS_TALLY_H
+
+#include "compute.h"
+
+namespace LAMMPS_NS {
+
+class ComputeStressTally : public Compute {
+
+ public:
+  ComputeStressTally(class LAMMPS *, int, char **);
+  virtual ~ComputeStressTally();
+
+  void init();
+
+  double compute_scalar();
+  void compute_peratom();
+
+  int pack_reverse_comm(int, int, double *);
+  void unpack_reverse_comm(int, int *, double *);
+  double memory_usage();
+
+  void pair_setup_callback(int, int);
+  void pair_tally_callback(int, int, int, int,
+                           double, double, double,
+                           double, double, double);
+
+ private:
+  bigint did_setup;
+  int nmax,igroup2,groupbit2;
+  double **stress;
+  double *virial;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+*/
Common subdirectories: src/CORESHELL and src_DFT-CES2/CORESHELL
Common subdirectories: src/DEPEND and src_DFT-CES2/DEPEND
Common subdirectories: src/DIPOLE and src_DFT-CES2/DIPOLE
diff -uN src/domain.cpp src_DFT-CES2/domain.cpp
--- src/domain.cpp	2024-04-23 22:12:52.617241387 +0900
+++ src_DFT-CES2/domain.cpp	2025-02-11 06:42:37.279609891 +0900
@@ -40,6 +40,9 @@
 #include "math_const.h"
 #include "memory.h"
 #include "error.h"
+// DFT-CES start
+#include "grid.h"
+// DFT-CES end
 
 using namespace LAMMPS_NS;
 using namespace MathConst;
@@ -101,6 +104,18 @@
   args[1] = (char *) "1.0";
   set_lattice(2,args);
   delete [] args;
+// DFT-CES start
+  char **args2 = new char*[50];
+  grid = NULL;
+  args2[0] = (char *) "3";
+  args2[1] = (char *) "6";
+  for (int i = 2; i < 50; i++)
+	  args2[i] = (char *) "None";
+
+  set_grid(50,args2);
+  delete [] args2;
+
+// DFT-CES end
 
   nregion = maxregion = 0;
   regions = NULL;
@@ -124,6 +139,9 @@
   if (copymode) return;
 
   delete lattice;
+// DFT-CES start
+  delete grid;
+// DFT-CES end
   for (int i = 0; i < nregion; i++) delete regions[i];
   memory->sfree(regions);
 
@@ -1702,6 +1720,19 @@
   lattice = new Lattice(lmp,narg,arg);
 }
 
+// DFT-CES start
+/* ----------------------------------------------------------------------
+   create a grid
+------------------------------------------------------------------------- */
+
+void Domain::set_grid(int narg, char **arg)
+{
+  if (grid) delete grid;
+  grid = new Grid(lmp,narg,arg);
+}
+// DFT-CES end
+
+
 /* ----------------------------------------------------------------------
    create a new region
 ------------------------------------------------------------------------- */
diff -uN src/domain.h src_DFT-CES2/domain.h
--- src/domain.h	2024-04-23 22:12:52.605241283 +0900
+++ src_DFT-CES2/domain.h	2025-02-11 06:42:37.182608955 +0900
@@ -87,6 +87,9 @@
   int deform_groupbit;            // atom group to perform v remap for
 
   class Lattice *lattice;                  // user-defined lattice
+// DFT-CES start
+  class Grid *grid;                        // 3d-grid for DFT-CES simulation
+// DFT-CES end
 
   int nregion;                             // # of defined Regions
   int maxregion;                           // max # list can hold
@@ -126,6 +129,9 @@
   int ownatom(int, double *, imageint *, int);
   
   void set_lattice(int, char **);
+// DFT-CES start
+  void set_grid(int, char **);
+// DFT-CES end
   void add_region(int, char **);
   void delete_region(int, char **);
   int find_region(char *);
diff -uN src/fftset.c src_DFT-CES2/fftset.c
--- src/fftset.c	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fftset.c	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,185 @@
+#include "stdio.h"
+
+#include "math.h"
+#include "mkl.h"
+#include "mkl_dfti.h"
+
+#include "tagmodels.h"
+#include "fftset.h"
+/*
+#ifdef _OPENMP
+#include "omp.h"
+#else
+#define omp_get_thread_num() 0
+#endif
+*/
+int RealScaleImagZero(MKL_Complex8 *arr, int size, float scale)
+{
+	/*
+	int numThreads, threadID;
+
+	#pragma omp parallel private(numThreads) private(threadID)
+	{
+		numThreads = omp_get_num_threads();
+		threadID = omp_get_thread_num();
+
+		for (int i = threadID; i < size; i += numThreads)
+		{
+			arr[i].real *= scale;
+			arr[i].imag = 0.0;
+		}
+	}
+	*/
+	for (int i = 0; i < size; i++) {
+		arr[i].real *= scale;
+		arr[i].imag = 0.0;
+	}
+	
+	return 0;
+}
+
+int ComplexPointwiseMul(MKL_Complex8 *a, MKL_Complex8 *b, int size)
+{
+	/*
+	int numThreads, threadID;
+	MKL_Complex8 c;
+
+	#pragma omp parallel private(numThreads) private(threadID) private(c)
+	{
+		numThreads = omp_get_num_threads();
+		threadID = omp_get_thread_num();
+
+		for (int i = threadID; i < size; i += numThreads)
+		{
+			c.real = a[i].real * b[i].real - a[i].imag * b[i].imag;
+			c.imag = a[i].real * b[i].imag + a[i].imag * b[i].real;
+			b[i].real = c.real;
+			b[i].imag = c.imag;
+		}
+	}
+	*/
+	MKL_Complex8 c;
+	for (int i = 0; i < size; i++) {
+		c.real = a[i].real * b[i].real - a[i].imag * b[i].imag;
+		c.imag = a[i].real * b[i].imag + a[i].imag * b[i].real;
+		b[i].real = c.real;
+		b[i].imag = c.imag;		
+	}
+	
+	
+	return 0;
+}
+
+// gen_kernel
+// input: Any of tag_Models' that can give units and size of gk. info.plrzblty[0] is a good choice. cellParams unit Bohr, pValue unit Ha/eBohr
+// sigma: Gaussian kernel sigma, unit Bohr
+// gk: Normalized Gaussian kernel, cellParams unit Bohr. gk MUST be already allocated with its memory, before this function call!
+int gen_kernel(tag_Models **gk, double sigma)
+{
+	int i, j, k, rm_index;				 //rm_index is row-major order index.
+	double s_sigma = sigma * sigma;		 // Prefix s_ stands for "squared"
+	double r_exp_const = -0.5 / s_sigma; // Real space exponential constant
+	double di, dj, dk, s_di, s_dj, s_dk; //di, dj, dk are displacements in x, y, and z directions.
+	double i_test_integral;
+	double grid_spacing[3], s_grid_spacing[3];
+	double test_integral = 0.0;
+	//double retest_integral = 0.0;
+
+	for (i = 0; i < 3; i++)
+	{
+		grid_spacing[i] = (*gk)->cellParams[i] / (*gk)->pGrid[i];
+		s_grid_spacing[i] = grid_spacing[i] * grid_spacing[i];
+	}
+
+	// Filling a real-space Gaussian distribution in gk.
+	for (i = 0; i < (*gk)->pGrid[0]; i++)
+	{
+		for (j = 0; j < (*gk)->pGrid[1]; j++)
+		{
+			for (k = 0; k < (*gk)->pGrid[2]; k++)
+			{
+				rm_index = k + j * (*gk)->pGrid[2] + i * (*gk)->pGrid[2] * (*gk)->pGrid[1];
+
+				di = i;
+				dj = j;
+				dk = k;
+
+				di -= (double)rint(di / (*gk)->pGrid[0]) * (*gk)->pGrid[0];
+				dj -= (double)rint(dj / (*gk)->pGrid[1]) * (*gk)->pGrid[1];
+				dk -= (double)rint(dk / (*gk)->pGrid[2]) * (*gk)->pGrid[2];
+
+				s_di = di * di;
+				s_dj = dj * dj;
+				s_dk = dk * dk;
+
+				(*gk)->pValue[rm_index] = exp(r_exp_const * (s_grid_spacing[0] * s_di + s_grid_spacing[1] * s_dj + s_grid_spacing[2] * s_dk));
+				test_integral += (*gk)->pValue[rm_index];
+			}
+		}
+	}
+
+	// Re-normalization of 3-D Gaussian
+	i_test_integral = 1.0 / test_integral;
+	for (i = 0; i < (*gk)->pGrid[0] * (*gk)->pGrid[1] * (*gk)->pGrid[2]; i++)
+	{
+		(*gk)->pValue[i] *= i_test_integral;
+		//retest_integral += (*gk)->pValue[i];
+	}
+
+	return 0;
+}
+
+// gaussR2K
+// Forward cuFFT for devcplx_gauss
+int gaussR2K(compute_Models **compute_info)
+{
+	DFTI_DESCRIPTOR_HANDLE plan_gauss = NULL;
+	MKL_LONG status;
+	MKL_LONG dim_sizes[3] = {(*compute_info)->N[0], (*compute_info)->N[1], (*compute_info)->N[2]};
+
+	/* Create a 3D FFT plan. */
+	status = DftiCreateDescriptor(&plan_gauss, DFTI_SINGLE, DFTI_COMPLEX, 3, dim_sizes);
+	status = DftiCommitDescriptor(plan_gauss);
+
+	// Forward FFT
+	status = DftiComputeForward(plan_gauss, (*compute_info)->cplx_gauss);
+
+	// delete FFT plan
+	status = DftiFreeDescriptor(&plan_gauss);
+
+	return 0;
+}
+
+// extfield_kernel
+// Gaussian operation in k-space
+int extfield_kernel(compute_Models **compute_info)
+{
+	DFTI_DESCRIPTOR_HANDLE plan_extfield_kernel = NULL;
+	MKL_LONG status;
+	MKL_LONG dim_sizes[3] = {(*compute_info)->N[0], (*compute_info)->N[1], (*compute_info)->N[2]};
+	
+	int size = (*compute_info)->N[0] * (*compute_info)->N[1] * (*compute_info)->N[2];
+	float norm_const = 1.0 / (float)(size);
+
+	/* Create a 3D FFT plan. */
+	status = DftiCreateDescriptor(&plan_extfield_kernel, DFTI_SINGLE, DFTI_COMPLEX, 3, dim_sizes);
+	status = DftiCommitDescriptor(plan_extfield_kernel);
+
+	// Forward FFT
+	status = DftiComputeForward(plan_extfield_kernel, (*compute_info)->cplx_Ptr);
+
+	// Gaussian operation in k-space
+	ComplexPointwiseMul((*compute_info)->cplx_gauss, (*compute_info)->cplx_Ptr, \
+	(*compute_info)->N[0] * (*compute_info)->N[1] * (*compute_info)->N[2]);
+
+	// Backward FFT
+	status = DftiComputeBackward(plan_extfield_kernel, (*compute_info)->cplx_Ptr);
+
+	// delete FFT plan
+	status = DftiFreeDescriptor(&plan_extfield_kernel);
+
+	// Normalizing FFT arrays
+	RealScaleImagZero((*compute_info)->cplx_Ptr, (*compute_info)->N[0] * (*compute_info)->N[1] * (*compute_info)->N[2], norm_const);
+
+	return 0;
+}
diff -uN src/fftset.h src_DFT-CES2/fftset.h
--- src/fftset.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fftset.h	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,17 @@
+#ifndef _FFTSET_H
+#define _FFTSET_H
+
+#include "mkl_types.h"
+#include "tagmodels.h"
+#include "computemodels.h"
+
+int RealScaleImagZero(MKL_Complex8 *arr, int size, float scale);
+int ComplexPointwiseMul(MKL_Complex8 *a, MKL_Complex8 *b, int size);
+
+int gen_kernel(tag_Models **gk, double sigma);
+
+int gaussR2K(compute_Models **compute_info);
+
+int extfield_kernel(compute_Models **compute_info);
+
+#endif
diff -uN src/fix_ehex.cpp src_DFT-CES2/fix_ehex.cpp
--- src/fix_ehex.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_ehex.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,622 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Peter Wirnsberger (University of Cambridge)
+
+   This source file implements the asymmetric version of the enhanced heat
+   exchange (eHEX/a) algorithm. The paper is available for download on
+   arXiv: http://arxiv.org/pdf/1507.07081.pdf.
+
+   This file is based on fix_heat.cpp written by Paul Crozier (SNL)
+   which implements the heat exchange (HEX) algorithm.
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include "fix_ehex.h"
+#include "atom.h"
+#include "domain.h"
+#include "region.h"
+#include "group.h"
+#include "force.h"
+#include "update.h"
+#include "modify.h"
+#include "input.h"
+#include "variable.h"
+#include "memory.h"
+#include "error.h"
+#include "fix_shake.h"
+#include "neighbor.h"
+#include "comm.h"
+#include "timer.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum{CONSTANT,EQUAL,ATOM};
+
+/* ---------------------------------------------------------------------- */
+
+FixEHEX::FixEHEX(LAMMPS *lmp, int narg, char **arg) : Fix(lmp, narg, arg),
+  idregion(NULL), x(NULL), f(NULL), v(NULL), 
+  mass(NULL), rmass(NULL), type(NULL), scalingmask(NULL)
+{
+  MPI_Comm_rank(world, &me);
+ 
+  // check
+  if (narg < 4) error->all(FLERR,"Illegal fix ehex command: wrong number of parameters ");
+
+  scalar_flag = 1;
+  global_freq = 1;
+  extscalar = 0;
+
+  // apply fix every nevery timesteps
+
+  nevery = force->inumeric(FLERR,arg[3]);
+
+  if (nevery <= 0) error->all(FLERR,"Illegal fix ehex command");
+
+  // heat flux into the reservoir
+
+  heat_input = force->numeric(FLERR,arg[4]);
+
+  // optional args
+
+  iregion = -1;
+  
+  // NOTE: constraints are deactivated by default
+
+  constraints = 0;
+
+  // NOTE: cluster rescaling is deactivated by default
+
+  cluster = 0;
+
+  // NOTE: hex = 1 means that no coordinate correction is applied in which case eHEX reduces to HEX
+ 
+  hex = 0;
+
+  int iarg = 5;
+  while (iarg < narg) {
+
+    if (strcmp(arg[iarg],"region") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ehex command: wrong number of parameters ");
+      iregion = domain->find_region(arg[iarg+1]);
+      if (iregion == -1)
+        error->all(FLERR,"Region ID for fix ehex does not exist");
+      int n = strlen(arg[iarg+1]) + 1;
+      idregion = new char[n];
+      strcpy(idregion,arg[iarg+1]);
+      iarg += 2;
+    } 
+
+    // apply constraints (shake/rattle) at the end of the timestep
+
+    else if (strcmp(arg[iarg], "constrain") == 0) {
+      constraints = 1;
+      iarg += 1;
+    }
+
+    // rescale only if the entire molecule is contained within the region
+
+    else if (strcmp(arg[iarg], "com") == 0) {
+      cluster = 1;
+      iarg += 1;
+    }
+    
+    // don't apply a coordinate correction if this keyword is specified
+
+    else if (strcmp(arg[iarg], "hex") == 0) {
+      hex  = 1;
+      iarg+= 1;
+    }
+    else
+      error->all(FLERR, "Illegal fix ehex keyword ");
+  } 
+
+  // check options
+
+  if (cluster && !constraints) 
+    error->all(FLERR, "You can only use the keyword 'com' together with the keyword 'constrain' ");
+
+  scale = 1.0;
+  scalingmask    = NULL;
+  grow_arrays(atom->nmax);
+  atom->add_callback(0);
+
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+void FixEHEX::grow_arrays(int nmax) {
+  memory->grow(scalingmask, nmax,"ehex:scalingmask");
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+FixEHEX::~FixEHEX()
+{
+  atom->delete_callback(id,0);
+  delete [] idregion;
+  memory->destroy(scalingmask);
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixEHEX::setmask()
+{
+  int mask = 0;
+  mask |= END_OF_STEP;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixEHEX::init()
+{
+  // set index and check validity of region
+
+  if (iregion >= 0) {
+    iregion = domain->find_region(idregion);
+    if (iregion == -1)
+      error->all(FLERR,"Region ID for fix ehex does not exist");
+  }
+
+  // cannot have 0 atoms in group
+
+  if (group->count(igroup) == 0)
+    error->all(FLERR,"Fix ehex group has no atoms");
+
+  fshake = NULL;
+  if (constraints) { 
+
+    // check if constraining algorithm is used (FixRattle inherits from FixShake)
+
+    int cnt_shake = 0;
+    int id_shake;
+    for (int i = 0; i < modify->nfix; i++) { 
+      if (strcmp("rattle", modify->fix[i]->style) == 0 ||
+          strcmp("shake", modify->fix[i]->style) == 0) {
+        cnt_shake++;
+        id_shake = i;
+      }
+    } 
+ 
+    if (cnt_shake > 1)         
+      error->all(FLERR,"Multiple instances of fix shake/rattle detected (not supported yet)");
+    else if (cnt_shake == 1)   {
+     fshake = ((FixShake*) modify->fix[id_shake]);
+    }
+    else if (cnt_shake == 0)                  
+      error->all(FLERR, "Fix ehex was configured with keyword constrain, but shake/rattle was not defined");
+  }
+}
+
+
+
+/* ---------------------------------------------------------------------- */
+
+
+void FixEHEX::end_of_step() {
+  // store local pointers
+
+  x       = atom->x;
+  f       = atom->f;
+  v       = atom->v;
+  mass    = atom->mass;
+  rmass   = atom->rmass;
+  type    = atom->type;
+  nlocal  = atom->nlocal;
+
+  // determine which sites are to be rescaled
+
+  update_scalingmask();
+
+  // rescale velocities 
+
+  rescale();
+
+  // if required use shake/rattle to correct coordinates and velocities
+
+  if (constraints && fshake) 
+    fshake->shake_end_of_step(0);
+}
+
+
+
+/* ----------------------------------------------------------------------
+   Iterate over all atoms, rescale the velocities and apply coordinate 
+   corrections.
+------------------------------------------------------------------------- */
+
+void FixEHEX::rescale() {
+  double Kr, Ke, escale;
+  double vsub[3],vcm[3], sfr[3];
+  double mi;
+  double dt;
+  double F, mr, epsr_ik, sfvr, eta_ik;
+
+  dt = update->dt;
+
+  // calculate centre of mass properties
+   
+  com_properties(vcm, sfr, &sfvr, &Ke, &Kr, &masstotal); 
+
+  // heat flux into the reservoir
+
+  F     = heat_input * force->ftm2v * nevery;
+  
+  // total mass
+
+  mr    = masstotal;
+  
+  // energy scaling factor
+
+  escale = 1. + (F*dt)/Kr;
+
+  // safety check for kinetic energy
+
+  if (escale < 0.0) error->all(FLERR,"Fix ehex kinetic energy went negative");
+
+  scale = sqrt(escale);
+  vsub[0] = (scale-1.0) * vcm[0];
+  vsub[1] = (scale-1.0) * vcm[1];
+  vsub[2] = (scale-1.0) * vcm[2];
+
+  for (int i = 0; i < nlocal; i++){
+
+    if (scalingmask[i]) {
+
+      mi = (rmass) ? rmass[i] :  mass[type[i]];
+
+      for (int k=0; k<3; k++) {
+
+        // apply coordinate correction unless running in hex mode
+
+        if (!hex) {
+
+            // epsr_ik implements Eq. (20) in the paper
+
+            eta_ik    = mi * F/(2.*Kr) * (v[i][k] - vcm[k]);          
+            epsr_ik   = eta_ik / (mi*Kr) * (F/48. + sfvr/6.*force->ftm2v) - F/(12.*Kr) * (f[i][k]/mi - sfr[k]/mr)*force->ftm2v;
+
+            x[i][k]  -= dt*dt*dt * epsr_ik;
+        }
+
+        // rescale the velocity
+
+        v[i][k]   = scale*v[i][k] - vsub[k];
+      }
+    }
+  }
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+double FixEHEX::compute_scalar()
+{
+  return scale;
+}
+
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based arrays
+------------------------------------------------------------------------- */
+
+double FixEHEX::memory_usage()
+{
+  double bytes = 0.0;
+  bytes += atom->nmax * sizeof(double);
+  return bytes;
+}
+
+
+/* ----------------------------------------------------------------------
+   Update the array scalingmask depending on which individual atoms 
+   will be rescaled or not. 
+------------------------------------------------------------------------- */
+
+void FixEHEX::update_scalingmask() {
+  int m;
+  int lid;
+  bool stat;
+  int nsites;
+
+  // prematch region
+
+  Region *region = NULL;
+  if (iregion >= 0) {
+    region = domain->regions[iregion];
+    region->prematch();
+  }
+
+  // only rescale molecules whose center of mass if fully contained in the region
+
+  if (cluster) {
+ 
+    // loop over all clusters
+
+    for (int i=0; i < fshake->nlist; i++) {
+
+      // cluster id 
+
+      m    = fshake->list[i]; 
+
+      // check if the centre of mass of the cluster is inside the region
+      // if region == NULL, just check the group information of all sites
+
+      if      (fshake->shake_flag[m] == 1)      nsites = 3;
+      else if (fshake->shake_flag[m] == 2)      nsites = 2;
+      else if (fshake->shake_flag[m] == 3)      nsites = 3;
+      else if (fshake->shake_flag[m] == 4)      nsites = 4;
+      else                                      nsites = 0;
+
+      if (nsites == 0) {
+        error->all(FLERR,"Internal error: shake_flag[m] has to be between 1 and 4 for m in nlist");  
+      }
+
+      stat = check_cluster(fshake->shake_atom[m], nsites, region);
+
+      for (int l=0; l < nsites; l++)  {
+        lid = atom->map(fshake->shake_atom[m][l]);
+        scalingmask[lid] = stat;
+      }      
+    }
+
+    // check atoms that do not belong to any cluster
+
+    for (int i=0; i<atom->nlocal; i++)  {
+      if (fshake->shake_flag[i] == 0) 
+        scalingmask[i] = rescale_atom(i,region);
+    }
+
+  } 
+
+  // no clusters, just individual sites (e.g. monatomic system or flexible molecules)
+
+  else {
+    for (int i=0; i<atom->nlocal; i++) 
+      scalingmask[i] =  rescale_atom(i,region);
+  }
+
+}
+
+
+/* ----------------------------------------------------------------------
+   Check if the centre of mass of the cluster to be constrained is
+   inside the region.
+------------------------------------------------------------------------- */
+
+bool FixEHEX::check_cluster(tagint *shake_atom, int n, Region * region) {
+
+  // IMPORTANT NOTE: If any site of the cluster belongs to a group
+  //                 which should not be rescaled than all of the sites
+  //                 will be ignored!
+
+  double **x     = atom->x;
+  double * rmass = atom->rmass;
+  double * mass  = atom->mass; 
+  int    * type  = atom->type;
+  int    * mask  = atom->mask;
+  double   xcom[3], xtemp[3];
+  double   mcluster, mi;
+  bool     stat;
+  int      lid[4];
+
+  // accumulate mass and centre of mass position
+
+  stat      = true;
+  xcom[0]   = 0.;
+  xcom[1]   = 0.;
+  xcom[2]   = 0.;
+  mcluster  = 0;
+
+  for (int i = 0; i < n; i++) {
+
+    // get local id
+
+    lid[i] = atom->map(shake_atom[i]);
+    
+    // check if all sites of the cluster belong to the correct group
+
+    stat = stat && (mask[lid[i]] & groupbit);
+
+    if (region && stat)  {
+
+      // check if reduced mass is used
+
+      mi        = (rmass) ? rmass[lid[i]] : mass[type[lid[i]]];
+      mcluster += mi;
+
+      // accumulate centre of mass 
+      // NOTE: you can either use unwrapped coordinates or take site x[lid[0]] as reference,
+      //       i.e. reconstruct the molecule around this site and calculate the com.
+
+      for (int k=0; k<3; k++) 
+        xtemp[k] = x[lid[i]][k] - x[lid[0]][k];
+ 
+      // take into account pbc
+      
+      domain->minimum_image(xtemp);
+
+      for (int k=0; k<3; k++)
+        xcom[k] += mi * (x[lid[0]][k] + xtemp[k]) ;
+    }   
+  } 
+
+  // check if centre of mass is inside the region (if specified)
+
+  if (region && stat) {
+
+    // check mass
+
+    if (mcluster < 1.e-14) {
+      error->all(FLERR, "Fix ehex shake cluster has almost zero mass.");
+    }
+
+    // divide by total mass
+
+    for (int k=0; k<3; k++) 
+      xcom[k] = xcom[k]/mcluster;      
+ 
+    // apply periodic boundary conditions (centre of mass could be outside the box)
+    // and check if molecule is inside the region
+
+    domain->remap(xcom);
+    stat = stat && region->match(xcom[0], xcom[1], xcom[2]);
+  }
+  
+  return stat; 
+}
+
+
+/* ----------------------------------------------------------------------
+   Check if atom i has the correct group and is inside the region.
+------------------------------------------------------------------------- */
+
+bool FixEHEX::rescale_atom(int i, Region*region) {
+  bool stat;
+  double x_r[3];
+
+  // check mask and group
+
+  stat = (atom->mask[i] & groupbit);
+
+  if (region) {
+
+    x_r[0] = atom->x[i][0];
+    x_r[1] = atom->x[i][1];
+    x_r[2] = atom->x[i][2];
+
+    // apply periodic boundary conditions
+
+    domain->remap(x_r);
+
+    // check if the atom is in the group/region
+
+    stat = stat && region->match(x_r[0],x_r[1],x_r[2]);
+  }
+
+  return stat;
+}
+
+/* ----------------------------------------------------------------------
+   Calculate global properties of the atoms inside the reservoir.
+   (e.g. com velocity, kinetic energy, total mass,...)
+------------------------------------------------------------------------- */
+
+void FixEHEX::com_properties(double * vr, double * sfr, double *sfvr, double *K, double *Kr, double *mr) {
+   double ** f  = atom->f;
+   double ** v  = atom->v;
+   int nlocal   = atom->nlocal;
+   double *rmass= atom->rmass;
+   double *mass = atom->mass;
+   int    *type = atom->type;
+   double l_vr[3];
+   double l_mr;
+   double l_sfr[3];
+   double l_sfvr;
+   double l_K;
+   double mi;
+   double l_buf[9];
+   double buf[9];
+ 
+   // calculate partial sums
+
+   l_vr[0]  = l_vr[1]  = l_vr[2] = 0;
+   l_sfr[0] = l_sfr[1] = l_sfr[2] = 0;
+   l_sfvr   = 0;
+   l_mr     = 0;
+   l_K      = 0;
+
+   for (int i = 0; i < nlocal; i++) {
+     if (scalingmask[i]) {        
+       
+        // check if reduced mass is used
+
+        mi    = (rmass) ? rmass[i] : mass[type[i]];
+
+        // accumulate total mass
+
+        l_mr += mi;
+  
+        // accumulate kinetic energy
+
+        l_K  += mi/2. * (v[i][0]*v[i][0] + v[i][1]*v[i][1] + v[i][2]*v[i][2]);
+
+        // sum_j f_j * v_j
+
+        l_sfvr  += f[i][0]*v[i][0] + f[i][1]*v[i][1] + f[i][2]*v[i][2];
+
+        // accumulate com velocity and sum of forces
+
+        for (int k=0; k<3; k++) {
+          l_vr[k] += mi * v[i][k];
+          l_sfr[k]+= f[i][k];
+        }
+     }
+   }
+
+   // reduce sums
+
+   l_buf[0] = l_vr[0];
+   l_buf[1] = l_vr[1];
+   l_buf[2] = l_vr[2];
+   l_buf[3] = l_K;
+   l_buf[4] = l_mr;
+   l_buf[5] = l_sfr[0];
+   l_buf[6] = l_sfr[1];
+   l_buf[7] = l_sfr[2];
+   l_buf[8] = l_sfvr;
+
+   MPI_Allreduce(l_buf, buf, 9, MPI_DOUBLE, MPI_SUM, world);
+
+   // total mass of region
+
+   *mr = buf[4];
+
+   if (*mr < 1.e-14) {
+      error->all(FLERR, "Fix ehex error mass of region is close to zero");
+   }
+
+   // total kinetic energy of region 
+
+   *K  = buf[3];
+
+   // centre of mass velocity of region
+
+   vr[0] = buf[0]/(*mr);
+   vr[1] = buf[1]/(*mr);
+   vr[2] = buf[2]/(*mr);
+
+   // sum of forces
+
+   sfr[0] = buf[5];
+   sfr[1] = buf[6];
+   sfr[2] = buf[7];
+
+   // calculate non-translational kinetic energy
+
+   *Kr = *K - 0.5* (*mr) * (vr[0]*vr[0]+vr[1]*vr[1]+vr[2]*vr[2]);
+
+   // calculate sum_j f_j * (v_j - v_r) = sum_j f_j * v_j  - v_r * sum_j f_j
+ 
+   *sfvr =  buf[8] - (vr[0]*sfr[0] + vr[1]*sfr[1] + vr[2]*sfr[2]);
+}
+
diff -uN src/fix_ehex.h src_DFT-CES2/fix_ehex.h
--- src/fix_ehex.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_ehex.h	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,130 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+
+#ifdef FIX_CLASS
+
+FixStyle(ehex,FixEHEX)
+
+#else
+
+#ifndef LMP_FIX_EHEX_H
+#define LMP_FIX_EHEX_H
+
+#include "fix.h"
+#include "fix_shake.h"
+#include "region.h"
+#define EHEX_DEBUG 0
+
+namespace LAMMPS_NS {
+
+class FixEHEX : public Fix {
+
+ public:
+  FixEHEX(class LAMMPS *, int, char **);
+  ~FixEHEX();
+  int  setmask();
+  void init();
+  void end_of_step();
+  void   rescale();
+  double compute_scalar();
+  double memory_usage();
+  void update_scalingmask();
+  void com_properties(double *, double *, double *, double*, double *, double*);
+  bool rescale_atom(int i, Region*region);
+  virtual void grow_arrays(int nmax);
+  bool check_cluster(tagint *shake_atom, int n, Region * region);
+
+ private:
+  int iregion;
+  double heat_input;
+  double masstotal;
+  double scale;
+  char *idregion;
+  int me;
+ 
+  double **x;              // coordinates
+  double **f;              // forces
+  double **v;              // velocities
+  double *mass;           // masses
+  double *rmass;          // reduced masses
+  int    *type;           // atom types
+  int   nlocal;             // number of local atoms
+  FixShake * fshake;        // pointer to fix_shake/fix_rattle
+  int constraints;          // constraints (0/1)
+  int cluster;              // rescaling entire clusters (0/1)
+  int hex;                  // HEX mode (0/1)
+  bool *scalingmask;       // scalingmask[i] determines whether 
+                            // the velocity of atom i is to be rescaled
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal fix ehex command: wrong number of parameters 
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Illegal fix ehex command: integer value expected
+
+Self-explanatory. Check the value for nevery.
+
+E: Region ID for fix ehex does not exist
+
+Self-explanatory.
+
+E: You can only use the keyword 'com' together with the keyword 'constrain' .
+
+Self-explanatory.
+
+E: Illegal fix ehex keyword
+
+Self-explanatory.
+
+E: Fix ehex group has no atoms
+
+Self-explanatory.
+
+E: Multiple instances of fix shake/rattle detected (not supported yet)
+
+You can only have one instance of fix rattle/shake at the moment.
+
+E: Fix ehex was configured with keyword constrain, but shake/rattle was not defined
+
+The option constrain requires either fix shake or fix rattle which is missing in the input script.
+
+E: Fix heat kinetic energy went negative
+
+This will cause the velocity rescaling about to be performed by fix
+heat to be invalid.
+
+E: Fix heat kinetic energy of an atom went negative
+
+This will cause the velocity rescaling about to be performed by fix
+heat to be invalid.
+
+E: Internal error: shake_flag[m] has to be between 1 and 4 for m in nlist
+
+Contact developers.
+
+E: Fix ehex error mass of region is close to zero
+
+Check your configuration.
+
+*/
diff -uN src/fix_gridforce.cpp src_DFT-CES2/fix_gridforce.cpp
--- src/fix_gridforce.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_gridforce.cpp	2025-02-11 06:42:37.281609910 +0900
@@ -0,0 +1,714 @@
+#/* ----------------------------------------------------------------------
+   DFT-CES core subroutines. Written by H.-K. Lim
+	 Modified by T. Jang
+   Copyright (C) 2024 M-design group @ KAIST
+------------------------------------------------------------------------- */
+
+#include "fix_gridforce.h"
+#include "angle.h"
+#include "atom.h"
+#include "atom_masks.h"
+#include "bond.h"
+#include "domain.h"
+#include "error.h"
+#include "force.h"
+#include "grid.h"
+#include "input.h"
+#include "memory.h"
+#include "modify.h"
+#include "region.h"
+#include "update.h"
+#include "variable.h"
+#include <iostream>
+#include <stdlib.h>
+#include <string.h>
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace std;
+
+/* ---------------------------------------------------------------------- */
+
+FixGridForce::FixGridForce(LAMMPS *lmp, int narg, char **arg) : Fix(lmp, narg, arg) {
+  if (narg != 14 && narg != 7)
+    error->all(FLERR, "Illegal fix gridforce command: weight supercellfactor cube-ID element keywords");
+  else if (narg == 14 &&  (strcmp(arg[7], "tip4p") != 0) && (strcmp(arg[7], "TIP4P") != 0) )
+    error->all(FLERR, "Illegal fix gridforce command: TIP4P arguments - otype htype bdistance angle qdist indicator");
+  scalar_flag = 1;
+  vector_flag = 1;  
+  extvector = 1;    
+  size_vector = 3; 
+  extscalar = 1;
+
+  weight = atof(arg[3]);
+  sfactor = atoi(arg[4]);
+  cubeID = atoi(arg[5]);
+  RepXmeta = arg[6];
+
+  if (comm->me == 0)
+    printf("DFT-CES: weight factor    = %f\n", weight);
+  if (comm->me == 0)
+    printf("DFT-CES: supercell factor = %d\n", sfactor);
+  if (comm->me == 0)
+    printf("DFT-CES: cubefile ID      = %d\n", cubeID);
+
+  force_flag = 0;
+  Egrid[0] = Egrid[1] = Egrid[2] = 0.0;
+  tmp5[0] = tmp5[1] = tmp5[2] = tmp5[3] = 0;
+  tmp6[0] = tmp6[1] = tmp6[2] = tmp6[3] = tmp6[4] = tmp6[5] = tmp6[6] = tmp6[7] = 0;
+  tip4p_CES = 0;
+
+	if ( narg > 7){
+		if ( (strcmp(arg[7], "tip4p") == 0) || (strcmp(arg[7], "TIP4P") == 0) ) {
+    tip4p_CES = 1; // DFT-CES with tip4p turn on
+    typeO = atoi(arg[8]);
+    typeH = atoi(arg[9]);
+    blen = atof(arg[10]);
+    theta = atof(arg[11]);
+    qdist = atof(arg[12]);
+
+    // set alpha parameter
+    alpha = qdist / (cos(0.5 * theta * M_PI / 180) * blen);
+    cubeID_tip4p_O = atoi(arg[13]);
+  } 
+  }
+
+	find(RepXmeta);
+	
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixGridForce::~FixGridForce() {
+  return;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixGridForce::setmask() {
+  datamask_read = datamask_modify = 0;
+
+  int mask = 0;
+  mask |= POST_FORCE;
+  mask |= THERMO_ENERGY;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixGridForce::init() {
+  // check variables
+  if (domain->grid->natoms == 0)
+    error->all(FLERR, "Grid data is unavilable");
+	if (domain->grid->savetag == 1 && tip4p_CES == 1){
+		if (domain->grid->ncubes <= (domain->grid->nrhocubes -1 +3 +1 )) // exclude potentialcube, type of atoms (nrhocubes), dipx-, y-, z- cubes, and tip4p O) 
+    	error->all(FLERR, "Grid data is unavilable, allocate more memory to Grid for oxgyen in TIP4P.");
+	}
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixGridForce::setup(int vflag) {
+  post_force(vflag);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixGridForce::post_force(int vflag) {
+  int iH1, iH2;
+  double **x = atom->x;
+  double **f = atom->f;
+  tagint *tag = atom->tag; 
+  double *q = atom->q;
+  int *type = atom->type; // TIP4P
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+  double fx, fy, fz;
+  double repfx, repfy, repfz;
+
+  newsite[0] = newsite[1] = newsite[2] = 0;
+  Egrid[0] = Egrid[1] = Egrid[2] = 0.0;
+  force_flag = 0;
+  tmp5[0] = tmp5[1] = tmp5[2] = tmp5[3] = 0;
+  tmp6[0] = tmp6[1] = tmp6[2] = tmp6[3] = tmp6[4] = tmp6[5] = tmp6[6] = tmp6[7] = 0;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      if (tip4p_CES == 1) {
+        if (type[i] == typeO) {
+          iH1 = atom->map(tag[i] + 1);
+          iH2 = atom->map(tag[i] + 2);
+          iH1 = domain->closest_image(i, iH1);
+          iH2 = domain->closest_image(i, iH2);
+          compute_newsite(x[i], x[iH1], x[iH2], newsite);
+          triInterRep(RepX, x[i][0], x[i][1], x[i][2], tmp5, cubeID); // newsite is valid only for the electrostatic force, not Pauli rep and disp
+          triInterInduce(q[i], Polar, newsite[0], newsite[1], newsite[2], tmp6, cubeID);
+          // save at updated position and force calculate
+          Egrid[0] += weight * 23.06092 * q[i] * tmp6[0]; // weight = -1, 1 eV = 23.06092 kcal/mol
+          fx = weight * 23.06092 * q[i] * tmp6[1];
+          fy = weight * 23.06092 * q[i] * tmp6[2];
+          fz = weight * 23.06092 * q[i] * tmp6[3];
+          Egrid[1] += 0.237154 * tmp6[4]; // , (0.52917721/13.60569/2)^2 *627.509 = 0.237154
+          fx += weight * 0.237154 * tmp6[5];
+          fy += weight * 0.237154 * tmp6[6];
+          fz += weight * 0.237154 * tmp6[7];
+          Egrid[2] += RepX * tmp5[0]; 
+          repfx = RepX * tmp5[1];
+          repfy = RepX * tmp5[2];
+          repfz = RepX * tmp5[3];
+          f[i][0] += (repfx + fx) * (1.0 - alpha);
+          f[i][1] += (repfy + fy) * (1.0 - alpha);
+          f[i][2] += (repfz + fz) * (1.0 - alpha);
+          f[iH1][0] += 0.5 * alpha * (fx + repfx);
+          f[iH1][1] += 0.5 * alpha * (fy + repfy);
+          f[iH1][2] += 0.5 * alpha * (fz + repfz);
+          f[iH2][0] += 0.5 * alpha * (fx + repfx);
+          f[iH2][1] += 0.5 * alpha * (fy + repfy);
+          f[iH2][2] += 0.5 * alpha * (fz + repfz);
+          // distribute force at massless point at O,H1,H2
+        } else { // type[i]==typeH
+          triInterRep(RepX, x[i][0], x[i][1], x[i][2], tmp5, cubeID);
+          triInterInduce(q[i], Polar, x[i][0], x[i][1], x[i][2], tmp6, cubeID);
+          Egrid[0] += weight * 23.06092 * q[i] * tmp6[0];
+          fx = weight * 23.06092 * q[i] * tmp6[1];
+          fy = weight * 23.06092 * q[i] * tmp6[2];
+          fz = weight * 23.06092 * q[i] * tmp6[3];
+          Egrid[1] += 0.237154 * tmp6[4]; 
+          fx += weight * 0.237154 * tmp6[5];
+          fy += weight * 0.237154 * tmp6[6];
+          fz += weight * 0.237154 * tmp6[7];
+          Egrid[2] += RepX * tmp5[0];
+          repfx = RepX * tmp5[1];
+          repfy = RepX * tmp5[2];
+          repfz = RepX * tmp5[3];
+          f[i][0] += fx + repfx;
+          f[i][1] += fy + repfy;
+          f[i][2] += fz + repfz;
+        }
+      } else {
+        triInterRep(RepX, x[i][0], x[i][1], x[i][2], tmp5, cubeID);
+        triInterInduce(q[i], Polar, x[i][0], x[i][1], x[i][2], tmp6, cubeID);
+        Egrid[0] += weight * 23.06092 * q[i] * tmp6[0];
+        fx = weight * 23.06092 * q[i] * tmp6[1];
+        fy = weight * 23.06092 * q[i] * tmp6[2];
+        fz = weight * 23.06092 * q[i] * tmp6[3];
+        Egrid[1] += 0.237154 * tmp6[4]; 
+        fx += weight * 0.237154 * tmp6[5];
+        fy += weight * 0.237154 * tmp6[6];
+        fz += weight * 0.237154 * tmp6[7];
+        Egrid[2] += RepX * tmp5[0];
+        repfx = RepX * tmp5[1];
+        repfy = RepX * tmp5[2];
+        repfz = RepX * tmp5[3];
+        f[i][0] += fx + repfx;
+        f[i][1] += fy + repfy;
+        f[i][2] += fz + repfz;
+      }
+    }
+  }
+}
+
+double FixGridForce::compute_scalar() {
+  // only sum across procs one time
+  if (force_flag == 0) {
+    MPI_Allreduce(&Egrid[0], &Egrid_all[0], 1, MPI_DOUBLE, MPI_SUM, world);
+    MPI_Allreduce(&Egrid[1], &Egrid_all[1], 1, MPI_DOUBLE, MPI_SUM, world);
+    MPI_Allreduce(&Egrid[2], &Egrid_all[2], 1, MPI_DOUBLE, MPI_SUM, world);
+    force_flag = 1;
+  }
+  return Egrid_all[0] + Egrid_all[1] + Egrid_all[2];
+}
+
+double FixGridForce::compute_vector(int n) {
+  // only sum across procs one time
+
+  if (force_flag == 0) {
+    MPI_Allreduce(&Egrid[0], &Egrid_all[0], 3, MPI_DOUBLE, MPI_SUM, world);
+    force_flag = 1;
+  }
+  return Egrid_all[n]; // an element
+}
+
+void FixGridForce::triInterRep(double RepX, double x, double y, double z, double *tmp5, int CUBEID) {
+  int i;
+  double check;
+  double *gvin = domain->grid->gvin;
+  double *cvin = NULL;
+  int gnx = domain->grid->gnx;
+  int gny = domain->grid->gny;
+  int gnz = domain->grid->gnz;
+  int cube = domain->grid->nrhocubes;
+	int savetag = domain->grid->savetag;
+  cvin = &(domain->grid->cvin[gnx * gny * gnz * CUBEID]);
+  double px, py, pz, xd, yd, zd;
+  double pPR000, pPR100, pPR010, pPR001, pPR110, pPR101, pPR011, pPR111;
+  double gG[3];
+  double ePR000[3], ePR100[3], ePR010[3], ePR001[3], ePR110[3], ePR101[3], ePR011[3], ePR111[3];
+  double gsx = domain->grid->gx[0]; // unit in Angstrom;
+  double gsy = domain->grid->gy[1];
+  double gsz = domain->grid->gz[2];
+  double gvol;
+  if (x < 0) {
+    px = (fmod(x, gnx * gsx) + gnx * gsx) / gsx;
+  } else {
+    px = fmod(x, gnx * gsx) / gsx;
+  }
+  if (y < 0) {
+    py = (fmod(y, gny * gsy) + gny * gsy) / gsy;
+  } else {
+    py = fmod(y, gny * gsy) / gsy;
+  }
+  if (z < 0) {
+    pz = (fmod(z, gnz * gsz) + gnz * gsz) / gsz;
+  } else {
+    pz = fmod(z, gnz * gsz) / gsz;
+  }
+  xd = (double)(px - (int)px);
+  yd = (double)(py - (int)py);
+  zd = (double)(pz - (int)pz);
+
+  tmp5[0] = tmp5[1] = tmp5[2] = tmp5[3] = 0;
+  pPR000 = gridValue(cvin, (int)px, (int)py, (int)pz); 
+  pPR100 = gridValue(cvin, 1 + (int)px, (int)py, (int)pz);
+  pPR010 = gridValue(cvin, (int)px, 1 + (int)py, (int)pz);
+  pPR001 = gridValue(cvin, (int)px, (int)py, 1 + (int)pz);
+  pPR110 = gridValue(cvin, 1 + (int)px, 1 + (int)py, (int)pz);
+  pPR101 = gridValue(cvin, 1 + (int)px, (int)py, 1 + (int)pz);
+  pPR011 = gridValue(cvin, (int)px, 1 + (int)py, 1 + (int)pz);
+  pPR111 = gridValue(cvin, 1 + (int)px, 1 + (int)py, 1 + (int)pz);
+  tmp5[0] = triInterValue(pPR000, pPR100, pPR010, pPR001, pPR110, pPR101, pPR011, pPR111, xd, yd, zd);
+  check = sqrt(tmp5[0] * tmp5[0]);
+  if (check > tmp5[0] || tmp5[0] < 0.000000001) {
+    tmp5[0] = 0.0;
+  }
+
+  gridGrad(cvin, ((int)px) % gnx, ((int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR000[i] = gG[i];
+  gridGrad(cvin, (1 + (int)px) % gnx, ((int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR100[i] = gG[i];
+  gridGrad(cvin, ((int)px) % gnx, (1 + (int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR010[i] = gG[i];
+  gridGrad(cvin, ((int)px) % gnx, ((int)py) % gny, (1 + (int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR001[i] = gG[i];
+  gridGrad(cvin, (1 + (int)px) % gnx, (1 + (int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR110[i] = gG[i];
+  gridGrad(cvin, (1 + (int)px) % gnx, ((int)py) % gny, (1 + (int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR101[i] = gG[i];
+  gridGrad(cvin, ((int)px) % gnx, (1 + (int)py) % gny, (1 + (int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR011[i] = gG[i];
+  gridGrad(cvin, (1 + (int)px) % gnx, (1 + (int)py) % gny, (1 + (int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    ePR111[i] = gG[i];
+  tmp5[1] = triInterValue(ePR000[0], ePR100[0], ePR010[0], ePR001[0], ePR110[0], ePR101[0], ePR011[0], ePR111[0], xd, yd, zd);
+  tmp5[2] = triInterValue(ePR000[1], ePR100[1], ePR010[1], ePR001[1], ePR110[1], ePR101[1], ePR011[1], ePR111[1], xd, yd, zd);
+  tmp5[3] = triInterValue(ePR000[2], ePR100[2], ePR010[2], ePR001[2], ePR110[2], ePR101[2], ePR011[2], ePR111[2], xd, yd, zd);
+
+    if (tip4p_CES == 1 && savetag ==1) {
+    if (cubeID == cubeID_tip4p_O){
+			int cuber = domain->grid->nrhocubes;
+			double *gvout = NULL;
+			gvout = &(domain->grid->gvout[gnz * gny * gnx * (cuber + 3)]);
+			RepX *= 0.00318720528; // [=] kcal mol-1*e-1*bohr3 to Ry*e-1*bohr3
+			pPR000 = (1 - xd) * (1 - yd) * (1 - zd) * abs(weight) * RepX;
+			pPR100 = xd * (1 - yd) * (1 - zd) * abs(weight) * RepX;
+			pPR010 = (1 - xd) * yd * (1 - zd) * abs(weight) * RepX;
+			pPR110 = xd * yd * (1 - zd) * abs(weight) * RepX;
+			pPR001 = (1 - xd) * (1 - yd) * zd * abs(weight) * RepX;
+			pPR101 = xd * (1 - yd) * zd * abs(weight) * RepX;
+			pPR011 = (1 - xd) * yd * zd * abs(weight) * RepX;
+		  pPR111 = xd * yd * zd * abs(weight) * RepX;
+  		gvol = gsx * gsy * gsz; // Ang3
+
+    	gvout[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pPR000 / gvol / sfactor;
+    	gvout[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pPR100 / gvol / sfactor;
+    	gvout[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pPR010 / gvol / sfactor;
+    	gvout[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pPR001 / gvol / sfactor;
+    	gvout[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pPR110 / gvol / sfactor;
+    	gvout[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pPR101 / gvol / sfactor;
+    	gvout[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pPR011 / gvol / sfactor;
+    	gvout[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pPR111 / gvol / sfactor;
+		}
+  }
+  return;
+}
+
+void FixGridForce::triInterInduce(double q, double Polar, double x, double y, double z, double *tmp6, int CUBEID) {
+  int i;
+  double check;
+  double dipole[3];
+  double *gvin = domain->grid->gvin;
+  double px, py, pz, xd, yd, zd;
+  double p000, p100, p010, p001, p110, p101, p011, p111;
+  double pi000[3], pi100[3], pi010[3], pi001[3], pi110[3], pi101[3], pi011[3], pi111[3]; // induced dipole derivatives of squared field in grid points
+  double gG[3];
+  double e000[3], e100[3], e010[3], e001[3], e110[3], e101[3], e011[3], e111[3];
+  int gnx = domain->grid->gnx;
+  int gny = domain->grid->gny;
+  int gnz = domain->grid->gnz;
+	int savetag = domain->grid->savetag;
+  double gsx = domain->grid->gx[0]; // unit in Angstrom
+  double gsy = domain->grid->gy[1];
+  double gsz = domain->grid->gz[2];
+  double gvol;
+  if (x < 0) {
+    px = (fmod(x, gnx * gsx) + gnx * gsx) / gsx;
+  } else {
+    px = fmod(x, gnx * gsx) / gsx;
+  }
+  if (y < 0) {
+    py = (fmod(y, gny * gsy) + gny * gsy) / gsy;
+  } else {
+    py = fmod(y, gny * gsy) / gsy;
+  }
+  if (z < 0) {
+    pz = (fmod(z, gnz * gsz) + gnz * gsz) / gsz;
+  } else {
+    pz = fmod(z, gnz * gsz) / gsz;
+  }
+  xd = (double)(px - (int)px);
+  yd = (double)(py - (int)py);
+  zd = (double)(pz - (int)pz);
+  double Polar2 = Polar / 2; // scaling of alpha to include self-polarization energy
+
+  tmp6[0] = tmp6[1] = tmp6[2] = tmp6[3] = tmp6[4] = tmp6[5] = tmp6[6] = tmp6[7] = 0;
+
+  p000 = gridValue(gvin, (int)px, (int)py, (int)pz);
+  p100 = gridValue(gvin, 1 + (int)px, (int)py, (int)pz);
+  p010 = gridValue(gvin, (int)px, 1 + (int)py, (int)pz);
+  p001 = gridValue(gvin, (int)px, (int)py, 1 + (int)pz);
+  p110 = gridValue(gvin, 1 + (int)px, 1 + (int)py, (int)pz);
+  p101 = gridValue(gvin, 1 + (int)px, (int)py, 1 + (int)pz);
+  p011 = gridValue(gvin, (int)px, 1 + (int)py, 1 + (int)pz);
+  p111 = gridValue(gvin, 1 + (int)px, 1 + (int)py, 1 + (int)pz);
+  tmp6[0] = triInterValue(p000, p100, p010, p001, p110, p101, p011, p111, xd, yd, zd);
+  gridGrad(gvin, ((int)px) % gnx, ((int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e000[i] = gG[i];
+  gridGrad(gvin, (int(1 + px)) % gnx, ((int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e100[i] = gG[i];
+  gridGrad(gvin, ((int)px) % gnx, (int(1 + py)) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e010[i] = gG[i];
+  gridGrad(gvin, ((int)px) % gnx, ((int)py) % gny, (int(1 + pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e001[i] = gG[i];
+  gridGrad(gvin, (int(1 + px)) % gnx, (int(1 + py)) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e110[i] = gG[i];
+  gridGrad(gvin, (int(1 + px)) % gnx, ((int)py) % gny, (int(1 + pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e101[i] = gG[i];
+  gridGrad(gvin, ((int)px) % gnx, (int(1 + py)) % gny, (int(1 + pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e011[i] = gG[i];
+  gridGrad(gvin, (int(1 + px)) % gnx, (int(1 + py)) % gny, (int(1 + pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    e111[i] = gG[i];
+  tmp6[1] = triInterValue(e000[0], e100[0], e010[0], e001[0], e110[0], e101[0], e011[0], e111[0], xd, yd, zd);
+  tmp6[2] = triInterValue(e000[1], e100[1], e010[1], e001[1], e110[1], e101[1], e011[1], e111[1], xd, yd, zd);
+  tmp6[3] = triInterValue(e000[2], e100[2], e010[2], e001[2], e110[2], e101[2], e011[2], e111[2], xd, yd, zd);
+  tmp6[4] = -1 * (tmp6[1] * tmp6[1] + tmp6[2] * tmp6[2] + tmp6[3] * tmp6[3]) * Polar2;
+
+  sc_gridGrad(gvin, ((int)px) % gnx, ((int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi000[i] = gG[i];
+  sc_gridGrad(gvin, (int(1 + px)) % gnx, ((int)py) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi100[i] = gG[i];
+  sc_gridGrad(gvin, ((int)px) % gnx, (int(1+py)) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi010[i] = gG[i];
+  sc_gridGrad(gvin, ((int)px) % gnx, ((int)py) % gny, (int(1+pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi001[i] = gG[i];
+  sc_gridGrad(gvin, (int(1+px)) % gnx, (int(1+py)) % gny, ((int)pz) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi110[i] = gG[i];
+  sc_gridGrad(gvin, (int(1+px)) % gnx, ((int)py) % gny, (int(1+pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi101[i] = gG[i];
+  sc_gridGrad(gvin, ((int)px) % gnx, (int(1+py)) % gny, (int(1+pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi011[i] = gG[i];
+  sc_gridGrad(gvin, (int(1+px)) % gnx, (int(1+py)) % gny, (int(1+pz)) % gnz, gG);
+  for (i = 0; i < 3; i++)
+    pi111[i] = gG[i];
+
+	tmp6[5] = Polar2 * (-1) * tmp6[1] * triInterValue(pi000[0], pi100[0], pi010[0], pi001[0], pi110[0], pi101[0], pi011[0], pi111[0], xd, yd, zd); 
+  tmp6[6] = Polar2 * (-1) * tmp6[2] * triInterValue(pi000[1], pi100[1], pi010[1], pi001[1], pi110[1], pi101[1], pi011[1], pi111[1], xd, yd, zd);
+  tmp6[7] = Polar2 * (-1) * tmp6[3] * triInterValue(pi000[2], pi100[2], pi010[2], pi001[2], pi110[2], pi101[2], pi011[2], pi111[2], xd, yd, zd);
+
+	if (savetag==1){
+  // inverse trilinear interpolation for saving MD rho
+  p000 = (1 - xd) * (1 - yd) * (1 - zd) * abs(weight) * q;
+  p100 = xd * (1 - yd) * (1 - zd) * abs(weight) * q;
+  p010 = (1 - xd) * yd * (1 - zd) * abs(weight) * q;
+  p110 = xd * yd * (1 - zd) * abs(weight) * q;
+  p001 = (1 - xd) * (1 - yd) * zd * abs(weight) * q;
+  p101 = xd * (1 - yd) * zd * abs(weight) * q;
+  p011 = (1 - xd) * yd * zd * abs(weight) * q;
+  p111 = xd * yd * zd * abs(weight) * q;
+
+  dipole[0] = tmp6[1] * Polar2 * abs(weight) * 0.0194469; // 0.52917721/2/13.60569253 = 0.01944690 ebohr
+  pi000[0] = (1 - xd) * (1 - yd) * (1 - zd) * dipole[0];
+  pi100[0] = xd * (1 - yd) * (1 - zd) * dipole[0];
+  pi010[0] = (1 - xd) * yd * (1 - zd) * dipole[0];
+  pi110[0] = xd * yd * (1 - zd) * dipole[0];
+  pi001[0] = (1 - xd) * (1 - yd) * dipole[0];
+  pi101[0] = xd * (1 - yd) * zd * dipole[0];
+  pi011[0] = (1 - xd) * yd * zd * dipole[0];
+  pi111[0] = xd * yd * zd * dipole[0];
+
+  dipole[1] = tmp6[2] * Polar2 * abs(weight) * 0.01944690;
+  pi000[1] = (1 - xd) * (1 - yd) * (1 - zd) * dipole[1];
+  pi100[1] = xd * (1 - yd) * (1 - zd) * dipole[1];
+  pi010[1] = (1 - xd) * yd * (1 - zd) * dipole[1];
+  pi110[1] = xd * yd * (1 - zd) * dipole[1];
+  pi001[1] = (1 - xd) * (1 - yd) * dipole[1];
+  pi101[1] = xd * (1 - yd) * zd * dipole[1];
+  pi011[1] = (1 - xd) * yd * zd * dipole[1];
+  pi111[1] = xd * yd * zd * dipole[1];
+
+  dipole[2] = tmp6[3] * Polar2 * abs(weight) * 0.01944690;
+  pi000[2] = (1 - xd) * (1 - yd) * (1 - zd) * dipole[2];
+  pi100[2] = xd * (1 - yd) * (1 - zd) * dipole[2];
+  pi010[2] = (1 - xd) * yd * (1 - zd) * dipole[2];
+  pi110[2] = xd * yd * (1 - zd) * dipole[2];
+  pi001[2] = (1 - xd) * (1 - yd) * dipole[2];
+  pi101[2] = xd * (1 - yd) * zd * dipole[2];
+  pi011[2] = (1 - xd) * yd * zd * dipole[2];
+  pi111[2] = xd * yd * zd * dipole[2];
+
+  gvol = gsx * gsy * gsz; // Ang3
+
+  double *gvout = NULL;
+  gvout = &(domain->grid->gvout[gnz * gny * gnx * CUBEID]);
+  gvout[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += p000 / gvol / sfactor;
+  gvout[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += p100 / gvol / sfactor;
+  gvout[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += p010 / gvol / sfactor;
+  gvout[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += p001 / gvol / sfactor;
+  gvout[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += p110 / gvol / sfactor;
+  gvout[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += p101 / gvol / sfactor;
+  gvout[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += p011 / gvol / sfactor;
+  gvout[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += p111 / gvol / sfactor;
+
+  int cube = domain->grid->nrhocubes;
+  double *gvoutx = NULL;
+  double *gvouty = NULL;
+  double *gvoutz = NULL;
+  gvoutx = &(domain->grid->gvout[gnz * gny * gnx * cube]);
+  gvouty = &(domain->grid->gvout[gnz * gny * gnx * (cube + 1)]);
+  gvoutz = &(domain->grid->gvout[gnz * gny * gnx * (cube + 2)]);
+  gvoutx[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi000[0] / gvol / sfactor;
+  gvoutx[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi100[0] / gvol / sfactor;
+  gvoutx[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi010[0] / gvol / sfactor;
+  gvoutx[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi001[0] / gvol / sfactor;
+  gvoutx[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi110[0] / gvol / sfactor;
+  gvoutx[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi101[0] / gvol / sfactor;
+  gvoutx[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi011[0] / gvol / sfactor;
+  gvoutx[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi111[0] / gvol / sfactor;
+
+  gvouty[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi000[1] / gvol / sfactor;
+  gvouty[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi100[1] / gvol / sfactor;
+  gvouty[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi010[1] / gvol / sfactor;
+  gvouty[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi001[1] / gvol / sfactor;
+  gvouty[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi110[1] / gvol / sfactor;
+  gvouty[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi101[1] / gvol / sfactor;
+  gvouty[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi011[1] / gvol / sfactor;
+  gvouty[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi111[1] / gvol / sfactor;
+
+  gvoutz[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi000[2] / gvol / sfactor;
+  gvoutz[((int)pz) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi100[2] / gvol / sfactor;
+  gvoutz[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi010[2] / gvol / sfactor;
+  gvoutz[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi001[2] / gvol / sfactor;
+  gvoutz[((int)pz) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi110[2] / gvol / sfactor;
+  gvoutz[((int)pz + 1) % gnz + (((int)py) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi101[2] / gvol / sfactor;
+  gvoutz[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px) % gnx) * gnz * gny] += pi011[2] / gvol / sfactor;
+  gvoutz[((int)pz + 1) % gnz + (((int)py + 1) % gny) * gnz + (((int)px + 1) % gnx) * gnz * gny] += pi111[2] / gvol / sfactor;
+
+	}
+  return;
+}
+
+double FixGridForce::triInterValue(double c000, double c100, double c010, double c001, double c110, double c101, double c011, double c111, double xd, double yd, double zd) {
+  double c00, c10, c01, c11, c0, c1, c;
+  c00 = c000 * (1 - xd) + c100 * xd;
+  c01 = c001 * (1 - xd) + c101 * xd;
+  c10 = c010 * (1 - xd) + c110 * xd;
+  c11 = c011 * (1 - xd) + c111 * xd;
+  c0 = c00 * (1 - yd) + c10 * yd;
+  c1 = c01 * (1 - yd) + c11 * yd;
+  c = c0 * (1 - zd) + c1 * zd;
+  return c;
+}
+
+double FixGridForce::gridValue(double *gvin, int x, int y, int z) {
+  int gnx = domain->grid->gnx;
+  int gny = domain->grid->gny;
+  int gnz = domain->grid->gnz;
+  double gValue = 0;
+
+  gValue = gvin[(z % gnz) + (y % gny) * gnz + (x % gnx) * gnz * gny];
+
+  return gValue;
+}
+
+void FixGridForce::sc_gridGrad(double *gvin, int x, int y, int z, double *gG) { // gradient of squared field output
+  int gnx = domain->grid->gnx;
+  int gny = domain->grid->gny;
+  int gnz = domain->grid->gnz;
+  double gsx = domain->grid->gx[0];
+  double gsy = domain->grid->gy[1];
+  double gsz = domain->grid->gz[2];
+  double xbef, xaft, ybef, yaft, zbef, zaft;
+  int xplus, xminus, yplus, yminus, zplus, zminus;
+  double nzz[3], pzz[3], znz[3], zpz[3], zzn[3], zzp[3];
+  double ingG[3];
+  ingG[0] = ingG[1] = ingG[2] = 0;
+  gG[0] = gG[1] = gG[2] = 0;
+	xplus = (x+1)%gnx;
+	xminus = (gnx + x -1)%gnx;
+	yplus = (y+1)%gny;
+	yminus = (gny + y -1)%gny;
+	zplus = (z+1)%gnz;
+	zminus = (gnz + z -1)%gnz;
+  // c-100=nzz
+  xbef = gvin[z + y * gnz + ((gnx + x - 2) % gnx) * gnz * gny];
+  xaft = gvin[z + y * gnz + x * gnz * gny];
+  ybef = gvin[z + ((gny + y - 1) % gny) * gnz + xminus * gnz * gny];
+  yaft = gvin[z + ((y + 1) % gny) * gnz + xminus * gnz * gny];
+  zbef = gvin[((gnz + z - 1) % gnz) + y * gnz + xminus * gnz * gny];
+  zaft = gvin[(z + 1) % gnz + y * gnz + xminus * gnz * gny];
+  nzz[0] = (xaft - xbef) / (2 * gsx);
+  nzz[1] = (yaft - ybef) / (2 * gsy);
+  nzz[2] = (zaft - zbef) / (2 * gsz);
+  // c100=pzz
+  xbef = gvin[z + y * gnz + x * gnz * gny];
+  xaft = gvin[z + y * gnz + ((x + 2) % gnx) * gnz * gny];
+  ybef = gvin[z + ((gny + y - 1) % gny) * gnz + xplus * gnz * gny];
+  yaft = gvin[z + ((y + 1) % gny) * gnz + xplus * gnz * gny];
+  zbef = gvin[((gnz + z - 1) % gnz) + y * gnz + xplus * gnz * gny];
+  zaft = gvin[(z + 1) % gnz + y * gnz + xplus * gnz * gny];
+  pzz[0] = (xaft - xbef) / (2 * gsx);
+  pzz[1] = (yaft - ybef) / (2 * gsy);
+  pzz[2] = (zaft - zbef) / (2 * gsz);
+  // c0-10=znz
+  xbef = gvin[z + yminus * gnz + ((gnx + x - 1) % gnx) * gnz * gny];
+  xaft = gvin[z + yminus * gnz + ((x + 1) % gnx) * gnz * gny];
+  ybef = gvin[z + ((gny + y - 2) % gny) * gnz + x * gnz * gny];
+  yaft = gvin[z + y * gnz + x * gnz * gny];
+  zbef = gvin[((gnz + z - 1) % gnz) + yminus * gnz + x * gnz * gny];
+  zaft = gvin[(z + 1) % gnz + yminus * gnz + x * gnz * gny];
+  znz[0] = (xaft - xbef) / (2 * gsx);
+  znz[1] = (yaft - ybef) / (2 * gsy);
+  znz[2] = (zaft - zbef) / (2 * gsz);
+  // c010=zpz
+  xbef = gvin[z + yplus * gnz + ((gnx + x - 1) % gnx) * gnz * gny];
+  xaft = gvin[z + yplus * gnz + ((x + 1) % gnx) * gnz * gny];
+  ybef = gvin[z + y * gnz + x * gnz * gny];
+  yaft = gvin[z + ((y + 2) % gny) * gnz + x * gnz * gny];
+  zbef = gvin[((gnz + z - 1) % gnz) + yplus * gnz + x * gnz * gny];
+  zaft = gvin[(z + 1) % gnz + yplus * gnz + x * gnz * gny];
+  zpz[0] = (xaft - xbef) / (2 * gsx);
+  zpz[1] = (yaft - ybef) / (2 * gsy);
+  zpz[2] = (zaft - zbef) / (2 * gsz);
+  // c00-1=zzn
+  xbef = gvin[zminus + y * gnz + ((gnx + x - 1) % gnx) * gnz * gny];
+  xaft = gvin[zminus + y * gnz + ((x + 1) % gnx) * gnz * gny];
+  ybef = gvin[zminus + ((gny + y - 1) % gny) * gnz + x * gnz * gny];
+  yaft = gvin[zminus + ((y + 1) % gny) * gnz + x * gnz * gny];
+  zbef = gvin[((gnz + z - 2) % gnz) + y * gnz + x * gnz * gny];
+  zaft = gvin[z + y * gnz + x * gnz * gny];
+  zzn[0] = (xaft - xbef) / (2 * gsx);
+  zzn[1] = (yaft - ybef) / (2 * gsy);
+  zzn[2] = (zaft - zbef) / (2 * gsz);
+  // c001=zzp
+  xbef = gvin[zplus + y * gnz + ((gnx + x - 1) % gnx) * gnz * gny];
+  xaft = gvin[zplus + y * gnz + ((x + 1) % gnx) * gnz * gny];
+  ybef = gvin[zplus + ((gny + y - 1) % gny) * gnz + x * gnz * gny];
+  yaft = gvin[zplus + ((y + 1) % gny) * gnz + x * gnz * gny];
+  zbef = gvin[z + y * gnz + x * gnz * gny];
+  zaft = gvin[(z + 2) % gnz + y * gnz + x * gnz * gny];
+  zzp[0] = (xaft - xbef) / (2 * gsx);
+  zzp[1] = (yaft - ybef) / (2 * gsy);
+  zzp[2] = (zaft - zbef) / (2 * gsz);
+  gG[0] = -1 * (pzz[0] - nzz[0]) / (2 * gsx);
+  gG[1] = -1 * (zpz[1] - znz[1]) / (2 * gsy);
+  gG[2] = -1 * (zzp[2] - zzn[2]) / (2 * gsz);
+  return;
+}
+
+void FixGridForce::gridGrad(double *gvin, int x, int y, int z, double *gG) {
+  int gnx = domain->grid->gnx;
+  int gny = domain->grid->gny;
+  int gnz = domain->grid->gnz;
+  double gsx = domain->grid->gx[0];
+  double gsy = domain->grid->gy[1];
+  double gsz = domain->grid->gz[2];
+
+  gG[0] = gG[1] = gG[2] = 0;
+
+  gG[0] = -1 * (-1 * gvin[z + y * gnz + ((x + 2) % gnx) * gnz * gny] + 8 * gvin[z + y * gnz + ((x + 1) % gnx) * gnz * gny] - 8 * gvin[z + y * gnz + (x ? (x - 1) : (gnx - 1)) * gnz * gny] + gvin[z + y * gnz + ((gnx + x - 2) % gnx) * gnz * gny]) / (12 * gsx);
+  gG[1] = -1 * (-1 * gvin[z + ((y + 2) % gny) * gnz + x * gnz * gny] + 8 * gvin[z + ((y + 1) % gny) * gnz + x * gnz * gny] - 8 * gvin[z + (y ? (y - 1) : (gny - 1)) * gnz + x * gnz * gny] + gvin[z + ((gny + y - 2) % gny) * gnz + x * gnz * gny]) / (12 * gsy);
+  gG[2] = -1 * (-1 * gvin[((z + 2) % gnz) + y * gnz + x * gnz * gny] + 8 * gvin[((z + 1) % gnz) + y * gnz + x * gnz * gny] - 8 * gvin[(z ? (z - 1) : (gnz - 1)) + y * gnz + x * gnz * gny] + gvin[((gnz + z - 2) % gnz) + y * gnz + x * gnz * gny]) / (12 * gsz);
+  // gG[0] = -1*(gvin[z+y*gnz+((x+1)%gnx)*gnz*gny]-gvin[z+y*gnz+(x?(x-1):(gnx-1))*gnz*gny])/(2*gsx);
+  // gG[1] = -1*(gvin[z+((y+1)%gny)*gnz+x*gnz*gny]-gvin[z+(y?(y-1):(gny-1))*gnz+x*gnz*gny])/(2*gsy);
+  // gG[2] = -1*(gvin[((z+1)%gnz)+y*gnz+x*gnz*gny]-gvin[(z?(z-1):(gnz-1))+y*gnz+x*gnz*gny])/(2*gsz);
+
+  return;
+}
+
+/* ----------------------------------------------------------------------
+  compute position xM of fictitious charge site for O atom and 2 H atoms
+  return it as xM
+------------------------------------------------------------------------- */
+
+void FixGridForce::compute_newsite(double *xO, double *xH1,
+                                   double *xH2, double *xM) {
+  double delx1 = xH1[0] - xO[0];
+  double dely1 = xH1[1] - xO[1];
+  double delz1 = xH1[2] - xO[2];
+
+  double delx2 = xH2[0] - xO[0];
+  double dely2 = xH2[1] - xO[1];
+  double delz2 = xH2[2] - xO[2];
+
+  xM[0] = xO[0] + alpha * 0.5 * (delx1 + delx2);
+  xM[1] = xO[1] + alpha * 0.5 * (dely1 + dely2);
+  xM[2] = xO[2] + alpha * 0.5 * (delz1 + delz2);
+}
+
+int FixGridForce::find(char *name) {
+  if(name==NULL) return -1;
+  if(strcmp(name,"H") == 0) {RepX=866.6; Polar=1.693;} // unit: real for RepX
+  if(strcmp(name,"O") == 0) {RepX=9766.9; Polar=5.20;}
+  if(strcmp(name,"N") == 0) {RepX=6593.4; Polar=7.25;}
+  if(strcmp(name,"S") == 0) {RepX=2127.6; Polar=19.5;}
+  if(strcmp(name,"C") == 0) {RepX=3231.7; Polar=11.7;}
+  if(strcmp(name,"Li") == 0) {RepX=7091.; Polar=0.193;}
+  if(strcmp(name,"Na") == 0) {RepX=15575.; Polar=0.93;}
+  if(strcmp(name,"K") == 0) {RepX=14753.; Polar=5.05;}
+  if(strcmp(name,"Rb") == 0) {RepX=12086.; Polar=8.32;}
+  if(strcmp(name,"Cs") == 0) {RepX=7047.; Polar=15.0;}
+  if(strcmp(name,"He") == 0) {RepX=14922.; Polar=1.38;}
+  if(strcmp(name,"Ne") == 0) {RepX=13811.; Polar=2.67;}
+  if(strcmp(name,"Ar") == 0) {RepX=6953.; Polar=11.1;}
+  if(strcmp(name,"Kr") == 0) {RepX=4780.; Polar=16.8;}
+  if(strcmp(name,"Xe") == 0) {RepX=2844.; Polar=27.2;}
+  if(strcmp(name,"F") == 0) {RepX=1632.; Polar=15.0;}
+  if(strcmp(name,"Cl") == 0) {RepX=1691.; Polar=30.3;}
+  if(strcmp(name,"Br") == 0) {RepX=1365.; Polar=42.8;}
+  if(strcmp(name,"I") == 0) {RepX=1216.; Polar=61.7;}
+  if(strcmp(name,"P") == 0) {RepX=2744.5; Polar=24.8;}
+  return -1;
+}
+
diff -uN src/fix_gridforce.h src_DFT-CES2/fix_gridforce.h
--- src/fix_gridforce.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_gridforce.h	2025-02-11 06:42:37.181608945 +0900
@@ -0,0 +1,77 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   DFT-CES core subroutines. Written by H.-K. Lim
+   Copyright (C) 2016 M-design group @ KAIST
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(gridforce,FixGridForce)
+
+#else
+
+#ifndef LMP_FIX_GRIDFORCE_H
+#define LMP_FIX_GRIDFORCE_H
+
+#include "fix.h"
+#include <map>
+#include <string>
+
+namespace LAMMPS_NS {
+
+class FixGridForce : public Fix {
+ public:
+  FixGridForce(class LAMMPS *, int, char **);
+  ~FixGridForce();
+  int setmask();
+  void init();
+  void setup(int);
+  void post_force(int);
+  double compute_scalar();
+  double compute_vector(int);
+  void triInterRep(double, double, double, double, double*, int);
+//  void triInter(double, double, double, double, double*, int);
+  void triInterInduce(double, double,double, double, double, double*, int);
+  double triInterValue(double,double,double,double,double,double,double,double,double,double,double);
+  double gridValue(double*, int, int, int);
+  void gridGrad(double*, int, int, int, double*);
+  void sc_gridGrad(double*, int, int, int, double*);
+  int tip4p_CES; //DFT-CES with tip4p tag 
+	int find(char *);
+
+//  void grid2ndGrad(double*, int, int, int, double*);
+
+ private:
+  double weight;      // weight factor for grid energy and force, usually -1 for QE coupling
+  int sfactor;        // supercell factor
+  int cubeID;        // cubefile id 
+  int cubeID_tip4p_O;        // cubefile id 
+  double tmp3[3], tmp4[4],tmp5[4],tmp6[8];
+  double newsite[3];
+  //double tmp3[3], tmp4[4],tmp5[8];
+ 
+  int force_flag;
+//  int force_flag2;
+
+  double Egrid[3];
+  double Egrid_all[3];
+//  double EgridRep;
+//  double Egrid_all, EgridRep_all;
+  
+
+ protected:
+  int typeH,typeO;             // atom types of TIP4P water H and O atoms
+  double theta,blen;             // angle and bond types of TIP4P water
+  double alpha;                // geometric constraint parameter for TIP4P
+  double qdist;
+  double RepX;					// Pauli Repulsion parameter of atomic species X in kcal/mol bohr3
+  double Polar;					// isotropic polarizability
+	char *RepXmeta;
+
+  void compute_newsite(double *, double *, double *, double *);
+
+};
+
+}
+
+#endif
+#endif
diff -uN src/fix_rattle.cpp src_DFT-CES2/fix_rattle.cpp
--- src/fix_rattle.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rattle.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,1007 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Peter Wirnsberger (University of Cambridge)
+------------------------------------------------------------------------- */
+
+#include <mpi.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include "fix_rattle.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "update.h"
+#include "respa.h"
+#include "modify.h"
+#include "domain.h"
+#include "force.h"
+#include "bond.h"
+#include "angle.h"
+#include "comm.h"
+#include "group.h"
+#include "fix_respa.h"
+#include "math_const.h"
+#include "math_extra.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathConst;
+using namespace MathExtra;
+
+// set RATTLE_DEBUG  1 to check constraints at end of timestep
+
+#define RATTLE_DEBUG 0
+
+// set RATTLE_RAISE_ERROR 1 if you want this fix to raise
+//     an error if the constraints cannot be satisfied
+
+#define RATTLE_RAISE_ERROR 0
+
+// You can enable velocity and coordinate checks separately
+// by setting RATTLE_TEST_VEL/POS true
+
+#define RATTLE_TEST_VEL false
+#define RATTLE_TEST_POS false
+
+enum{V,VP,XSHAKE};
+
+/* ---------------------------------------------------------------------- */
+
+FixRattle::FixRattle(LAMMPS *lmp, int narg, char **arg) :
+  FixShake(lmp, narg, arg)
+{
+  rattle = 1;
+
+  // allocate memory for unconstrained velocity update
+
+  vp = NULL;
+  grow_arrays(atom->nmax);
+
+  // default communication mode
+  // necessary for compatibility with SHAKE
+  // see pack_forward and unpack_forward
+
+  comm_mode = XSHAKE;
+  vflag_post_force = 0;
+
+  verr_max = 0;  
+  derr_max = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixRattle::~FixRattle()
+{ 
+  memory->destroy(vp);
+
+
+  if (RATTLE_DEBUG) {
+
+    // communicate maximum distance error
+
+    double global_derr_max, global_verr_max;
+    int npid;
+
+    MPI_Reduce(&derr_max, &global_derr_max, 1 , MPI_DOUBLE, MPI_MAX, 0, world);
+    MPI_Reduce(&verr_max, &global_verr_max, 1 , MPI_DOUBLE, MPI_MAX, 0, world);
+
+    MPI_Comm_rank (world, &npid); // Find out process rank
+
+    if (npid == 0 && screen) {
+      fprintf(screen, "RATTLE: Maximum overall relative position error ( (r_ij-d_ij)/d_ij ): %.10g\n", global_derr_max);
+      fprintf(screen, "RATTLE: Maximum overall absolute velocity error (r_ij * v_ij): %.10g\n", global_verr_max);
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRattle::setmask()
+{
+  int mask = 0;
+  mask |= PRE_NEIGHBOR;
+  mask |= POST_FORCE; 
+  mask |= POST_FORCE_RESPA;
+  mask |= FINAL_INTEGRATE;
+  mask |= FINAL_INTEGRATE_RESPA;
+  if (RATTLE_DEBUG) mask |= END_OF_STEP;          
+  return mask;
+}
+
+/* ----------------------------------------------------------------------
+   initialize RATTLE and check that this is the last final_integrate fix
+------------------------------------------------------------------------- */
+
+void FixRattle::init() {
+
+  // initialise SHAKE first
+
+  FixShake::init();
+
+  // show a warning if any final-integrate fix comes after this one
+
+  int after = 0;
+  int flag = 0;
+  for (int i = 0; i < modify->nfix; i++) {
+    if (strcmp(id,modify->fix[i]->id) == 0) after = 1;
+    else if ((modify->fmask[i] & FINAL_INTEGRATE) && after) flag = 1;
+  }
+
+  if (flag && comm->me == 0)
+    error->warning(FLERR,
+                   "Fix rattle should come after all other integration fixes ");
+}
+
+/* ----------------------------------------------------------------------
+   This method carries out an unconstrained velocity update first and
+   then applies the velocity corrections directly (v and vp are modified).
+------------------------------------------------------------------------- */
+
+void FixRattle::post_force(int vflag)
+{
+  // remember vflag for the coordinate correction in this->final_integrate
+
+  vflag_post_force = vflag;
+
+  // unconstrained velocity update by half a timestep
+  // similar to FixShake::unconstrained_update()
+
+  update_v_half_nocons();
+
+  // communicate the unconstrained velocities
+
+  if (nprocs > 1) {
+    comm_mode = VP;
+    comm->forward_comm_fix(this);
+  }
+
+  // correct the velocity for each molecule accordingly
+
+  int m;
+  for (int i = 0; i < nlist; i++) {
+    m = list[i];
+    if      (shake_flag[m] == 2)        vrattle2(m);   
+    else if (shake_flag[m] == 3)        vrattle3(m);  
+    else if (shake_flag[m] == 4)        vrattle4(m);  
+    else                                vrattle3angle(m); 
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::post_force_respa(int vflag, int ilevel, int iloop)
+{
+  // remember vflag for the coordinate correction in this->final_integrate
+
+  vflag_post_force = vflag;
+
+  // unconstrained velocity update by half a timestep
+  // similar to FixShake::unconstrained_update()
+
+  update_v_half_nocons_respa(ilevel);
+
+  // communicate the unconstrained velocities
+
+  if (nprocs > 1) {
+    comm_mode = VP;
+    comm->forward_comm_fix(this);
+  }
+
+  // correct the velocity for each molecule accordingly
+
+  int m;
+  for (int i = 0; i < nlist; i++) {
+    m = list[i];
+    if      (shake_flag[m] == 2)        vrattle2(m);
+    else if (shake_flag[m] == 3)        vrattle3(m);
+    else if (shake_flag[m] == 4)        vrattle4(m);
+    else                                vrattle3angle(m);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   let SHAKE calculate the constraining forces for the coordinates
+------------------------------------------------------------------------- */
+
+void FixRattle::final_integrate()
+{
+  comm_mode = XSHAKE;
+  FixShake::post_force(vflag_post_force);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::final_integrate_respa(int ilevel, int iloop)
+{
+  comm_mode = XSHAKE;
+  FixShake::post_force_respa(vflag_post_force, ilevel, iloop);
+}
+
+/* ----------------------------------------------------------------------
+   correct velocities of molecule m with 2 constraints bonds and 1 angle
+------------------------------------------------------------------------- */
+
+void FixRattle::vrattle3angle(int m)
+{
+  tagint i0,i1,i2;
+  double c[3], l[3], a[3][3], r01[3], imass[3],
+         r02[3], r12[3], vp01[3], vp02[3], vp12[3];
+
+  // local atom IDs and constraint distances
+
+  i0 = atom->map(shake_atom[m][0]);
+  i1 = atom->map(shake_atom[m][1]);
+  i2 = atom->map(shake_atom[m][2]);
+
+  // r01,r02,r12 = distance vec between atoms
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  MathExtra::sub3(x[i2],x[i0],r02);
+  MathExtra::sub3(x[i2],x[i1],r12);
+
+  // take into account periodicity
+
+  domain->minimum_image(r01);
+  domain->minimum_image(r02);
+  domain->minimum_image(r12);
+
+  // v01,v02,v12 = velocity differences 
+
+  MathExtra::sub3(vp[i1],vp[i0],vp01);
+  MathExtra::sub3(vp[i2],vp[i0],vp02);
+  MathExtra::sub3(vp[i2],vp[i1],vp12);
+
+  // matrix coeffs and rhs for lamda equations
+
+  if (rmass) {
+    imass[0] = 1.0/rmass[i0];
+    imass[1] = 1.0/rmass[i1];
+    imass[2] = 1.0/rmass[i2];
+  } else {
+    imass[0] = 1.0/mass[type[i0]];
+    imass[1] = 1.0/mass[type[i1]];
+    imass[2] = 1.0/mass[type[i2]];
+  }
+
+  // setup matrix
+
+  a[0][0]   =   (imass[1] + imass[0])   * MathExtra::dot3(r01,r01);
+  a[0][1]   =   (imass[0]           )   * MathExtra::dot3(r01,r02);
+  a[0][2]   =   (-imass[1]          )   * MathExtra::dot3(r01,r12);
+  a[1][0]   =   a[0][1];
+  a[1][1]   =   (imass[0] + imass[2])   * MathExtra::dot3(r02,r02); 
+  a[1][2]   =   (imass[2]           )   * MathExtra::dot3(r02,r12);
+  a[2][0]   =   a[0][2];
+  a[2][1]   =   a[1][2];
+  a[2][2]   =   (imass[2] + imass[1])   * MathExtra::dot3(r12,r12);
+
+  // sestup RHS
+
+  c[0]  = -MathExtra::dot3(vp01,r01);
+  c[1]  = -MathExtra::dot3(vp02,r02);
+  c[2]  = -MathExtra::dot3(vp12,r12);
+
+  // calculate the inverse matrix exactly
+
+  solve3x3exactly(a,c,l);
+
+  // add corrections to the velocities if processor owns atom
+
+  if (i0 < nlocal) {
+    for (int k=0; k<3; k++)  
+      v[i0][k]  -=  imass[0]*  (  l[0] * r01[k] + l[1] * r02[k] );
+  } 
+  if (i1 < nlocal) {
+    for (int k=0; k<3; k++)  
+      v[i1][k]  -=  imass[1] * ( -l[0] * r01[k] + l[2] * r12[k] );
+  }
+  if (i2 < nlocal) {
+    for (int k=0; k<3; k++) 
+      v[i2][k] -=   imass[2] * ( -l[1] * r02[k] - l[2] * r12[k] );
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::vrattle2(int m)
+{
+  tagint    i0, i1;
+  double    imass[2], r01[3], vp01[3];
+
+  // local atom IDs and constraint distances
+
+  i0 = atom->map(shake_atom[m][0]);
+  i1 = atom->map(shake_atom[m][1]);
+
+  // r01 = distance vec between atoms, with PBC
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  domain->minimum_image(r01);
+
+  // v01 = distance vectors for velocities
+
+  MathExtra::sub3(vp[i1],vp[i0],vp01);
+
+  // matrix coeffs and rhs for lamda equations
+
+  if (rmass) {
+    imass[0] = 1.0/rmass[i0];
+    imass[1] = 1.0/rmass[i1];
+  } else {
+    imass[0] = 1.0/mass[type[i0]];
+    imass[1] = 1.0/mass[type[i1]];
+  }
+
+  // Lagrange multiplier: exact solution
+
+  double l01 = - MathExtra::dot3(r01,vp01) / 
+    (MathExtra::dot3(r01,r01) * (imass[0] + imass[1]));
+
+  // add corrections to the velocities if the process owns this atom
+
+  if (i0 < nlocal) {
+    for (int k=0; k<3; k++)  
+      v[i0][k] -= imass[0] * l01 * r01[k];
+  } 
+  if (i1 < nlocal) {
+    for (int k=0; k<3; k++) 
+      v[i1][k] -= imass[1] * (-l01) * r01[k];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::vrattle3(int m)
+{
+  tagint    i0,i1,i2;
+  double    imass[3], r01[3], r02[3], vp01[3], vp02[3],
+            a[2][2],c[2],l[2];
+
+  // local atom IDs and constraint distances
+
+  i0 = atom->map(shake_atom[m][0]);
+  i1 = atom->map(shake_atom[m][1]);
+  i2 = atom->map(shake_atom[m][2]);
+
+  // r01,r02 = distance vec between atoms, with PBC
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  MathExtra::sub3(x[i2],x[i0],r02);
+ 
+  domain->minimum_image(r01);
+  domain->minimum_image(r02);
+
+  // vp01,vp02 =  distance vectors between velocities
+
+  MathExtra::sub3(vp[i1],vp[i0],vp01);
+  MathExtra::sub3(vp[i2],vp[i0],vp02);
+
+  if (rmass) {
+    imass[0] = 1.0/rmass[i0];
+    imass[1] = 1.0/rmass[i1];
+    imass[2] = 1.0/rmass[i2];
+  } else {
+    imass[0] = 1.0/mass[type[i0]];
+    imass[1] = 1.0/mass[type[i1]];
+    imass[2] = 1.0/mass[type[i2]];
+  }
+
+  // setup matrix
+
+  a[0][0]   =   (imass[1] + imass[0])   * MathExtra::dot3(r01,r01);
+  a[0][1]   =   (imass[0]           )   * MathExtra::dot3(r01,r02);
+  a[1][0]   =   a[0][1];
+  a[1][1]   =   (imass[0] + imass[2])   * MathExtra::dot3(r02,r02);
+
+  // setup RHS
+
+  c[0]  = - MathExtra::dot3(vp01,r01);
+  c[1]  = - MathExtra::dot3(vp02,r02);
+
+  // calculate the inverse 2x2 matrix exactly
+
+  solve2x2exactly(a,c,l);
+
+  // add corrections to the velocities if the process owns this atom
+
+  if (i0 < nlocal) {
+    for (int k=0; k<3; k++)  
+      v[i0][k] -= imass[0] * (  l[0] * r01[k] + l[1] * r02[k] );
+  } 
+  if (i1 < nlocal) 
+    for (int k=0; k<3; k++) {
+      v[i1][k] -= imass[1] * ( -l[0] * r01[k] );
+  }
+  if (i2 < nlocal) {
+    for (int k=0; k<3; k++) 
+      v[i2][k] -= imass[2] * ( -l[1] * r02[k] );
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::vrattle4(int m)
+{
+  tagint    i0,i1,i2,i3;
+  double    imass[4], c[3], l[3], a[3][3],
+            r01[3], r02[3], r03[3], vp01[3], vp02[3], vp03[3];
+
+  // local atom IDs and constraint distances
+
+  i0 = atom->map(shake_atom[m][0]);
+  i1 = atom->map(shake_atom[m][1]);
+  i2 = atom->map(shake_atom[m][2]);
+  i3 = atom->map(shake_atom[m][3]);
+
+  // r01,r02,r12 = distance vec between atoms, with PBC
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  MathExtra::sub3(x[i2],x[i0],r02);
+  MathExtra::sub3(x[i3],x[i0],r03);
+
+  domain->minimum_image(r01);
+  domain->minimum_image(r02);
+  domain->minimum_image(r03);
+
+  // vp01,vp02,vp03 = distance vectors between velocities
+
+  MathExtra::sub3(vp[i1],vp[i0],vp01);
+  MathExtra::sub3(vp[i2],vp[i0],vp02);
+  MathExtra::sub3(vp[i3],vp[i0],vp03);
+
+  // matrix coeffs and rhs for lamda equations
+
+  if (rmass) {
+    imass[0] = 1.0/rmass[i0];
+    imass[1] = 1.0/rmass[i1];
+    imass[2] = 1.0/rmass[i2];
+    imass[3] = 1.0/rmass[i3];
+  } else {
+    imass[0] = 1.0/mass[type[i0]];
+    imass[1] = 1.0/mass[type[i1]];
+    imass[2] = 1.0/mass[type[i2]];
+    imass[3] = 1.0/mass[type[i3]];
+  }
+
+  // setup matrix
+
+  a[0][0]   =   (imass[0] + imass[1])   * MathExtra::dot3(r01,r01);
+  a[0][1]   =   (imass[0]           )   * MathExtra::dot3(r01,r02);
+  a[0][2]   =   (imass[0]           )   * MathExtra::dot3(r01,r03);
+  a[1][0]   =   a[0][1];
+  a[1][1]   =   (imass[0] + imass[2])   * MathExtra::dot3(r02,r02);
+  a[1][2]   =   (imass[0]           )   * MathExtra::dot3(r02,r03);
+  a[2][0]   =   a[0][2];
+  a[2][1]   =   a[1][2];
+  a[2][2]   =   (imass[0] + imass[3])   * MathExtra::dot3(r03,r03);
+
+  // setup RHS
+
+  c[0]  = - MathExtra::dot3(vp01,r01);
+  c[1]  = - MathExtra::dot3(vp02,r02);
+  c[2]  = - MathExtra::dot3(vp03,r03);
+
+  // calculate the inverse 3x3 matrix exactly
+
+  solve3x3exactly(a,c,l);
+
+  // add corrections to the velocities if the process owns this atom
+
+  if (i0 < nlocal) {
+    for (int k=0; k<3; k++) 
+      v[i0][k] -= imass[0] * (  l[0] * r01[k] + l[1] * r02[k] + l[2] * r03[k]);
+  } 
+  if (i1 < nlocal) {
+    for (int k=0; k<3; k++) 
+      v[i1][k] -= imass[1] * (-l[0] * r01[k]); 
+  }
+  if (i2 < nlocal) {
+    for (int k=0; k<3; k++) 
+      v[i2][k] -= imass[2] * ( -l[1] * r02[k]);
+  }
+  if (i3 < nlocal) {
+    for (int k=0; k<3; k++) 
+      v[i3][k] -= imass[3] * ( -l[2] * r03[k]);                 
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::solve2x2exactly(const double a[][2], 
+                                const double c[], double l[])
+{
+  double determ, determinv;
+
+  // calculate the determinant of the matrix
+
+  determ = a[0][0] * a[1][1] - a[0][1] * a[1][0];
+
+  // check if matrix is actually invertible
+
+  if (determ == 0.0) error->one(FLERR,"Rattle determinant = 0.0");
+  determinv = 1.0/determ;
+
+  // Calculate the solution:  (l01, l02)^T = A^(-1) * c
+
+  l[0] = determinv * ( a[1][1] * c[0]  - a[0][1] * c[1]);
+  l[1] = determinv * (-a[1][0] * c[0]  + a[0][0] * c[1]);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::solve3x3exactly(const double a[][3], 
+                                const double c[], double l[])
+{
+  double ai[3][3];
+  double determ, determinv;
+  
+  // calculate the determinant of the matrix
+
+  determ = a[0][0]*a[1][1]*a[2][2] + a[0][1]*a[1][2]*a[2][0] + 
+    a[0][2]*a[1][0]*a[2][1] - a[0][0]*a[1][2]*a[2][1] - 
+    a[0][1]*a[1][0]*a[2][2] - a[0][2]*a[1][1]*a[2][0];
+  
+  // check if matrix is actually invertible
+
+  if (determ == 0.0) error->one(FLERR,"Rattle determinant = 0.0");
+
+  // calculate the inverse 3x3 matrix: A^(-1) = (ai_jk)
+
+  determinv = 1.0/determ;
+  ai[0][0] =  determinv * (a[1][1]*a[2][2] - a[1][2]*a[2][1]);
+  ai[0][1] = -determinv * (a[0][1]*a[2][2] - a[0][2]*a[2][1]); 
+  ai[0][2] =  determinv * (a[0][1]*a[1][2] - a[0][2]*a[1][1]);
+  ai[1][0] = -determinv * (a[1][0]*a[2][2] - a[1][2]*a[2][0]);
+  ai[1][1] =  determinv * (a[0][0]*a[2][2] - a[0][2]*a[2][0]);
+  ai[1][2] = -determinv * (a[0][0]*a[1][2] - a[0][2]*a[1][0]);
+  ai[2][0] =  determinv * (a[1][0]*a[2][1] - a[1][1]*a[2][0]);
+  ai[2][1] = -determinv * (a[0][0]*a[2][1] - a[0][1]*a[2][0]);
+  ai[2][2] =  determinv * (a[0][0]*a[1][1] - a[0][1]*a[1][0]);
+
+  // calculate the solution:  (l01, l02, l12)^T = A^(-1) * c
+
+  for (int i=0; i<3; i++) {
+    l[i] = 0;
+    for (int j=0; j<3; j++) 
+      l[i] += ai[i][j] * c[j];
+  }  
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::reset_dt()
+{
+  FixShake::reset_dt();
+}
+
+/* ----------------------------------------------------------------------
+   carry out an unconstrained velocity update (vp is modified)
+------------------------------------------------------------------------- */
+
+void FixRattle::update_v_half_nocons()
+{
+  const double dtfv = 0.5 * update->dt * force->ftm2v;
+  double dtfvinvm;
+
+  if (rmass) {
+    for (int i = 0; i < nlocal; i++) {
+      if (shake_flag[i]) {
+        dtfvinvm = dtfv / rmass[i];
+        for (int k=0; k<3; k++)
+          vp[i][k] = v[i][k] + dtfvinvm * f[i][k];
+      }
+      else
+        vp[i][0] = vp[i][1] = vp[i][2] = 0;
+    }
+  }
+  else {
+    for (int i = 0; i < nlocal; i++) {
+      dtfvinvm = dtfv/mass[type[i]];
+      if (shake_flag[i]) {
+        for (int k=0; k<3; k++)
+          vp[i][k] = v[i][k] + dtfvinvm * f[i][k];
+      }
+      else
+        vp[i][0] = vp[i][1] = vp[i][2] = 0;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::update_v_half_nocons_respa(int ilevel)
+{
+  // carry out unconstrained velocity update
+
+  update_v_half_nocons();
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based arrays
+------------------------------------------------------------------------- */
+
+double FixRattle::memory_usage()
+{
+  int nmax = atom->nmax;
+  double bytes = FixShake::memory_usage();
+  bytes += nmax*3 * sizeof(double);
+  return bytes;
+}
+
+/* ----------------------------------------------------------------------
+   allocate local atom-based arrays
+------------------------------------------------------------------------- */
+
+void FixRattle::grow_arrays(int nmax)
+{
+  FixShake::grow_arrays(nmax);
+  memory->destroy(vp);
+  memory->create(vp,nmax,3,"rattle:vp");
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRattle::pack_forward_comm(int n, int *list, double *buf,
+                                 int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  m = 0;
+
+  switch (comm_mode) {
+    case XSHAKE:
+      m = FixShake::pack_forward_comm(n, list, buf, pbc_flag, pbc);
+      break;
+    case VP:
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = vp[j][0];
+        buf[m++] = vp[j][1];
+        buf[m++] = vp[j][2];
+      }
+      break;
+
+    case V:
+      for (i = 0; i < n; i++) {
+        j = list[i];
+        buf[m++] = v[j][0];
+        buf[m++] = v[j][1];
+        buf[m++] = v[j][2];
+      }
+      break;
+  }
+  return m;
+} 
+
+/* ---------------------------------------------------------------------- */
+
+void FixRattle::unpack_forward_comm(int n, int first, double *buf)
+{
+  int i, m, last;
+  m = 0;
+  last = first + n;
+
+  switch (comm_mode) {
+    case XSHAKE:
+      FixShake::unpack_forward_comm(n, first,buf);
+      break;
+
+    case VP:
+      for (i = first; i < last; i++) {
+        vp[i][0] = buf[m++];
+        vp[i][1] = buf[m++];
+        vp[i][2] = buf[m++];
+      }
+      break;
+
+    case V:
+      for (i = first; i < last; i++) {
+        v[i][0] = buf[m++];
+        v[i][1] = buf[m++];
+        v[i][2] = buf[m++];
+      }
+      break;
+  }
+}
+
+
+/* ----------------------------------------------------------------------
+  Let shake calculate new constraining forces for the coordinates;
+  As opposed to the regular shake call, this method is usually called from
+  end_of_step fixes after the second velocity integration has happened.
+------------------------------------------------------------------------- */
+
+void FixRattle::shake_end_of_step(int vflag) {
+
+  if (nprocs > 1) {
+    comm_mode = V;
+    comm->forward_comm_fix(this);
+  }
+
+  comm_mode = XSHAKE;
+  FixShake::shake_end_of_step(vflag);
+}
+
+
+/* ----------------------------------------------------------------------
+  Let shake calculate new constraining forces and correct the 
+  coordinates. Nothing to do for rattle here.
+------------------------------------------------------------------------- */
+
+void FixRattle::correct_coordinates(int vflag) {
+  comm_mode = XSHAKE;
+  FixShake::correct_coordinates(vflag);
+}
+
+
+/* ----------------------------------------------------------------------
+   Remove the velocity component along any bond.
+------------------------------------------------------------------------- */
+
+void FixRattle::correct_velocities() {
+
+  // Copy current velocities instead of unconstrained_update, because the correction
+  // should happen instantaneously and not after the next half step.
+
+  for (int i = 0; i < atom->nlocal; i++) {
+    if (shake_flag[i]) {
+      for (int k=0; k<3; k++)
+        vp[i][k] = v[i][k];
+    }
+    else
+      vp[i][0] = vp[i][1] = vp[i][2] = 0;
+  }
+
+  // communicate the unconstrained velocities
+
+  if (nprocs > 1) {
+    comm_mode = VP;
+    comm->forward_comm_fix(this);
+  }
+
+  // correct the velocity for each molecule accordingly
+
+  int m;
+  for (int i = 0; i < nlist; i++) {
+    m = list[i];
+    if      (shake_flag[m] == 2)        vrattle2(m);
+    else if (shake_flag[m] == 3)        vrattle3(m);
+    else if (shake_flag[m] == 4)        vrattle4(m);
+    else                                vrattle3angle(m);
+  }
+}
+
+
+/* ----------------------------------------------------------------------
+   DEBUGGING methods
+   The functions below allow you to check whether the 
+     coordinate and velocity constraints are satisfied at the
+     end of the timestep
+   only enabled if RATTLE_DEBUG is set to 1 at top of file
+   checkX tests if shakeX and vrattleX worked as expected
+------------------------------------------------------------------------- */
+
+void FixRattle::end_of_step()
+{
+  if (nprocs > 1) {
+       comm_mode = V;
+       comm->forward_comm_fix(this);
+  }
+  if (!check_constraints(v, RATTLE_TEST_POS, RATTLE_TEST_VEL) && RATTLE_RAISE_ERROR) {
+    error->one(FLERR, "Rattle failed ");
+  }
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+bool FixRattle::check_constraints(double **v, bool checkr, bool checkv)
+{
+  int m;
+  bool ret = true;
+  int i=0;
+  while (i < nlist && ret) {
+    m = list[i];
+    if      (shake_flag[m] == 2)     ret =   check2(v,m,checkr,checkv); 
+    else if (shake_flag[m] == 3)     ret =   check3(v,m,checkr,checkv); 
+    else if (shake_flag[m] == 4)     ret =   check4(v,m,checkr,checkv); 
+    else                             ret =   check3angle(v,m,checkr,checkv);
+    i++;
+    if (!RATTLE_RAISE_ERROR)         ret = true;
+  }
+  return ret;
+}
+
+/* ---------------------------------------------------------------------- */
+
+bool FixRattle::check2(double **v, int m, bool checkr, bool checkv)
+{
+  bool      stat;
+  double    r01[3],v01[3];
+  const double tol = tolerance;
+  double bond1 = bond_distance[shake_type[m][0]];
+ 
+  tagint i0 = atom->map(shake_atom[m][0]);
+  tagint i1 = atom->map(shake_atom[m][1]);
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  domain->minimum_image(r01);
+  MathExtra::sub3(v[i1],v[i0],v01);
+
+  stat = !(checkr && (fabs(sqrt(MathExtra::dot3(r01,r01)) - bond1) > tol));
+  if (!stat)   
+     error->one(FLERR,"Coordinate constraints are not satisfied "
+                "up to desired tolerance ");
+
+  stat = !(checkv && (fabs(MathExtra::dot3(r01,v01)) > tol));
+  if (!stat)   
+     error->one(FLERR,"Velocity constraints are not satisfied "
+                "up to desired tolerance ");
+  return stat;
+}
+
+/* ---------------------------------------------------------------------- */
+
+bool FixRattle::check3(double **v, int m, bool checkr, bool checkv)
+{
+  bool      stat;
+  tagint    i0,i1,i2;
+  double    r01[3], r02[3], v01[3], v02[3];
+  const double tol = tolerance;
+  double bond1 = bond_distance[shake_type[m][0]];
+  double bond2 = bond_distance[shake_type[m][1]];
+ 
+  i0 = atom->map(shake_atom[m][0]);
+  i1 = atom->map(shake_atom[m][1]);
+  i2 = atom->map(shake_atom[m][2]);
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  MathExtra::sub3(x[i2],x[i0],r02);
+ 
+  domain->minimum_image(r01);
+  domain->minimum_image(r02);
+
+  MathExtra::sub3(v[i1],v[i0],v01);
+  MathExtra::sub3(v[i2],v[i0],v02);
+
+  stat = !(checkr && (fabs(sqrt(MathExtra::dot3(r01,r01)) - bond1) > tol ||
+                      fabs(sqrt(MathExtra::dot3(r02,r02))-bond2) > tol));
+  if (!stat)   
+     error->one(FLERR,"Coordinate constraints are not satisfied "
+                "up to desired tolerance ");
+
+  stat = !(checkv && (fabs(MathExtra::dot3(r01,v01)) > tol || 
+                      fabs(MathExtra::dot3(r02,v02)) > tol));
+  if (!stat)   
+     error->one(FLERR,"Velocity constraints are not satisfied "
+                "up to desired tolerance ");
+  return stat;
+}
+
+/* ---------------------------------------------------------------------- */
+
+bool FixRattle::check4(double **v, int m, bool checkr, bool checkv)
+{
+  bool stat = true;
+  const double tol = tolerance;
+  double r01[3], r02[3], r03[3], v01[3], v02[3], v03[3];
+
+  int i0 = atom->map(shake_atom[m][0]);
+  int i1 = atom->map(shake_atom[m][1]);
+  int i2 = atom->map(shake_atom[m][2]);
+  int i3 = atom->map(shake_atom[m][3]);
+  double bond1 = bond_distance[shake_type[m][0]];
+  double bond2 = bond_distance[shake_type[m][1]];
+  double bond3 = bond_distance[shake_type[m][2]];
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  MathExtra::sub3(x[i2],x[i0],r02);
+  MathExtra::sub3(x[i3],x[i0],r03);
+
+  domain->minimum_image(r01);
+  domain->minimum_image(r02);
+  domain->minimum_image(r03);
+
+  MathExtra::sub3(v[i1],v[i0],v01);
+  MathExtra::sub3(v[i2],v[i0],v02);
+  MathExtra::sub3(v[i3],v[i0],v03);
+
+  stat = !(checkr && (fabs(sqrt(MathExtra::dot3(r01,r01)) - bond1) > tol || 
+                      fabs(sqrt(MathExtra::dot3(r02,r02))-bond2) > tol || 
+                      fabs(sqrt(MathExtra::dot3(r03,r03))-bond3) > tol));
+  if (!stat)   
+     error->one(FLERR,"Coordinate constraints are not satisfied "
+                "up to desired tolerance ");
+
+  stat = !(checkv && (fabs(MathExtra::dot3(r01,v01)) > tol || 
+                      fabs(MathExtra::dot3(r02,v02)) > tol || 
+                      fabs(MathExtra::dot3(r03,v03)) > tol));
+  if (!stat)   
+     error->one(FLERR,"Velocity constraints are not satisfied "
+                "up to desired tolerance ");
+  return stat;
+}
+
+/* ---------------------------------------------------------------------- */
+
+bool FixRattle::check3angle(double **v, int m, bool checkr, bool checkv)
+{
+  bool stat = true;
+  const double tol = tolerance;
+  double r01[3], r02[3], r12[3], v01[3], v02[3], v12[3];
+
+  int i0 = atom->map(shake_atom[m][0]);
+  int i1 = atom->map(shake_atom[m][1]);
+  int i2 = atom->map(shake_atom[m][2]);
+  double bond1 = bond_distance[shake_type[m][0]];
+  double bond2 = bond_distance[shake_type[m][1]];
+  double bond12 = angle_distance[shake_type[m][2]];
+
+  MathExtra::sub3(x[i1],x[i0],r01);
+  MathExtra::sub3(x[i2],x[i0],r02);
+  MathExtra::sub3(x[i2],x[i1],r12);
+
+  domain->minimum_image(r01);
+  domain->minimum_image(r02);
+  domain->minimum_image(r12);
+
+  MathExtra::sub3(v[i1],v[i0],v01);
+  MathExtra::sub3(v[i2],v[i0],v02);
+  MathExtra::sub3(v[i2],v[i1],v12);
+
+
+
+  double db1 = fabs(sqrt(MathExtra::dot3(r01,r01)) - bond1);
+  double db2 = fabs(sqrt(MathExtra::dot3(r02,r02))-bond2);
+  double db12 = fabs(sqrt(MathExtra::dot3(r12,r12))-bond12);
+
+
+  stat = !(checkr && (db1 > tol || 
+                      db2 > tol || 
+                      db12 > tol));
+
+  if (derr_max < db1/bond1)    derr_max = db1/bond1;
+  if (derr_max < db2/bond2)    derr_max = db2/bond2;
+  if (derr_max < db12/bond12)  derr_max = db12/bond12;
+
+
+  if (!stat && RATTLE_RAISE_ERROR)   
+     error->one(FLERR,"Coordinate constraints are not satisfied "
+                "up to desired tolerance ");
+
+  double dv1 = fabs(MathExtra::dot3(r01,v01));
+  double dv2 = fabs(MathExtra::dot3(r02,v02));
+  double dv12 = fabs(MathExtra::dot3(r12,v12));
+
+  if (verr_max < dv1)    verr_max = dv1;
+  if (verr_max < dv2)    verr_max = dv2;
+  if (verr_max < dv12)   verr_max = dv12;
+
+
+  stat = !(checkv && (dv1 > tol || 
+                      dv2 > tol || 
+                      dv12> tol));
+
+
+  if (!stat && RATTLE_RAISE_ERROR)   
+     error->one(FLERR,"Velocity constraints are not satisfied "
+                "up to desired tolerance!");
+
+
+  return stat;
+}
diff -uN src/fix_rattle.h src_DFT-CES2/fix_rattle.h
--- src/fix_rattle.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rattle.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,107 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rattle,FixRattle)
+
+#else
+
+#ifndef LMP_FIX_RATTLE_H
+#define LMP_FIX_RATTLE_H
+
+#include "fix.h"
+#include "fix_shake.h"
+
+namespace LAMMPS_NS {
+
+class FixRattle : public FixShake {
+ public:
+  double **vp;                // array for unconstrained velocities
+  int comm_mode;              // mode for communication pack/unpack
+  double derr_max;            // distance error
+  double verr_max;            // velocity error
+
+  FixRattle(class LAMMPS *, int, char **);
+  ~FixRattle();
+  int setmask();
+  virtual void init();
+  virtual void post_force(int);
+  virtual void post_force_respa(int, int, int);
+  virtual void final_integrate();
+  virtual void final_integrate_respa(int,int);
+
+  virtual void correct_coordinates(int vflag);
+  virtual void correct_velocities();
+  virtual void shake_end_of_step(int vflag);
+
+  virtual double memory_usage();
+  virtual void grow_arrays(int);
+  virtual int pack_forward_comm(int, int *, double *, int, int *);
+  virtual void unpack_forward_comm(int, int, double *);
+  virtual void reset_dt();
+
+ private:
+  void update_v_half_nocons();
+  void update_v_half_nocons_respa(int);
+
+  void vrattle2(int m);
+  void vrattle3(int m);
+  void vrattle4(int m);
+  void vrattle3angle(int m);
+  void solve3x3exactly(const double a[][3], const double c[], double l[]);
+  void solve2x2exactly(const double a[][2], const double c[], double l[]);
+
+  // debugging methods
+
+  bool check3angle(double ** v, int m, bool checkr, bool checkv);
+  bool check2(double **v, int m, bool checkr, bool checkv);
+  bool check3(double **v, int m, bool checkr, bool checkv);
+  bool check4(double **v, int m, bool checkr, bool checkv);
+  bool check_constraints(double **v, bool checkr, bool checkv);
+  void end_of_step();
+};
+
+}
+
+#endif
+#endif
+
+
+/* ERROR/WARNING messages:
+
+W: Fix rattle should come after all other integration fixes
+
+This fix is designed to work after all other integration fixes change
+atom positions.  Thus it should be the last integration fix specified.
+If not, it will not satisfy the desired constraints as well as it
+otherwise would.
+
+E: Rattle determinant = 0.0
+
+The determinant of the matrix being solved for a single cluster
+specified by the fix rattle command is numerically invalid.
+
+E: Rattle failed
+
+Certain constraints were not satisfied.
+
+E: Coordinate constraints are not satisfied up to desired tolerance
+
+Self-explanatory.
+
+E: Rattle velocity constraints are not satisfied up to desired tolerance
+
+Self-explanatory.
+
+*/
diff -uN src/fix_rigid.cpp src_DFT-CES2/fix_rigid.cpp
--- src/fix_rigid.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,2656 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "fix_rigid.h"
+#include "math_extra.h"
+#include "atom.h"
+#include "atom_vec_ellipsoid.h"
+#include "atom_vec_line.h"
+#include "atom_vec_tri.h"
+#include "domain.h"
+#include "update.h"
+#include "respa.h"
+#include "modify.h"
+#include "group.h"
+#include "comm.h"
+#include "random_mars.h"
+#include "force.h"
+#include "output.h"
+#include "math_const.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathConst;
+
+enum{SINGLE,MOLECULE,GROUP};
+enum{NONE,XYZ,XY,YZ,XZ};
+enum{ISO,ANISO,TRICLINIC};
+
+#define MAXLINE 1024
+#define CHUNK 1024
+#define ATTRIBUTE_PERBODY 20
+
+#define TOLERANCE 1.0e-6
+#define EPSILON 1.0e-7
+
+#define SINERTIA 0.4            // moment of inertia prefactor for sphere
+#define EINERTIA 0.2            // moment of inertia prefactor for ellipsoid
+#define LINERTIA (1.0/12.0)     // moment of inertia prefactor for line segment
+
+/* ---------------------------------------------------------------------- */
+
+FixRigid::FixRigid(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg), step_respa(NULL), 
+  infile(NULL), nrigid(NULL), mol2body(NULL), body2mol(NULL), 
+  body(NULL), displace(NULL), masstotal(NULL), xcm(NULL), 
+  vcm(NULL), fcm(NULL), inertia(NULL), ex_space(NULL), 
+  ey_space(NULL), ez_space(NULL), angmom(NULL), omega(NULL), 
+  torque(NULL), quat(NULL), imagebody(NULL), fflag(NULL), 
+  tflag(NULL), langextra(NULL), sum(NULL), all(NULL), 
+  remapflag(NULL), xcmimage(NULL), eflags(NULL), orient(NULL), 
+  dorient(NULL), id_dilate(NULL), random(NULL), avec_ellipsoid(NULL), 
+  avec_line(NULL), avec_tri(NULL)
+{
+  int i,ibody;
+
+  scalar_flag = 1;
+  extscalar = 0;
+  time_integrate = 1;
+  rigid_flag = 1;
+  virial_flag = 1;
+  create_attribute = 1;
+  dof_flag = 1;
+  enforce2d_flag = 1;
+
+  MPI_Comm_rank(world,&me);
+  MPI_Comm_size(world,&nprocs);
+
+  // perform initial allocation of atom-based arrays
+  // register with Atom class
+
+  extended = orientflag = dorientflag = 0;
+  body = NULL;
+  xcmimage = NULL;
+  displace = NULL;
+  eflags = NULL;
+  orient = NULL;
+  dorient = NULL;
+  grow_arrays(atom->nmax);
+  atom->add_callback(0);
+
+  // parse args for rigid body specification
+  // set nbody and body[i] for each atom
+
+  if (narg < 4) error->all(FLERR,"Illegal fix rigid command");
+  int iarg;
+
+  mol2body = NULL;
+  body2mol = NULL;
+
+  // single rigid body
+  // nbody = 1
+  // all atoms in fix group are part of body
+
+  if (strcmp(arg[3],"single") == 0) {
+    rstyle = SINGLE;
+    iarg = 4;
+    nbody = 1;
+
+    int *mask = atom->mask;
+    int nlocal = atom->nlocal;
+
+    for (i = 0; i < nlocal; i++) {
+      body[i] = -1;
+      if (mask[i] & groupbit) body[i] = 0;
+    }
+
+  // each molecule in fix group is a rigid body
+  // maxmol = largest molecule ID
+  // ncount = # of atoms in each molecule (have to sum across procs)
+  // nbody = # of non-zero ncount values
+  // use nall as incremented ptr to set body[] values for each atom
+
+  } else if (strcmp(arg[3],"molecule") == 0) {
+    rstyle = MOLECULE;
+    iarg = 4;
+    if (atom->molecule_flag == 0)
+      error->all(FLERR,"Fix rigid molecule requires atom attribute molecule");
+
+    int *mask = atom->mask;
+    tagint *molecule = atom->molecule;
+    int nlocal = atom->nlocal;
+
+    tagint maxmol_tag = -1;
+    for (i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) maxmol_tag = MAX(maxmol_tag,molecule[i]);
+
+    tagint itmp;
+    MPI_Allreduce(&maxmol_tag,&itmp,1,MPI_LMP_TAGINT,MPI_MAX,world);
+    if (itmp+1 > MAXSMALLINT)
+      error->all(FLERR,"Too many molecules for fix rigid");
+    maxmol = (int) itmp;
+
+    int *ncount;
+    memory->create(ncount,maxmol+1,"rigid:ncount");
+    for (i = 0; i <= maxmol; i++) ncount[i] = 0;
+
+    for (i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) ncount[molecule[i]]++;
+
+    memory->create(mol2body,maxmol+1,"rigid:mol2body");
+    MPI_Allreduce(ncount,mol2body,maxmol+1,MPI_INT,MPI_SUM,world);
+
+    nbody = 0;
+    for (i = 0; i <= maxmol; i++)
+      if (mol2body[i]) mol2body[i] = nbody++;
+      else mol2body[i] = -1;
+
+    memory->create(body2mol,nbody,"rigid:body2mol");
+
+    nbody = 0;
+    for (i = 0; i <= maxmol; i++)
+      if (mol2body[i] >= 0) body2mol[nbody++] = i;
+
+    for (i = 0; i < nlocal; i++) {
+      body[i] = -1;
+      if (mask[i] & groupbit) body[i] = mol2body[molecule[i]];
+    }
+
+    memory->destroy(ncount);
+
+  // each listed group is a rigid body
+  // check if all listed groups exist
+  // an atom must belong to fix group and listed group to be in rigid body
+  // error if atom belongs to more than 1 rigid body
+
+  } else if (strcmp(arg[3],"group") == 0) {
+    if (narg < 5) error->all(FLERR,"Illegal fix rigid command");
+    rstyle = GROUP;
+    nbody = force->inumeric(FLERR,arg[4]);
+    if (nbody <= 0) error->all(FLERR,"Illegal fix rigid command");
+    if (narg < 5+nbody) error->all(FLERR,"Illegal fix rigid command");
+    iarg = 5+nbody;
+
+    int *igroups = new int[nbody];
+    for (ibody = 0; ibody < nbody; ibody++) {
+      igroups[ibody] = group->find(arg[5+ibody]);
+      if (igroups[ibody] == -1)
+        error->all(FLERR,"Could not find fix rigid group ID");
+    }
+
+    int *mask = atom->mask;
+    int nlocal = atom->nlocal;
+
+    int flag = 0;
+    for (i = 0; i < nlocal; i++) {
+      body[i] = -1;
+      if (mask[i] & groupbit)
+        for (ibody = 0; ibody < nbody; ibody++)
+          if (mask[i] & group->bitmask[igroups[ibody]]) {
+            if (body[i] >= 0) flag = 1;
+            body[i] = ibody;
+          }
+    }
+
+    int flagall;
+    MPI_Allreduce(&flag,&flagall,1,MPI_INT,MPI_SUM,world);
+    if (flagall)
+      error->all(FLERR,"One or more atoms belong to multiple rigid bodies");
+
+    delete [] igroups;
+
+  } else error->all(FLERR,"Illegal fix rigid command");
+
+  // error check on nbody
+
+  if (nbody == 0) error->all(FLERR,"No rigid bodies defined");
+
+  // create all nbody-length arrays
+
+  memory->create(nrigid,nbody,"rigid:nrigid");
+  memory->create(masstotal,nbody,"rigid:masstotal");
+  memory->create(xcm,nbody,3,"rigid:xcm");
+  memory->create(vcm,nbody,3,"rigid:vcm");
+  memory->create(fcm,nbody,3,"rigid:fcm");
+  memory->create(inertia,nbody,3,"rigid:inertia");
+  memory->create(ex_space,nbody,3,"rigid:ex_space");
+  memory->create(ey_space,nbody,3,"rigid:ey_space");
+  memory->create(ez_space,nbody,3,"rigid:ez_space");
+  memory->create(angmom,nbody,3,"rigid:angmom");
+  memory->create(omega,nbody,3,"rigid:omega");
+  memory->create(torque,nbody,3,"rigid:torque");
+  memory->create(quat,nbody,4,"rigid:quat");
+  memory->create(imagebody,nbody,"rigid:imagebody");
+  memory->create(fflag,nbody,3,"rigid:fflag");
+  memory->create(tflag,nbody,3,"rigid:tflag");
+  memory->create(langextra,nbody,6,"rigid:langextra");
+
+  memory->create(sum,nbody,6,"rigid:sum");
+  memory->create(all,nbody,6,"rigid:all");
+  memory->create(remapflag,nbody,4,"rigid:remapflag");
+
+  // initialize force/torque flags to default = 1.0
+  // for 2d: fz, tx, ty = 0.0
+
+  array_flag = 1;
+  size_array_rows = nbody;
+  size_array_cols = 15;
+  global_freq = 1;
+  extarray = 0;
+
+  for (i = 0; i < nbody; i++) {
+    fflag[i][0] = fflag[i][1] = fflag[i][2] = 1.0;
+    tflag[i][0] = tflag[i][1] = tflag[i][2] = 1.0;
+    if (domain->dimension == 2) fflag[i][2] = tflag[i][0] = tflag[i][1] = 0.0;
+  }
+
+  // number of linear rigid bodies is counted later
+  nlinear = 0;
+
+  // parse optional args
+
+  int seed;
+  langflag = 0;
+  reinitflag = 1;
+
+  tstat_flag = 0;
+  pstat_flag = 0;
+  allremap = 1;
+  id_dilate = NULL;
+  t_chain = 10;
+  t_iter = 1;
+  t_order = 3;
+  p_chain = 10;
+  infile = NULL;
+
+  pcouple = NONE;
+  pstyle = ANISO;
+  dimension = domain->dimension;
+
+  for (int i = 0; i < 3; i++) {
+    p_start[i] = p_stop[i] = p_period[i] = 0.0;
+    p_flag[i] = 0;
+  }
+
+  while (iarg < narg) {
+    if (strcmp(arg[iarg],"force") == 0) {
+      if (iarg+5 > narg) error->all(FLERR,"Illegal fix rigid command");
+
+      int mlo,mhi;
+      force->bounds(FLERR,arg[iarg+1],nbody,mlo,mhi);
+
+      double xflag,yflag,zflag;
+      if (strcmp(arg[iarg+2],"off") == 0) xflag = 0.0;
+      else if (strcmp(arg[iarg+2],"on") == 0) xflag = 1.0;
+      else error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(arg[iarg+3],"off") == 0) yflag = 0.0;
+      else if (strcmp(arg[iarg+3],"on") == 0) yflag = 1.0;
+      else error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(arg[iarg+4],"off") == 0) zflag = 0.0;
+      else if (strcmp(arg[iarg+4],"on") == 0) zflag = 1.0;
+      else error->all(FLERR,"Illegal fix rigid command");
+
+      if (domain->dimension == 2 && zflag == 1.0)
+        error->all(FLERR,"Fix rigid z force cannot be on for 2d simulation");
+
+      int count = 0;
+      for (int m = mlo; m <= mhi; m++) {
+        fflag[m-1][0] = xflag;
+        fflag[m-1][1] = yflag;
+        fflag[m-1][2] = zflag;
+        count++;
+      }
+      if (count == 0) error->all(FLERR,"Illegal fix rigid command");
+
+      iarg += 5;
+
+    } else if (strcmp(arg[iarg],"torque") == 0) {
+      if (iarg+5 > narg) error->all(FLERR,"Illegal fix rigid command");
+
+      int mlo,mhi;
+      force->bounds(FLERR,arg[iarg+1],nbody,mlo,mhi);
+
+      double xflag,yflag,zflag;
+      if (strcmp(arg[iarg+2],"off") == 0) xflag = 0.0;
+      else if (strcmp(arg[iarg+2],"on") == 0) xflag = 1.0;
+      else error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(arg[iarg+3],"off") == 0) yflag = 0.0;
+      else if (strcmp(arg[iarg+3],"on") == 0) yflag = 1.0;
+      else error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(arg[iarg+4],"off") == 0) zflag = 0.0;
+      else if (strcmp(arg[iarg+4],"on") == 0) zflag = 1.0;
+      else error->all(FLERR,"Illegal fix rigid command");
+
+      if (domain->dimension == 2 && (xflag == 1.0 || yflag == 1.0))
+        error->all(FLERR,"Fix rigid xy torque cannot be on for 2d simulation");
+
+      int count = 0;
+      for (int m = mlo; m <= mhi; m++) {
+        tflag[m-1][0] = xflag;
+        tflag[m-1][1] = yflag;
+        tflag[m-1][2] = zflag;
+        count++;
+      }
+      if (count == 0) error->all(FLERR,"Illegal fix rigid command");
+
+      iarg += 5;
+
+    } else if (strcmp(arg[iarg],"langevin") == 0) {
+      if (iarg+5 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid") != 0 && strcmp(style,"rigid/nve") != 0 &&
+          strcmp(style,"rigid/omp") != 0 && strcmp(style,"rigid/nve/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      langflag = 1;
+      t_start = force->numeric(FLERR,arg[iarg+1]);
+      t_stop = force->numeric(FLERR,arg[iarg+2]);
+      t_period = force->numeric(FLERR,arg[iarg+3]);
+      seed = force->inumeric(FLERR,arg[iarg+4]);
+      if (t_period <= 0.0)
+        error->all(FLERR,"Fix rigid langevin period must be > 0.0");
+      if (seed <= 0) error->all(FLERR,"Illegal fix rigid command");
+      iarg += 5;
+
+    } else if (strcmp(arg[iarg],"temp") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/nvt") != 0 && strcmp(style,"rigid/npt") != 0 &&
+          strcmp(style,"rigid/nvt/omp") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      tstat_flag = 1;
+      t_start = force->numeric(FLERR,arg[iarg+1]);
+      t_stop = force->numeric(FLERR,arg[iarg+2]);
+      t_period = force->numeric(FLERR,arg[iarg+3]);
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"iso") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/npt") != 0 && strcmp(style,"rigid/nph") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0 &&
+          strcmp(style,"rigid/nph/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      pcouple = XYZ;
+      p_start[0] = p_start[1] = p_start[2] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[0] = p_stop[1] = p_stop[2] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[0] = p_period[1] = p_period[2] =
+        force->numeric(FLERR,arg[iarg+3]);
+      p_flag[0] = p_flag[1] = p_flag[2] = 1;
+      if (dimension == 2) {
+	      p_start[2] = p_stop[2] = p_period[2] = 0.0;
+      	p_flag[2] = 0;
+      }
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"aniso") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/npt") != 0 && strcmp(style,"rigid/nph") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0 &&
+          strcmp(style,"rigid/nph/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      p_start[0] = p_start[1] = p_start[2] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[0] = p_stop[1] = p_stop[2] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[0] = p_period[1] = p_period[2] =
+        force->numeric(FLERR,arg[iarg+3]);
+      p_flag[0] = p_flag[1] = p_flag[2] = 1;
+      if (dimension == 2) {
+      	p_start[2] = p_stop[2] = p_period[2] = 0.0;
+	      p_flag[2] = 0;
+      }
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"x") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/npt") != 0 && strcmp(style,"rigid/nph") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0 &&
+          strcmp(style,"rigid/nph/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      p_start[0] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[0] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[0] = force->numeric(FLERR,arg[iarg+3]);
+      p_flag[0] = 1;
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"y") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/npt") != 0 && strcmp(style,"rigid/nph") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0 &&
+          strcmp(style,"rigid/nph/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      p_start[1] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[1] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[1] = force->numeric(FLERR,arg[iarg+3]);
+      p_flag[1] = 1;
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"z") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/npt") != 0 && strcmp(style,"rigid/nph") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0 &&
+          strcmp(style,"rigid/nph/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      p_start[2] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[2] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[2] = force->numeric(FLERR,arg[iarg+3]);
+      p_flag[2] = 1;
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"couple") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(arg[iarg+1],"xyz") == 0) pcouple = XYZ;
+      else if (strcmp(arg[iarg+1],"xy") == 0) pcouple = XY;
+      else if (strcmp(arg[iarg+1],"yz") == 0) pcouple = YZ;
+      else if (strcmp(arg[iarg+1],"xz") == 0) pcouple = XZ;
+      else if (strcmp(arg[iarg+1],"none") == 0) pcouple = NONE;
+      else error->all(FLERR,"Illegal fix rigid command");
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"dilate") == 0) {
+      if (iarg+2 > narg)
+        error->all(FLERR,"Illegal fix rigid npt/nph command");
+      if (strcmp(arg[iarg+1],"all") == 0) allremap = 1;
+      else {
+        allremap = 0;
+        delete [] id_dilate;
+        int n = strlen(arg[iarg+1]) + 1;
+        id_dilate = new char[n];
+        strcpy(id_dilate,arg[iarg+1]);
+        int idilate = group->find(id_dilate);
+        if (idilate == -1)
+          error->all(FLERR,
+                     "Fix rigid npt/nph dilate group ID does not exist");
+      }
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"tparam") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/nvt") != 0 && strcmp(style,"rigid/npt") != 0 &&
+          strcmp(style,"rigid/nvt/omp") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      t_chain = force->inumeric(FLERR,arg[iarg+1]);
+      t_iter = force->inumeric(FLERR,arg[iarg+2]);
+      t_order = force->inumeric(FLERR,arg[iarg+3]);
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"pchain") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid command");
+      if (strcmp(style,"rigid/npt") != 0 && strcmp(style,"rigid/nph") != 0 &&
+          strcmp(style,"rigid/npt/omp") != 0 &&
+          strcmp(style,"rigid/nph/omp") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      p_chain = force->inumeric(FLERR,arg[iarg+1]);
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"infile") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid command");
+      delete [] infile;
+      int n = strlen(arg[iarg+1]) + 1;
+      infile = new char[n];
+      strcpy(infile,arg[iarg+1]);
+      restart_file = 1;
+      reinitflag = 0;
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"reinit") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp("yes",arg[iarg+1]) == 0) reinitflag = 1;
+      else if  (strcmp("no",arg[iarg+1]) == 0) reinitflag = 0;
+      else error->all(FLERR,"Illegal fix rigid command");
+      iarg += 2;
+
+    } else error->all(FLERR,"Illegal fix rigid command");
+  }
+
+  // set pstat_flag
+
+  pstat_flag = 0;
+  for (int i = 0; i < 3; i++)
+    if (p_flag[i]) pstat_flag = 1;
+
+  if (pcouple == XYZ || (dimension == 2 && pcouple == XY)) pstyle = ISO;
+  else pstyle = ANISO;
+
+  // initialize Marsaglia RNG with processor-unique seed
+
+  if (langflag) random = new RanMars(lmp,seed + me);
+  else random = NULL;
+
+  // initialize vector output quantities in case accessed before run
+
+  for (i = 0; i < nbody; i++) {
+    xcm[i][0] = xcm[i][1] = xcm[i][2] = 0.0;
+    vcm[i][0] = vcm[i][1] = vcm[i][2] = 0.0;
+    fcm[i][0] = fcm[i][1] = fcm[i][2] = 0.0;
+    torque[i][0] = torque[i][1] = torque[i][2] = 0.0;
+  }
+
+  // nrigid[n] = # of atoms in Nth rigid body
+  // error if one or zero atoms
+
+  int *ncount = new int[nbody];
+  for (ibody = 0; ibody < nbody; ibody++) ncount[ibody] = 0;
+
+  int nlocal = atom->nlocal;
+
+  for (i = 0; i < nlocal; i++)
+    if (body[i] >= 0) ncount[body[i]]++;
+
+  MPI_Allreduce(ncount,nrigid,nbody,MPI_INT,MPI_SUM,world);
+  delete [] ncount;
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    if (nrigid[ibody] <= 1) error->all(FLERR,"One or zero atoms in rigid body");
+
+  // bitmasks for properties of extended particles
+
+  POINT = 1;
+  SPHERE = 2;
+  ELLIPSOID = 4;
+  LINE = 8;
+  TRIANGLE = 16;
+  DIPOLE = 32;
+  OMEGA = 64;
+  ANGMOM = 128;
+  TORQUE = 256;
+
+  MINUSPI = -MY_PI;
+  TWOPI = 2.0*MY_PI;
+
+  // wait to setup bodies until first init() using current atom properties
+
+  setupflag = 0;
+
+  // print statistics
+
+  int nsum = 0;
+  for (ibody = 0; ibody < nbody; ibody++) nsum += nrigid[ibody];
+
+  if (me == 0) {
+    if (screen) fprintf(screen,"%d rigid bodies with %d atoms\n",nbody,nsum);
+    if (logfile) fprintf(logfile,"%d rigid bodies with %d atoms\n",nbody,nsum);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixRigid::~FixRigid()
+{
+  // unregister callbacks to this fix from Atom class
+
+  atom->delete_callback(id,0);
+
+  delete random;
+  delete [] infile;
+  memory->destroy(mol2body);
+  memory->destroy(body2mol);
+
+  // delete locally stored per-atom arrays
+
+  memory->destroy(body);
+  memory->destroy(xcmimage);
+  memory->destroy(displace);
+  memory->destroy(eflags);
+  memory->destroy(orient);
+  memory->destroy(dorient);
+
+  // delete nbody-length arrays
+
+  memory->destroy(nrigid);
+  memory->destroy(masstotal);
+  memory->destroy(xcm);
+  memory->destroy(vcm);
+  memory->destroy(fcm);
+  memory->destroy(inertia);
+  memory->destroy(ex_space);
+  memory->destroy(ey_space);
+  memory->destroy(ez_space);
+  memory->destroy(angmom);
+  memory->destroy(omega);
+  memory->destroy(torque);
+  memory->destroy(quat);
+  memory->destroy(imagebody);
+  memory->destroy(fflag);
+  memory->destroy(tflag);
+  memory->destroy(langextra);
+
+  memory->destroy(sum);
+  memory->destroy(all);
+  memory->destroy(remapflag);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRigid::setmask()
+{
+  int mask = 0;
+  mask |= INITIAL_INTEGRATE;
+  mask |= FINAL_INTEGRATE;
+  if (langflag) mask |= POST_FORCE;
+  mask |= PRE_NEIGHBOR;
+  mask |= INITIAL_INTEGRATE_RESPA;
+  mask |= FINAL_INTEGRATE_RESPA;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigid::init()
+{
+  int i,ibody;
+
+  triclinic = domain->triclinic;
+
+  // atom style pointers to particles that store extra info
+
+  avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
+  avec_line = (AtomVecLine *) atom->style_match("line");
+  avec_tri = (AtomVecTri *) atom->style_match("tri");
+
+  // warn if more than one rigid fix
+
+  int count = 0;
+  for (i = 0; i < modify->nfix; i++)
+    if (strcmp(modify->fix[i]->style,"rigid") == 0) count++;
+  if (count > 1 && me == 0) error->warning(FLERR,"More than one fix rigid");
+
+  // error if npt,nph fix comes before rigid fix
+
+  for (i = 0; i < modify->nfix; i++) {
+    if (strcmp(modify->fix[i]->style,"npt") == 0) break;
+    if (strcmp(modify->fix[i]->style,"nph") == 0) break;
+  }
+  if (i < modify->nfix) {
+    for (int j = i; j < modify->nfix; j++)
+      if (strcmp(modify->fix[j]->style,"rigid") == 0)
+        error->all(FLERR,"Rigid fix must come before NPT/NPH fix");
+  }
+
+  // timestep info
+
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+  dtq = 0.5 * update->dt;
+
+  if (strstr(update->integrate_style,"respa"))
+    step_respa = ((Respa *) update->integrate)->step;
+
+  // setup rigid bodies, using current atom info. if reinitflag is not set,
+  // do the initialization only once, b/c properties may not be re-computable
+  // especially if overlapping particles.
+  //   do not do dynamic init if read body properties from infile.
+  // this is b/c the infile defines the static and dynamic properties and may
+  // not be computable if contain overlapping particles.
+  //   setup_bodies_static() reads infile itself
+
+  if (reinitflag || !setupflag) {
+    setup_bodies_static();
+    if (!infile) setup_bodies_dynamic();
+    setupflag = 1;
+  }
+
+  // temperature scale factor
+
+  double ndof = 0.0;
+  for (ibody = 0; ibody < nbody; ibody++) {
+    ndof += fflag[ibody][0] + fflag[ibody][1] + fflag[ibody][2];
+    ndof += tflag[ibody][0] + tflag[ibody][1] + tflag[ibody][2];
+  }
+  ndof -= nlinear;
+  if (ndof > 0.0) tfactor = force->mvv2e / (ndof * force->boltz);
+  else tfactor = 0.0;
+}
+
+/* ----------------------------------------------------------------------
+   invoke pre_neighbor() to insure body xcmimage flags are reset
+     needed if Verlet::setup::pbc() has remapped/migrated atoms for 2nd run
+------------------------------------------------------------------------- */
+
+void FixRigid::setup_pre_neighbor()
+{
+  pre_neighbor();
+}
+
+/* ----------------------------------------------------------------------
+   compute initial fcm and torque on bodies, also initial virial
+   reset all particle velocities to be consistent with vcm and omega
+------------------------------------------------------------------------- */
+
+void FixRigid::setup(int vflag)
+{
+  int i,n,ibody;
+
+  // fcm = force on center-of-mass of each rigid body
+
+  double **f = atom->f;
+  int nlocal = atom->nlocal;
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+    sum[ibody][0] += f[i][0];
+    sum[ibody][1] += f[i][1];
+    sum[ibody][2] += f[i][2];
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    fcm[ibody][0] = all[ibody][0];
+    fcm[ibody][1] = all[ibody][1];
+    fcm[ibody][2] = all[ibody][2];
+  }
+
+  // torque = torque on each rigid body
+
+  double **x = atom->x;
+
+  double dx,dy,dz;
+  double unwrap[3];
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    dx = unwrap[0] - xcm[ibody][0];
+    dy = unwrap[1] - xcm[ibody][1];
+    dz = unwrap[2] - xcm[ibody][2];
+
+    sum[ibody][0] += dy * f[i][2] - dz * f[i][1];
+    sum[ibody][1] += dz * f[i][0] - dx * f[i][2];
+    sum[ibody][2] += dx * f[i][1] - dy * f[i][0];
+  }
+
+  // extended particles add their torque to torque of body
+
+  if (extended) {
+    double **torque_one = atom->torque;
+
+    for (i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      ibody = body[i];
+      if (eflags[i] & TORQUE) {
+        sum[ibody][0] += torque_one[i][0];
+        sum[ibody][1] += torque_one[i][1];
+        sum[ibody][2] += torque_one[i][2];
+      }
+    }
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    torque[ibody][0] = all[ibody][0];
+    torque[ibody][1] = all[ibody][1];
+    torque[ibody][2] = all[ibody][2];
+  }
+
+  // zero langextra in case Langevin thermostat not used
+  // no point to calling post_force() here since langextra
+  // is only added to fcm/torque in final_integrate()
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) langextra[ibody][i] = 0.0;
+
+  // virial setup before call to set_v
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // set velocities from angmom & omega
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    MathExtra::angmom_to_omega(angmom[ibody],ex_space[ibody],ey_space[ibody],
+                               ez_space[ibody],inertia[ibody],omega[ibody]);
+
+  set_v();
+
+  // guesstimate virial as 2x the set_v contribution
+
+  if (vflag_global)
+    for (n = 0; n < 6; n++) virial[n] *= 2.0;
+  if (vflag_atom) {
+    for (i = 0; i < nlocal; i++)
+      for (n = 0; n < 6; n++)
+        vatom[i][n] *= 2.0;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigid::initial_integrate(int vflag)
+{
+  double dtfm;
+
+  for (int ibody = 0; ibody < nbody; ibody++) {
+
+    // update vcm by 1/2 step
+
+    dtfm = dtf / masstotal[ibody];
+    vcm[ibody][0] += dtfm * fcm[ibody][0] * fflag[ibody][0];
+    vcm[ibody][1] += dtfm * fcm[ibody][1] * fflag[ibody][1];
+    vcm[ibody][2] += dtfm * fcm[ibody][2] * fflag[ibody][2];
+
+    // update xcm by full step
+
+    xcm[ibody][0] += dtv * vcm[ibody][0];
+    xcm[ibody][1] += dtv * vcm[ibody][1];
+    xcm[ibody][2] += dtv * vcm[ibody][2];
+
+    // update angular momentum by 1/2 step
+
+    angmom[ibody][0] += dtf * torque[ibody][0] * tflag[ibody][0];
+    angmom[ibody][1] += dtf * torque[ibody][1] * tflag[ibody][1];
+    angmom[ibody][2] += dtf * torque[ibody][2] * tflag[ibody][2];
+
+    // compute omega at 1/2 step from angmom at 1/2 step and current q
+    // update quaternion a full step via Richardson iteration
+    // returns new normalized quaternion, also updated omega at 1/2 step
+    // update ex,ey,ez to reflect new quaternion
+
+    MathExtra::angmom_to_omega(angmom[ibody],ex_space[ibody],ey_space[ibody],
+                               ez_space[ibody],inertia[ibody],omega[ibody]);
+    MathExtra::richardson(quat[ibody],angmom[ibody],omega[ibody],
+                          inertia[ibody],dtq);
+    MathExtra::q_to_exyz(quat[ibody],
+                         ex_space[ibody],ey_space[ibody],ez_space[ibody]);
+  }
+
+  // virial setup before call to set_xv
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // set coords/orient and velocity/rotation of atoms in rigid bodies
+  // from quarternion and omega
+
+  set_xv();
+}
+
+/* ----------------------------------------------------------------------
+   apply Langevin thermostat to all 6 DOF of rigid bodies
+   computed by proc 0, broadcast to other procs
+   unlike fix langevin, this stores extra force in extra arrays,
+     which are added in when final_integrate() calculates a new fcm/torque
+------------------------------------------------------------------------- */
+
+void FixRigid::post_force(int vflag)
+{
+  if (me == 0) {
+    double gamma1,gamma2;
+
+    double delta = update->ntimestep - update->beginstep;
+    if (delta != 0.0) delta /= update->endstep - update->beginstep;
+    t_target = t_start + delta * (t_stop-t_start);
+    double tsqrt = sqrt(t_target);
+
+    double boltz = force->boltz;
+    double dt = update->dt;
+    double mvv2e = force->mvv2e;
+    double ftm2v = force->ftm2v;
+
+    for (int i = 0; i < nbody; i++) {
+      gamma1 = -masstotal[i] / t_period / ftm2v;
+      gamma2 = sqrt(masstotal[i]) * tsqrt *
+        sqrt(24.0*boltz/t_period/dt/mvv2e) / ftm2v;
+      langextra[i][0] = gamma1*vcm[i][0] + gamma2*(random->uniform()-0.5);
+      langextra[i][1] = gamma1*vcm[i][1] + gamma2*(random->uniform()-0.5);
+      langextra[i][2] = gamma1*vcm[i][2] + gamma2*(random->uniform()-0.5);
+      
+      gamma1 = -1.0 / t_period / ftm2v;
+      gamma2 = tsqrt * sqrt(24.0*boltz/t_period/dt/mvv2e) / ftm2v;
+      langextra[i][3] = inertia[i][0]*gamma1*omega[i][0] +
+        sqrt(inertia[i][0])*gamma2*(random->uniform()-0.5);
+      langextra[i][4] = inertia[i][1]*gamma1*omega[i][1] +
+        sqrt(inertia[i][1])*gamma2*(random->uniform()-0.5);
+      langextra[i][5] = inertia[i][2]*gamma1*omega[i][2] +
+        sqrt(inertia[i][2])*gamma2*(random->uniform()-0.5);
+    }
+  }
+
+  MPI_Bcast(&langextra[0][0],6*nbody,MPI_DOUBLE,0,world);
+}
+
+/* ----------------------------------------------------------------------
+   called from FixEnforce2d post_force() for 2d problems
+   zero all body values that should be zero for 2d model
+------------------------------------------------------------------------- */
+
+void FixRigid::enforce2d()
+{
+  for (int ibody = 0; ibody < nbody; ibody++) {
+    xcm[ibody][2] = 0.0;
+    vcm[ibody][2] = 0.0;
+    fcm[ibody][2] = 0.0;
+    torque[ibody][0] = 0.0;
+    torque[ibody][1] = 0.0;
+    angmom[ibody][0] = 0.0;
+    angmom[ibody][1] = 0.0;
+    omega[ibody][0] = 0.0;
+    omega[ibody][1] = 0.0;
+    if (langflag && langextra) {
+      langextra[ibody][2] = 0.0;
+      langextra[ibody][3] = 0.0;
+      langextra[ibody][4] = 0.0;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigid::final_integrate()
+{
+  int i,ibody;
+  double dtfm;
+
+  // sum over atoms to get force and torque on rigid body
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int nlocal = atom->nlocal;
+
+  double dx,dy,dz;
+  double unwrap[3];
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    sum[ibody][0] += f[i][0];
+    sum[ibody][1] += f[i][1];
+    sum[ibody][2] += f[i][2];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    dx = unwrap[0] - xcm[ibody][0];
+    dy = unwrap[1] - xcm[ibody][1];
+    dz = unwrap[2] - xcm[ibody][2];
+
+    sum[ibody][3] += dy*f[i][2] - dz*f[i][1];
+    sum[ibody][4] += dz*f[i][0] - dx*f[i][2];
+    sum[ibody][5] += dx*f[i][1] - dy*f[i][0];
+  }
+
+  // extended particles add their torque to torque of body
+
+  if (extended) {
+    double **torque_one = atom->torque;
+
+    for (i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      ibody = body[i];
+
+      if (eflags[i] & TORQUE) {
+        sum[ibody][3] += torque_one[i][0];
+        sum[ibody][4] += torque_one[i][1];
+        sum[ibody][5] += torque_one[i][2];
+      }
+    }
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  // update vcm and angmom
+  // include Langevin thermostat forces
+  // fflag,tflag = 0 for some dimensions in 2d
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    fcm[ibody][0] = all[ibody][0] + langextra[ibody][0];
+    fcm[ibody][1] = all[ibody][1] + langextra[ibody][1];
+    fcm[ibody][2] = all[ibody][2] + langextra[ibody][2];
+    torque[ibody][0] = all[ibody][3] + langextra[ibody][3];
+    torque[ibody][1] = all[ibody][4] + langextra[ibody][4];
+    torque[ibody][2] = all[ibody][5] + langextra[ibody][5];
+
+    // update vcm by 1/2 step
+
+    dtfm = dtf / masstotal[ibody];
+    vcm[ibody][0] += dtfm * fcm[ibody][0] * fflag[ibody][0];
+    vcm[ibody][1] += dtfm * fcm[ibody][1] * fflag[ibody][1];
+    vcm[ibody][2] += dtfm * fcm[ibody][2] * fflag[ibody][2];
+
+    // update angular momentum by 1/2 step
+
+    angmom[ibody][0] += dtf * torque[ibody][0] * tflag[ibody][0];
+    angmom[ibody][1] += dtf * torque[ibody][1] * tflag[ibody][1];
+    angmom[ibody][2] += dtf * torque[ibody][2] * tflag[ibody][2];
+
+    MathExtra::angmom_to_omega(angmom[ibody],ex_space[ibody],ey_space[ibody],
+                               ez_space[ibody],inertia[ibody],omega[ibody]);
+  }
+
+  // set velocity/rotation of atoms in rigid bodies
+  // virial is already setup from initial_integrate
+
+  set_v();
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigid::initial_integrate_respa(int vflag, int ilevel, int iloop)
+{
+  dtv = step_respa[ilevel];
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+  dtq = 0.5 * step_respa[ilevel];
+
+  if (ilevel == 0) initial_integrate(vflag);
+  else final_integrate();
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigid::final_integrate_respa(int ilevel, int iloop)
+{
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+  final_integrate();
+}
+
+/* ----------------------------------------------------------------------
+   remap xcm of each rigid body back into periodic simulation box
+   done during pre_neighbor so will be after call to pbc()
+     and after fix_deform::pre_exchange() may have flipped box
+   use domain->remap() in case xcm is far away from box
+     due to first-time definition of rigid body in setup_bodies_static()
+     or due to box flip
+   also adjust imagebody = rigid body image flags, due to xcm remap
+   also reset body xcmimage flags of all atoms in bodies
+   xcmimage flags are relative to xcm so that body can be unwrapped
+   if don't do this, would need xcm to move with true image flags
+     then a body could end up very far away from box
+     set_xv() will then compute huge displacements every step to
+       reset coords of all body atoms to be back inside the box,
+       ditto for triclinic box flip, which causes numeric problems
+------------------------------------------------------------------------- */
+
+void FixRigid::pre_neighbor()
+{
+  for (int ibody = 0; ibody < nbody; ibody++)
+    domain->remap(xcm[ibody],imagebody[ibody]);
+  image_shift();
+}
+
+/* ----------------------------------------------------------------------
+   reset body xcmimage flags of atoms in bodies
+   xcmimage flags are relative to xcm so that body can be unwrapped
+   xcmimage = true image flag - imagebody flag
+------------------------------------------------------------------------- */
+
+void FixRigid::image_shift()
+{
+  int ibody;
+  imageint tdim,bdim,xdim[3];
+
+  imageint *image = atom->image;
+  int nlocal = atom->nlocal;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    tdim = image[i] & IMGMASK;
+    bdim = imagebody[ibody] & IMGMASK;
+    xdim[0] = IMGMAX + tdim - bdim;
+    tdim = (image[i] >> IMGBITS) & IMGMASK;
+    bdim = (imagebody[ibody] >> IMGBITS) & IMGMASK;
+    xdim[1] = IMGMAX + tdim - bdim;
+    tdim = image[i] >> IMG2BITS;
+    bdim = imagebody[ibody] >> IMG2BITS;
+    xdim[2] = IMGMAX + tdim - bdim;
+
+    xcmimage[i] = (xdim[2] << IMG2BITS) | (xdim[1] << IMGBITS) | xdim[0];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   count # of DOF removed by rigid bodies for atoms in igroup
+   return total count of DOF
+------------------------------------------------------------------------- */
+
+int FixRigid::dof(int tgroup)
+{
+  // cannot count DOF correctly unless setup_bodies_static() has been called
+
+  if (!setupflag) {
+    if (comm->me == 0)
+      error->warning(FLERR,"Cannot count rigid body degrees-of-freedom "
+                     "before bodies are initialized");
+    return 0;
+  }
+
+  int tgroupbit = group->bitmask[tgroup];
+
+  // nall = # of point particles in each rigid body
+  // mall = # of finite-size particles in each rigid body
+  // particles must also be in temperature group
+
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  int *ncount = new int[nbody];
+  int *mcount = new int[nbody];
+  for (int ibody = 0; ibody < nbody; ibody++)
+    ncount[ibody] = mcount[ibody] = 0;
+
+  for (int i = 0; i < nlocal; i++)
+    if (body[i] >= 0 && mask[i] & tgroupbit) {
+      // do not count point particles or point dipoles as extended particles
+      // a spheroid dipole will be counted as extended
+      if (extended && (eflags[i] & ~(POINT | DIPOLE))) mcount[body[i]]++;
+      else ncount[body[i]]++;
+    }
+
+  int *nall = new int[nbody];
+  int *mall = new int[nbody];
+  MPI_Allreduce(ncount,nall,nbody,MPI_INT,MPI_SUM,world);
+  MPI_Allreduce(mcount,mall,nbody,MPI_INT,MPI_SUM,world);
+
+  // warn if nall+mall != nrigid for any body included in temperature group
+
+  int flag = 0;
+  for (int ibody = 0; ibody < nbody; ibody++) {
+    if (nall[ibody]+mall[ibody] > 0 &&
+        nall[ibody]+mall[ibody] != nrigid[ibody]) flag = 1;
+  }
+  if (flag && me == 0)
+    error->warning(FLERR,"Computing temperature of portions of rigid bodies");
+
+  // remove appropriate DOFs for each rigid body wholly in temperature group
+  // N = # of point particles in body
+  // M = # of finite-size particles in body
+  // 3d body has 3N + 6M dof to start with
+  // 2d body has 2N + 3M dof to start with
+  // 3d point-particle body with all non-zero I should have 6 dof, remove 3N-6
+  // 3d point-particle body (linear) with a 0 I should have 5 dof, remove 3N-5
+  // 2d point-particle body should have 3 dof, remove 2N-3
+  // 3d body with any finite-size M should have 6 dof, remove (3N+6M) - 6
+  // 2d body with any finite-size M should have 3 dof, remove (2N+3M) - 3
+
+  int n = 0;
+  nlinear = 0;
+  if (domain->dimension == 3) {
+    for (int ibody = 0; ibody < nbody; ibody++)
+      if (nall[ibody]+mall[ibody] == nrigid[ibody]) {
+        n += 3*nall[ibody] + 6*mall[ibody] - 6;
+        if (inertia[ibody][0] == 0.0 || inertia[ibody][1] == 0.0 ||
+            inertia[ibody][2] == 0.0) {
+          n++;
+          nlinear++;
+        }
+      }
+  } else if (domain->dimension == 2) {
+    for (int ibody = 0; ibody < nbody; ibody++)
+      if (nall[ibody]+mall[ibody] == nrigid[ibody])
+        n += 2*nall[ibody] + 3*mall[ibody] - 3;
+  }
+
+  delete [] ncount;
+  delete [] mcount;
+  delete [] nall;
+  delete [] mall;
+
+  return n;
+}
+
+/* ----------------------------------------------------------------------
+   adjust xcm of each rigid body due to box deformation
+   called by various fixes that change box size/shape
+   flag = 0/1 means map from box to lamda coords or vice versa
+------------------------------------------------------------------------- */
+
+void FixRigid::deform(int flag)
+{
+  if (flag == 0)
+    for (int ibody = 0; ibody < nbody; ibody++)
+      domain->x2lamda(xcm[ibody],xcm[ibody]);
+  else
+    for (int ibody = 0; ibody < nbody; ibody++)
+      domain->lamda2x(xcm[ibody],xcm[ibody]);
+}
+
+/* ----------------------------------------------------------------------
+   set space-frame coords and velocity of each atom in each rigid body
+   set orientation and rotation of extended particles
+   x = Q displace + Xcm, mapped back to periodic box
+   v = Vcm + (W cross (x - Xcm))
+------------------------------------------------------------------------- */
+
+void FixRigid::set_xv()
+{
+  int ibody;
+  int xbox,ybox,zbox;
+  double x0,x1,x2,v0,v1,v2,fc0,fc1,fc2,massone;
+  double xy,xz,yz;
+  double ione[3],exone[3],eyone[3],ezone[3],vr[6],p[3][3];
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+
+  if (triclinic) {
+    xy = domain->xy;
+    xz = domain->xz;
+    yz = domain->yz;
+  }
+
+  // set x and v of each atom
+
+  for (int i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+    // save old positions and velocities for virial
+
+    if (evflag) {
+      if (triclinic == 0) {
+        x0 = x[i][0] + xbox*xprd;
+        x1 = x[i][1] + ybox*yprd;
+        x2 = x[i][2] + zbox*zprd;
+      } else {
+        x0 = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+        x1 = x[i][1] + ybox*yprd + zbox*yz;
+        x2 = x[i][2] + zbox*zprd;
+      }
+      v0 = v[i][0];
+      v1 = v[i][1];
+      v2 = v[i][2];
+    }
+
+    // x = displacement from center-of-mass, based on body orientation
+    // v = vcm + omega around center-of-mass
+
+    MathExtra::matvec(ex_space[ibody],ey_space[ibody],
+                      ez_space[ibody],displace[i],x[i]);
+
+    v[i][0] = omega[ibody][1]*x[i][2] - omega[ibody][2]*x[i][1] +
+      vcm[ibody][0];
+    v[i][1] = omega[ibody][2]*x[i][0] - omega[ibody][0]*x[i][2] +
+      vcm[ibody][1];
+    v[i][2] = omega[ibody][0]*x[i][1] - omega[ibody][1]*x[i][0] +
+      vcm[ibody][2];
+
+    // add center of mass to displacement
+    // map back into periodic box via xbox,ybox,zbox
+    // for triclinic, add in box tilt factors as well
+
+    if (triclinic == 0) {
+      x[i][0] += xcm[ibody][0] - xbox*xprd;
+      x[i][1] += xcm[ibody][1] - ybox*yprd;
+      x[i][2] += xcm[ibody][2] - zbox*zprd;
+    } else {
+      x[i][0] += xcm[ibody][0] - xbox*xprd - ybox*xy - zbox*xz;
+      x[i][1] += xcm[ibody][1] - ybox*yprd - zbox*yz;
+      x[i][2] += xcm[ibody][2] - zbox*zprd;
+    }
+
+    // virial = unwrapped coords dotted into body constraint force
+    // body constraint force = implied force due to v change minus f external
+    // assume f does not include forces internal to body
+    // 1/2 factor b/c final_integrate contributes other half
+    // assume per-atom contribution is due to constraint force on that atom
+
+    if (evflag) {
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+      fc0 = massone*(v[i][0] - v0)/dtf - f[i][0];
+      fc1 = massone*(v[i][1] - v1)/dtf - f[i][1];
+      fc2 = massone*(v[i][2] - v2)/dtf - f[i][2];
+
+      vr[0] = 0.5*x0*fc0;
+      vr[1] = 0.5*x1*fc1;
+      vr[2] = 0.5*x2*fc2;
+      vr[3] = 0.5*x0*fc1;
+      vr[4] = 0.5*x0*fc2;
+      vr[5] = 0.5*x1*fc2;
+
+      v_tally(1,&i,1.0,vr);
+    }
+  }
+
+  // set orientation, omega, angmom of each extended particle
+
+  if (extended) {
+    double theta_body,theta;
+    double *shape,*quatatom,*inertiaatom;
+
+    AtomVecEllipsoid::Bonus *ebonus;
+    if (avec_ellipsoid) ebonus = avec_ellipsoid->bonus;
+    AtomVecLine::Bonus *lbonus;
+    if (avec_line) lbonus = avec_line->bonus;
+    AtomVecTri::Bonus *tbonus;
+    if (avec_tri) tbonus = avec_tri->bonus;
+    double **omega_one = atom->omega;
+    double **angmom_one = atom->angmom;
+    double **mu = atom->mu;
+    int *ellipsoid = atom->ellipsoid;
+    int *line = atom->line;
+    int *tri = atom->tri;
+
+    for (int i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      ibody = body[i];
+
+      if (eflags[i] & SPHERE) {
+        omega_one[i][0] = omega[ibody][0];
+        omega_one[i][1] = omega[ibody][1];
+        omega_one[i][2] = omega[ibody][2];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        quatatom = ebonus[ellipsoid[i]].quat;
+        MathExtra::quatquat(quat[ibody],orient[i],quatatom);
+        MathExtra::qnormalize(quatatom);
+        ione[0] = EINERTIA*rmass[i] * (shape[1]*shape[1] + shape[2]*shape[2]);
+        ione[1] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[2]*shape[2]);
+        ione[2] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[1]*shape[1]);
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(omega[ibody],exone,eyone,ezone,ione,
+                                   angmom_one[i]);
+      } else if (eflags[i] & LINE) {
+        if (quat[ibody][3] >= 0.0) theta_body = 2.0*acos(quat[ibody][0]);
+        else theta_body = -2.0*acos(quat[ibody][0]);
+        theta = orient[i][0] + theta_body;
+        while (theta <= MINUSPI) theta += TWOPI;
+        while (theta > MY_PI) theta -= TWOPI;
+        lbonus[line[i]].theta = theta;
+        omega_one[i][0] = omega[ibody][0];
+        omega_one[i][1] = omega[ibody][1];
+        omega_one[i][2] = omega[ibody][2];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::quatquat(quat[ibody],orient[i],quatatom);
+        MathExtra::qnormalize(quatatom);
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(omega[ibody],exone,eyone,ezone,
+                                   inertiaatom,angmom_one[i]);
+      }
+      if (eflags[i] & DIPOLE) {
+        MathExtra::quat_to_mat(quat[ibody],p);
+        MathExtra::matvec(p,dorient[i],mu[i]);
+        MathExtra::snormalize3(mu[i][3],mu[i],mu[i]);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   set space-frame velocity of each atom in a rigid body
+   set omega and angmom of extended particles
+   v = Vcm + (W cross (x - Xcm))
+------------------------------------------------------------------------- */
+
+void FixRigid::set_v()
+{
+  int xbox,ybox,zbox;
+  double x0,x1,x2,v0,v1,v2,fc0,fc1,fc2,massone;
+  double xy,xz,yz;
+  double ione[3],exone[3],eyone[3],ezone[3],delta[3],vr[6];
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+  if (triclinic) {
+    xy = domain->xy;
+    xz = domain->xz;
+    yz = domain->yz;
+  }
+
+  // set v of each atom
+
+  for (int i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    const int ibody = body[i];
+
+    MathExtra::matvec(ex_space[ibody],ey_space[ibody],
+                      ez_space[ibody],displace[i],delta);
+
+    // save old velocities for virial
+
+    if (evflag) {
+      v0 = v[i][0];
+      v1 = v[i][1];
+      v2 = v[i][2];
+    }
+
+    v[i][0] = omega[ibody][1]*delta[2] - omega[ibody][2]*delta[1] +
+      vcm[ibody][0];
+    v[i][1] = omega[ibody][2]*delta[0] - omega[ibody][0]*delta[2] +
+      vcm[ibody][1];
+    v[i][2] = omega[ibody][0]*delta[1] - omega[ibody][1]*delta[0] +
+      vcm[ibody][2];
+
+    // virial = unwrapped coords dotted into body constraint force
+    // body constraint force = implied force due to v change minus f external
+    // assume f does not include forces internal to body
+    // 1/2 factor b/c initial_integrate contributes other half
+    // assume per-atom contribution is due to constraint force on that atom
+
+    if (evflag) {
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+      fc0 = massone*(v[i][0] - v0)/dtf - f[i][0];
+      fc1 = massone*(v[i][1] - v1)/dtf - f[i][1];
+      fc2 = massone*(v[i][2] - v2)/dtf - f[i][2];
+
+      xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+      ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+      zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+      if (triclinic == 0) {
+        x0 = x[i][0] + xbox*xprd;
+        x1 = x[i][1] + ybox*yprd;
+        x2 = x[i][2] + zbox*zprd;
+      } else {
+        x0 = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+        x1 = x[i][1] + ybox*yprd + zbox*yz;
+        x2 = x[i][2] + zbox*zprd;
+      }
+
+      vr[0] = 0.5*x0*fc0;
+      vr[1] = 0.5*x1*fc1;
+      vr[2] = 0.5*x2*fc2;
+      vr[3] = 0.5*x0*fc1;
+      vr[4] = 0.5*x0*fc2;
+      vr[5] = 0.5*x1*fc2;
+
+      v_tally(1,&i,1.0,vr);
+    }
+  }
+
+  // set omega, angmom of each extended particle
+
+  if (extended) {
+    double *shape,*quatatom,*inertiaatom;
+
+    AtomVecEllipsoid::Bonus *ebonus;
+    if (avec_ellipsoid) ebonus = avec_ellipsoid->bonus;
+    AtomVecTri::Bonus *tbonus;
+    if (avec_tri) tbonus = avec_tri->bonus;
+    double **omega_one = atom->omega;
+    double **angmom_one = atom->angmom;
+    int *ellipsoid = atom->ellipsoid;
+    int *tri = atom->tri;
+
+    for (int i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      const int ibody = body[i];
+
+      if (eflags[i] & SPHERE) {
+        omega_one[i][0] = omega[ibody][0];
+        omega_one[i][1] = omega[ibody][1];
+        omega_one[i][2] = omega[ibody][2];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        quatatom = ebonus[ellipsoid[i]].quat;
+        ione[0] = EINERTIA*rmass[i] * (shape[1]*shape[1] + shape[2]*shape[2]);
+        ione[1] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[2]*shape[2]);
+        ione[2] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[1]*shape[1]);
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(omega[ibody],exone,eyone,ezone,ione,
+                                   angmom_one[i]);
+      } else if (eflags[i] & LINE) {
+        omega_one[i][0] = omega[ibody][0];
+        omega_one[i][1] = omega[ibody][1];
+        omega_one[i][2] = omega[ibody][2];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(omega[ibody],exone,eyone,ezone,
+                                   inertiaatom,angmom_one[i]);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   one-time initialization of static rigid body attributes
+   sets extended flags, masstotal, center-of-mass
+   sets Cartesian and diagonalized inertia tensor
+   sets body image flags
+   may read some properties from infile
+------------------------------------------------------------------------- */
+
+void FixRigid::setup_bodies_static()
+{
+  int i,ibody;
+
+  // extended = 1 if any particle in a rigid body is finite size
+  //              or has a dipole moment
+
+  extended = orientflag = dorientflag = 0;
+
+  AtomVecEllipsoid::Bonus *ebonus;
+  if (avec_ellipsoid) ebonus = avec_ellipsoid->bonus;
+  AtomVecLine::Bonus *lbonus;
+  if (avec_line) lbonus = avec_line->bonus;
+  AtomVecTri::Bonus *tbonus;
+  if (avec_tri) tbonus = avec_tri->bonus;
+  double **mu = atom->mu;
+  double *radius = atom->radius;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *ellipsoid = atom->ellipsoid;
+  int *line = atom->line;
+  int *tri = atom->tri;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  if (atom->radius_flag || atom->ellipsoid_flag || atom->line_flag ||
+      atom->tri_flag || atom->mu_flag) {
+    int flag = 0;
+    for (i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      if (radius && radius[i] > 0.0) flag = 1;
+      if (ellipsoid && ellipsoid[i] >= 0) flag = 1;
+      if (line && line[i] >= 0) flag = 1;
+      if (tri && tri[i] >= 0) flag = 1;
+      if (mu && mu[i][3] > 0.0) flag = 1;
+    }
+
+    MPI_Allreduce(&flag,&extended,1,MPI_INT,MPI_MAX,world);
+  }
+
+  // grow extended arrays and set extended flags for each particle
+  // orientflag = 4 if any particle stores ellipsoid or tri orientation
+  // orientflag = 1 if any particle stores line orientation
+  // dorientflag = 1 if any particle stores dipole orientation
+
+  if (extended) {
+    if (atom->ellipsoid_flag) orientflag = 4;
+    if (atom->line_flag) orientflag = 1;
+    if (atom->tri_flag) orientflag = 4;
+    if (atom->mu_flag) dorientflag = 1;
+    grow_arrays(atom->nmax);
+
+    for (i = 0; i < nlocal; i++) {
+      eflags[i] = 0;
+      if (body[i] < 0) continue;
+
+      // set to POINT or SPHERE or ELLIPSOID or LINE
+
+      if (radius && radius[i] > 0.0) {
+        eflags[i] |= SPHERE;
+        eflags[i] |= OMEGA;
+        eflags[i] |= TORQUE;
+      } else if (ellipsoid && ellipsoid[i] >= 0) {
+        eflags[i] |= ELLIPSOID;
+        eflags[i] |= ANGMOM;
+        eflags[i] |= TORQUE;
+      } else if (line && line[i] >= 0) {
+        eflags[i] |= LINE;
+        eflags[i] |= OMEGA;
+        eflags[i] |= TORQUE;
+      } else if (tri && tri[i] >= 0) {
+        eflags[i] |= TRIANGLE;
+        eflags[i] |= ANGMOM;
+        eflags[i] |= TORQUE;
+      } else eflags[i] |= POINT;
+
+      // set DIPOLE if atom->mu and mu[3] > 0.0
+
+      if (atom->mu_flag && mu[i][3] > 0.0)
+        eflags[i] |= DIPOLE;
+    }
+  }
+
+  // set body xcmimage flags = true image flags
+
+  imageint *image = atom->image;
+  for (i = 0; i < nlocal; i++)
+    if (body[i] >= 0) xcmimage[i] = image[i];
+    else xcmimage[i] = 0;
+
+  // compute masstotal & center-of-mass of each rigid body
+  // error if image flag is not 0 in a non-periodic dim
+
+  double **x = atom->x;
+
+  int *periodicity = domain->periodicity;
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+  double xy = domain->xy;
+  double xz = domain->xz;
+  double yz = domain->yz;
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+  int xbox,ybox,zbox;
+  double massone,xunwrap,yunwrap,zunwrap;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    if ((xbox && !periodicity[0]) || (ybox && !periodicity[1]) ||
+        (zbox && !periodicity[2]))
+      error->one(FLERR,"Fix rigid atom has non-zero image flag "
+                 "in a non-periodic dimension");
+
+    if (triclinic == 0) {
+      xunwrap = x[i][0] + xbox*xprd;
+      yunwrap = x[i][1] + ybox*yprd;
+      zunwrap = x[i][2] + zbox*zprd;
+    } else {
+      xunwrap = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+      yunwrap = x[i][1] + ybox*yprd + zbox*yz;
+      zunwrap = x[i][2] + zbox*zprd;
+    }
+
+    sum[ibody][0] += xunwrap * massone;
+    sum[ibody][1] += yunwrap * massone;
+    sum[ibody][2] += zunwrap * massone;
+    sum[ibody][3] += massone;
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    masstotal[ibody] = all[ibody][3];
+    xcm[ibody][0] = all[ibody][0]/masstotal[ibody];
+    xcm[ibody][1] = all[ibody][1]/masstotal[ibody];
+    xcm[ibody][2] = all[ibody][2]/masstotal[ibody];
+  }
+
+  // set vcm, angmom = 0.0 in case infile is used
+  // and doesn't overwrite all body's values
+  // since setup_bodies_dynamic() will not be called
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    vcm[ibody][0] = vcm[ibody][1] = vcm[ibody][2] = 0.0;
+    angmom[ibody][0] = angmom[ibody][1] = angmom[ibody][2] = 0.0;
+  }
+
+  // set rigid body image flags to default values
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    imagebody[ibody] = ((imageint) IMGMAX << IMG2BITS) |
+      ((imageint) IMGMAX << IMGBITS) | IMGMAX;
+
+  // overwrite masstotal, center-of-mass, image flags with file values
+  // inbody[i] = 0/1 if Ith rigid body is initialized by file
+
+  int *inbody;
+  if (infile) {
+    memory->create(inbody,nbody,"rigid:inbody");
+    for (ibody = 0; ibody < nbody; ibody++) inbody[ibody] = 0;
+    readfile(0,masstotal,xcm,vcm,angmom,imagebody,inbody);
+  }
+
+  // remap the xcm of each body back into simulation box
+  //   and reset body and atom xcmimage flags via pre_neighbor()
+
+  pre_neighbor();
+
+  // compute 6 moments of inertia of each body in Cartesian reference frame
+  // dx,dy,dz = coords relative to center-of-mass
+  // symmetric 3x3 inertia tensor stored in Voigt notation as 6-vector
+
+  double dx,dy,dz;
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+    if (triclinic == 0) {
+      xunwrap = x[i][0] + xbox*xprd;
+      yunwrap = x[i][1] + ybox*yprd;
+      zunwrap = x[i][2] + zbox*zprd;
+    } else {
+      xunwrap = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+      yunwrap = x[i][1] + ybox*yprd + zbox*yz;
+      zunwrap = x[i][2] + zbox*zprd;
+    }
+
+    dx = xunwrap - xcm[ibody][0];
+    dy = yunwrap - xcm[ibody][1];
+    dz = zunwrap - xcm[ibody][2];
+
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    sum[ibody][0] += massone * (dy*dy + dz*dz);
+    sum[ibody][1] += massone * (dx*dx + dz*dz);
+    sum[ibody][2] += massone * (dx*dx + dy*dy);
+    sum[ibody][3] -= massone * dy*dz;
+    sum[ibody][4] -= massone * dx*dz;
+    sum[ibody][5] -= massone * dx*dy;
+  }
+
+  // extended particles may contribute extra terms to moments of inertia
+
+  if (extended) {
+    double ivec[6];
+    double *shape,*quatatom,*inertiaatom;
+    double length,theta;
+
+    for (i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      ibody = body[i];
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+
+      if (eflags[i] & SPHERE) {
+        sum[ibody][0] += SINERTIA*massone * radius[i]*radius[i];
+        sum[ibody][1] += SINERTIA*massone * radius[i]*radius[i];
+        sum[ibody][2] += SINERTIA*massone * radius[i]*radius[i];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        quatatom = ebonus[ellipsoid[i]].quat;
+        MathExtra::inertia_ellipsoid(shape,quatatom,massone,ivec);
+        sum[ibody][0] += ivec[0];
+        sum[ibody][1] += ivec[1];
+        sum[ibody][2] += ivec[2];
+        sum[ibody][3] += ivec[3];
+        sum[ibody][4] += ivec[4];
+        sum[ibody][5] += ivec[5];
+      } else if (eflags[i] & LINE) {
+        length = lbonus[line[i]].length;
+        theta = lbonus[line[i]].theta;
+        MathExtra::inertia_line(length,theta,massone,ivec);
+        sum[ibody][0] += ivec[0];
+        sum[ibody][1] += ivec[1];
+        sum[ibody][2] += ivec[2];
+        sum[ibody][3] += ivec[3];
+        sum[ibody][4] += ivec[4];
+        sum[ibody][5] += ivec[5];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::inertia_triangle(inertiaatom,quatatom,massone,ivec);
+        sum[ibody][0] += ivec[0];
+        sum[ibody][1] += ivec[1];
+        sum[ibody][2] += ivec[2];
+        sum[ibody][3] += ivec[3];
+        sum[ibody][4] += ivec[4];
+        sum[ibody][5] += ivec[5];
+      }
+    }
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  // overwrite Cartesian inertia tensor with file values
+
+  if (infile) readfile(1,NULL,all,NULL,NULL,NULL,inbody);
+
+  // diagonalize inertia tensor for each body via Jacobi rotations
+  // inertia = 3 eigenvalues = principal moments of inertia
+  // evectors and exzy_space = 3 evectors = principal axes of rigid body
+
+  int ierror;
+  double cross[3];
+  double tensor[3][3],evectors[3][3];
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    tensor[0][0] = all[ibody][0];
+    tensor[1][1] = all[ibody][1];
+    tensor[2][2] = all[ibody][2];
+    tensor[1][2] = tensor[2][1] = all[ibody][3];
+    tensor[0][2] = tensor[2][0] = all[ibody][4];
+    tensor[0][1] = tensor[1][0] = all[ibody][5];
+
+    ierror = MathExtra::jacobi(tensor,inertia[ibody],evectors);
+    if (ierror) error->all(FLERR,
+                           "Insufficient Jacobi rotations for rigid body");
+
+    ex_space[ibody][0] = evectors[0][0];
+    ex_space[ibody][1] = evectors[1][0];
+    ex_space[ibody][2] = evectors[2][0];
+    ey_space[ibody][0] = evectors[0][1];
+    ey_space[ibody][1] = evectors[1][1];
+    ey_space[ibody][2] = evectors[2][1];
+    ez_space[ibody][0] = evectors[0][2];
+    ez_space[ibody][1] = evectors[1][2];
+    ez_space[ibody][2] = evectors[2][2];
+
+    // if any principal moment < scaled EPSILON, set to 0.0
+
+    double max;
+    max = MAX(inertia[ibody][0],inertia[ibody][1]);
+    max = MAX(max,inertia[ibody][2]);
+
+    if (inertia[ibody][0] < EPSILON*max) inertia[ibody][0] = 0.0;
+    if (inertia[ibody][1] < EPSILON*max) inertia[ibody][1] = 0.0;
+    if (inertia[ibody][2] < EPSILON*max) inertia[ibody][2] = 0.0;
+
+    // enforce 3 evectors as a right-handed coordinate system
+    // flip 3rd vector if needed
+
+    MathExtra::cross3(ex_space[ibody],ey_space[ibody],cross);
+    if (MathExtra::dot3(cross,ez_space[ibody]) < 0.0)
+      MathExtra::negate3(ez_space[ibody]);
+
+    // create initial quaternion
+
+    MathExtra::exyz_to_q(ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                         quat[ibody]);
+  }
+
+  // displace = initial atom coords in basis of principal axes
+  // set displace = 0.0 for atoms not in any rigid body
+  // for extended particles, set their orientation wrt to rigid body
+
+  double qc[4],delta[3];
+  double *quatatom;
+  double theta_body;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) {
+      displace[i][0] = displace[i][1] = displace[i][2] = 0.0;
+      continue;
+    }
+
+    ibody = body[i];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+    if (triclinic == 0) {
+      xunwrap = x[i][0] + xbox*xprd;
+      yunwrap = x[i][1] + ybox*yprd;
+      zunwrap = x[i][2] + zbox*zprd;
+    } else {
+      xunwrap = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+      yunwrap = x[i][1] + ybox*yprd + zbox*yz;
+      zunwrap = x[i][2] + zbox*zprd;
+    }
+
+    delta[0] = xunwrap - xcm[ibody][0];
+    delta[1] = yunwrap - xcm[ibody][1];
+    delta[2] = zunwrap - xcm[ibody][2];
+    MathExtra::transpose_matvec(ex_space[ibody],ey_space[ibody],
+                                ez_space[ibody],delta,displace[i]);
+
+    if (extended) {
+      if (eflags[i] & ELLIPSOID) {
+        quatatom = ebonus[ellipsoid[i]].quat;
+        MathExtra::qconjugate(quat[ibody],qc);
+        MathExtra::quatquat(qc,quatatom,orient[i]);
+        MathExtra::qnormalize(orient[i]);
+      } else if (eflags[i] & LINE) {
+        if (quat[ibody][3] >= 0.0) theta_body = 2.0*acos(quat[ibody][0]);
+        else theta_body = -2.0*acos(quat[ibody][0]);
+        orient[i][0] = lbonus[line[i]].theta - theta_body;
+        while (orient[i][0] <= MINUSPI) orient[i][0] += TWOPI;
+        while (orient[i][0] > MY_PI) orient[i][0] -= TWOPI;
+        if (orientflag == 4) orient[i][1] = orient[i][2] = orient[i][3] = 0.0;
+      } else if (eflags[i] & TRIANGLE) {
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::qconjugate(quat[ibody],qc);
+        MathExtra::quatquat(qc,quatatom,orient[i]);
+        MathExtra::qnormalize(orient[i]);
+      } else if (orientflag == 4) {
+        orient[i][0] = orient[i][1] = orient[i][2] = orient[i][3] = 0.0;
+      } else if (orientflag == 1)
+        orient[i][0] = 0.0;
+
+      if (eflags[i] & DIPOLE) {
+        MathExtra::transpose_matvec(ex_space[ibody],ey_space[ibody],
+                                    ez_space[ibody],mu[i],dorient[i]);
+        MathExtra::snormalize3(mu[i][3],dorient[i],dorient[i]);
+      } else if (dorientflag)
+        dorient[i][0] = dorient[i][1] = dorient[i][2] = 0.0;
+    }
+  }
+
+  // test for valid principal moments & axes
+  // recompute moments of inertia around new axes
+  // 3 diagonal moments should equal principal moments
+  // 3 off-diagonal moments should be 0.0
+  // extended particles may contribute extra terms to moments of inertia
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    sum[ibody][0] += massone *
+      (displace[i][1]*displace[i][1] + displace[i][2]*displace[i][2]);
+    sum[ibody][1] += massone *
+      (displace[i][0]*displace[i][0] + displace[i][2]*displace[i][2]);
+    sum[ibody][2] += massone *
+      (displace[i][0]*displace[i][0] + displace[i][1]*displace[i][1]);
+    sum[ibody][3] -= massone * displace[i][1]*displace[i][2];
+    sum[ibody][4] -= massone * displace[i][0]*displace[i][2];
+    sum[ibody][5] -= massone * displace[i][0]*displace[i][1];
+  }
+
+  if (extended) {
+    double ivec[6];
+    double *shape,*inertiaatom;
+    double length;
+
+    for (i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      ibody = body[i];
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+
+      if (eflags[i] & SPHERE) {
+        sum[ibody][0] += SINERTIA*massone * radius[i]*radius[i];
+        sum[ibody][1] += SINERTIA*massone * radius[i]*radius[i];
+        sum[ibody][2] += SINERTIA*massone * radius[i]*radius[i];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        MathExtra::inertia_ellipsoid(shape,orient[i],massone,ivec);
+        sum[ibody][0] += ivec[0];
+        sum[ibody][1] += ivec[1];
+        sum[ibody][2] += ivec[2];
+        sum[ibody][3] += ivec[3];
+        sum[ibody][4] += ivec[4];
+        sum[ibody][5] += ivec[5];
+      } else if (eflags[i] & LINE) {
+        length = lbonus[line[i]].length;
+        MathExtra::inertia_line(length,orient[i][0],massone,ivec);
+        sum[ibody][0] += ivec[0];
+        sum[ibody][1] += ivec[1];
+        sum[ibody][2] += ivec[2];
+        sum[ibody][3] += ivec[3];
+        sum[ibody][4] += ivec[4];
+        sum[ibody][5] += ivec[5];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        MathExtra::inertia_triangle(inertiaatom,orient[i],massone,ivec);
+        sum[ibody][0] += ivec[0];
+        sum[ibody][1] += ivec[1];
+        sum[ibody][2] += ivec[2];
+        sum[ibody][3] += ivec[3];
+        sum[ibody][4] += ivec[4];
+        sum[ibody][5] += ivec[5];
+      }
+    }
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  // error check that re-computed moments of inertia match diagonalized ones
+  // do not do test for bodies with params read from infile
+
+  double norm;
+  for (ibody = 0; ibody < nbody; ibody++) {
+    if (infile && inbody[ibody]) continue;
+    if (inertia[ibody][0] == 0.0) {
+      if (fabs(all[ibody][0]) > TOLERANCE)
+        error->all(FLERR,"Fix rigid: Bad principal moments");
+    } else {
+      if (fabs((all[ibody][0]-inertia[ibody][0])/inertia[ibody][0]) >
+          TOLERANCE) error->all(FLERR,"Fix rigid: Bad principal moments");
+    }
+    if (inertia[ibody][1] == 0.0) {
+      if (fabs(all[ibody][1]) > TOLERANCE)
+        error->all(FLERR,"Fix rigid: Bad principal moments");
+    } else {
+      if (fabs((all[ibody][1]-inertia[ibody][1])/inertia[ibody][1]) >
+          TOLERANCE) error->all(FLERR,"Fix rigid: Bad principal moments");
+    }
+    if (inertia[ibody][2] == 0.0) {
+      if (fabs(all[ibody][2]) > TOLERANCE)
+        error->all(FLERR,"Fix rigid: Bad principal moments");
+    } else {
+      if (fabs((all[ibody][2]-inertia[ibody][2])/inertia[ibody][2]) >
+          TOLERANCE) error->all(FLERR,"Fix rigid: Bad principal moments");
+    }
+    norm = (inertia[ibody][0] + inertia[ibody][1] + inertia[ibody][2]) / 3.0;
+    if (fabs(all[ibody][3]/norm) > TOLERANCE ||
+        fabs(all[ibody][4]/norm) > TOLERANCE ||
+        fabs(all[ibody][5]/norm) > TOLERANCE)
+      error->all(FLERR,"Fix rigid: Bad principal moments");
+  }
+
+  if (infile) memory->destroy(inbody);
+}
+
+/* ----------------------------------------------------------------------
+   one-time initialization of dynamic rigid body attributes
+   set vcm and angmom, computed explicitly from constituent particles
+   not done if body properites read from file, e.g. for overlapping particles
+------------------------------------------------------------------------- */
+
+void FixRigid::setup_bodies_dynamic()
+{
+  int i,ibody;
+  double massone,radone;
+
+  // vcm = velocity of center-of-mass of each rigid body
+  // angmom = angular momentum of each rigid body
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  double dx,dy,dz;
+  double unwrap[3];
+
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    sum[ibody][0] += v[i][0] * massone;
+    sum[ibody][1] += v[i][1] * massone;
+    sum[ibody][2] += v[i][2] * massone;
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    dx = unwrap[0] - xcm[ibody][0];
+    dy = unwrap[1] - xcm[ibody][1];
+    dz = unwrap[2] - xcm[ibody][2];
+
+    sum[ibody][3] += dy * massone*v[i][2] - dz * massone*v[i][1];
+    sum[ibody][4] += dz * massone*v[i][0] - dx * massone*v[i][2];
+    sum[ibody][5] += dx * massone*v[i][1] - dy * massone*v[i][0];
+  }
+
+  // extended particles add their rotation to angmom of body
+
+  if (extended) {
+    AtomVecLine::Bonus *lbonus;
+    if (avec_line) lbonus = avec_line->bonus;
+    double **omega_one = atom->omega;
+    double **angmom_one = atom->angmom;
+    double *radius = atom->radius;
+    int *line = atom->line;
+
+    for (i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      ibody = body[i];
+
+      if (eflags[i] & OMEGA) {
+        if (eflags[i] & SPHERE) {
+          radone = radius[i];
+          sum[ibody][3] += SINERTIA*rmass[i] * radone*radone * omega_one[i][0];
+          sum[ibody][4] += SINERTIA*rmass[i] * radone*radone * omega_one[i][1];
+          sum[ibody][5] += SINERTIA*rmass[i] * radone*radone * omega_one[i][2];
+        } else if (eflags[i] & LINE) {
+          radone = lbonus[line[i]].length;
+          sum[ibody][5] += LINERTIA*rmass[i] * radone*radone * omega_one[i][2];
+        }
+      }
+      if (eflags[i] & ANGMOM) {
+        sum[ibody][3] += angmom_one[i][0];
+        sum[ibody][4] += angmom_one[i][1];
+        sum[ibody][5] += angmom_one[i][2];
+      }
+    }
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  // normalize velocity of COM
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    vcm[ibody][0] = all[ibody][0]/masstotal[ibody];
+    vcm[ibody][1] = all[ibody][1]/masstotal[ibody];
+    vcm[ibody][2] = all[ibody][2]/masstotal[ibody];
+    angmom[ibody][0] = all[ibody][3];
+    angmom[ibody][1] = all[ibody][4];
+    angmom[ibody][2] = all[ibody][5];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   read per rigid body info from user-provided file
+   which = 0 to read everthing except 6 moments of inertia
+   which = 1 to read 6 moments of inertia
+   flag inbody = 0 for bodies whose info is read from file
+   nlines = # of lines of rigid body info
+   one line = rigid-ID mass xcm ycm zcm ixx iyy izz ixy ixz iyz
+              vxcm vycm vzcm lx ly lz ix iy iz
+------------------------------------------------------------------------- */
+
+void FixRigid::readfile(int which, double *vec,
+                        double **array1, double **array2, double **array3,
+                        imageint *ivec, int *inbody)
+{
+  int j,nchunk,id,eofflag,xbox,ybox,zbox;
+  int nlines;
+  FILE *fp;
+  char *eof,*start,*next,*buf;
+  char line[MAXLINE];
+
+  if (me == 0) {
+    fp = fopen(infile,"r");
+    if (fp == NULL) {
+      char str[128];
+      sprintf(str,"Cannot open fix rigid infile %s",infile);
+      error->one(FLERR,str);
+    }
+
+    while (1) {
+      eof = fgets(line,MAXLINE,fp);
+      if (eof == NULL) error->one(FLERR,"Unexpected end of fix rigid file");
+      start = &line[strspn(line," \t\n\v\f\r")];
+      if (*start != '\0' && *start != '#') break;
+    }
+
+    sscanf(line,"%d",&nlines);
+  }
+
+  MPI_Bcast(&nlines,1,MPI_INT,0,world);
+  if (nlines == 0) error->all(FLERR,"Fix rigid file has no lines");
+
+  char *buffer = new char[CHUNK*MAXLINE];
+  char **values = new char*[ATTRIBUTE_PERBODY];
+
+  int nread = 0;
+  while (nread < nlines) {
+    nchunk = MIN(nlines-nread,CHUNK);
+    eofflag = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
+    if (eofflag) error->all(FLERR,"Unexpected end of fix rigid file");
+
+    buf = buffer;
+    next = strchr(buf,'\n');
+    *next = '\0';
+    int nwords = atom->count_words(buf);
+    *next = '\n';
+
+    if (nwords != ATTRIBUTE_PERBODY)
+      error->all(FLERR,"Incorrect rigid body format in fix rigid file");
+
+    // loop over lines of rigid body attributes
+    // tokenize the line into values
+    // id = rigid body ID
+    // use ID as-is for SINGLE, as mol-ID for MOLECULE, as-is for GROUP
+    // for which = 0, store all but inertia in vecs and arrays
+    // for which = 1, store inertia tensor array, invert 3,4,5 values to Voigt
+
+    for (int i = 0; i < nchunk; i++) {
+      next = strchr(buf,'\n');
+
+      values[0] = strtok(buf," \t\n\r\f");
+      for (j = 1; j < nwords; j++)
+        values[j] = strtok(NULL," \t\n\r\f");
+
+      id = atoi(values[0]);
+      if (rstyle == MOLECULE) {
+        if (id <= 0 || id > maxmol)
+          error->all(FLERR,"Invalid rigid body ID in fix rigid file");
+        id = mol2body[id];
+      } else id--;
+
+      if (id < 0 || id >= nbody)
+        error->all(FLERR,"Invalid rigid body ID in fix rigid file");
+      inbody[id] = 1;
+
+      if (which == 0) {
+        vec[id] = atof(values[1]);
+        array1[id][0] = atof(values[2]);
+        array1[id][1] = atof(values[3]);
+        array1[id][2] = atof(values[4]);
+        array2[id][0] = atof(values[11]);
+        array2[id][1] = atof(values[12]);
+        array2[id][2] = atof(values[13]);
+        array3[id][0] = atof(values[14]);
+        array3[id][1] = atof(values[15]);
+        array3[id][2] = atof(values[16]);
+        xbox = atoi(values[17]);
+        ybox = atoi(values[18]);
+        zbox = atoi(values[19]);
+        ivec[id] = ((imageint) (xbox + IMGMAX) & IMGMASK) |
+          (((imageint) (ybox + IMGMAX) & IMGMASK) << IMGBITS) |
+          (((imageint) (zbox + IMGMAX) & IMGMASK) << IMG2BITS);
+      } else {
+        array1[id][0] = atof(values[5]);
+        array1[id][1] = atof(values[6]);
+        array1[id][2] = atof(values[7]);
+        array1[id][3] = atof(values[10]);
+        array1[id][4] = atof(values[9]);
+        array1[id][5] = atof(values[8]);
+      }
+
+      buf = next + 1;
+    }
+
+    nread += nchunk;
+  }
+
+  if (me == 0) fclose(fp);
+
+  delete [] buffer;
+  delete [] values;
+}
+
+/* ----------------------------------------------------------------------
+   write out restart info for mass, COM, inertia tensor, image flags to file
+   identical format to infile option, so info can be read in when restarting
+   only proc 0 writes list of global bodies to file
+------------------------------------------------------------------------- */
+
+void FixRigid::write_restart_file(char *file)
+{
+  if (me) return;
+
+  char outfile[128];
+  sprintf(outfile,"%s.rigid",file);
+  FILE *fp = fopen(outfile,"w");
+  if (fp == NULL) {
+    char str[128];
+    sprintf(str,"Cannot open fix rigid restart file %s",outfile);
+    error->one(FLERR,str);
+  }
+
+  fprintf(fp,"# fix rigid mass, COM, inertia tensor info for "
+          "%d bodies on timestep " BIGINT_FORMAT "\n\n",
+          nbody,update->ntimestep);
+  fprintf(fp,"%d\n",nbody);
+
+  // compute I tensor against xyz axes from diagonalized I and current quat
+  // Ispace = P Idiag P_transpose
+  // P is stored column-wise in exyz_space
+
+  int xbox,ybox,zbox;
+  double p[3][3],pdiag[3][3],ispace[3][3];
+
+  int id;
+  for (int i = 0; i < nbody; i++) {
+    if (rstyle == SINGLE || rstyle == GROUP) id = i;
+    else id = body2mol[i];
+
+    MathExtra::col2mat(ex_space[i],ey_space[i],ez_space[i],p);
+    MathExtra::times3_diag(p,inertia[i],pdiag);
+    MathExtra::times3_transpose(pdiag,p,ispace);
+
+    xbox = (imagebody[i] & IMGMASK) - IMGMAX;
+    ybox = (imagebody[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (imagebody[i] >> IMG2BITS) - IMGMAX;
+
+    fprintf(fp,"%d %-1.16e %-1.16e %-1.16e %-1.16e "
+            "%-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e "
+            "%-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e "
+            "%d %d %d\n",
+            id,masstotal[i],xcm[i][0],xcm[i][1],xcm[i][2],
+            ispace[0][0],ispace[1][1],ispace[2][2],
+            ispace[0][1],ispace[0][2],ispace[1][2],
+            vcm[i][0],vcm[i][1],vcm[i][2],
+            angmom[i][0],angmom[i][1],angmom[i][2],
+            xbox,ybox,zbox);
+  }
+
+  fclose(fp);
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based arrays
+------------------------------------------------------------------------- */
+
+double FixRigid::memory_usage()
+{
+  int nmax = atom->nmax;
+  double bytes = nmax * sizeof(int);
+  bytes += nmax * sizeof(imageint);
+  bytes += nmax*3 * sizeof(double);
+  bytes += maxvatom*6 * sizeof(double);    // vatom
+  if (extended) {
+    bytes += nmax * sizeof(int);
+    if (orientflag) bytes = nmax*orientflag * sizeof(double);
+    if (dorientflag) bytes = nmax*3 * sizeof(double);
+  }
+  return bytes;
+}
+
+/* ----------------------------------------------------------------------
+   allocate local atom-based arrays
+------------------------------------------------------------------------- */
+
+void FixRigid::grow_arrays(int nmax)
+{
+  memory->grow(body,nmax,"rigid:body");
+  memory->grow(xcmimage,nmax,"rigid:xcmimage");
+  memory->grow(displace,nmax,3,"rigid:displace");
+  if (extended) {
+    memory->grow(eflags,nmax,"rigid:eflags");
+    if (orientflag) memory->grow(orient,nmax,orientflag,"rigid:orient");
+    if (dorientflag) memory->grow(dorient,nmax,3,"rigid:dorient");
+  }
+
+  // check for regrow of vatom
+  // must be done whether per-atom virial is accumulated on this step or not
+  //   b/c this is only time grow_array() may be called
+  // need to regrow b/c vatom is calculated before and after atom migration
+
+  if (nmax > maxvatom) {
+    maxvatom = atom->nmax;
+    memory->grow(vatom,maxvatom,6,"fix:vatom");
+  }
+}
+
+/* ----------------------------------------------------------------------
+   copy values within local atom-based arrays
+------------------------------------------------------------------------- */
+
+void FixRigid::copy_arrays(int i, int j, int delflag)
+{
+  body[j] = body[i];
+  xcmimage[j] = xcmimage[i];
+  displace[j][0] = displace[i][0];
+  displace[j][1] = displace[i][1];
+  displace[j][2] = displace[i][2];
+  if (extended) {
+    eflags[j] = eflags[i];
+    for (int k = 0; k < orientflag; k++)
+      orient[j][k] = orient[i][k];
+    if (dorientflag) {
+      dorient[j][0] = dorient[i][0];
+      dorient[j][1] = dorient[i][1];
+      dorient[j][2] = dorient[i][2];
+    }
+  }
+
+  // must also copy vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      vatom[j][k] = vatom[i][k];
+}
+
+/* ----------------------------------------------------------------------
+   initialize one atom's array values, called when atom is created
+------------------------------------------------------------------------- */
+
+void FixRigid::set_arrays(int i)
+{
+  body[i] = -1;
+  xcmimage[i] = 0;
+  displace[i][0] = 0.0;
+  displace[i][1] = 0.0;
+  displace[i][2] = 0.0;
+
+  // must also zero vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      vatom[i][k] = 0.0;
+}
+
+/* ----------------------------------------------------------------------
+   pack values in local atom-based arrays for exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixRigid::pack_exchange(int i, double *buf)
+{
+  buf[0] = ubuf(body[i]).d;
+  buf[1] = ubuf(xcmimage[i]).d;
+  buf[2] = displace[i][0];
+  buf[3] = displace[i][1];
+  buf[4] = displace[i][2];
+  if (!extended) return 5;
+
+  int m = 5;
+  buf[m++] = eflags[i];
+  for (int j = 0; j < orientflag; j++)
+    buf[m++] = orient[i][j];
+  if (dorientflag) {
+    buf[m++] = dorient[i][0];
+    buf[m++] = dorient[i][1];
+    buf[m++] = dorient[i][2];
+  }
+
+  // must also pack vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      buf[m++] = vatom[i][k];
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   unpack values in local atom-based arrays from exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixRigid::unpack_exchange(int nlocal, double *buf)
+{
+  body[nlocal] = (int) ubuf(buf[0]).i;
+  xcmimage[nlocal] = (imageint) ubuf(buf[1]).i;
+  displace[nlocal][0] = buf[2];
+  displace[nlocal][1] = buf[3];
+  displace[nlocal][2] = buf[4];
+  if (!extended) return 5;
+
+  int m = 5;
+  eflags[nlocal] = static_cast<int> (buf[m++]);
+  for (int j = 0; j < orientflag; j++)
+    orient[nlocal][j] = buf[m++];
+  if (dorientflag) {
+    dorient[nlocal][0] = buf[m++];
+    dorient[nlocal][1] = buf[m++];
+    dorient[nlocal][2] = buf[m++];
+  }
+
+  // must also unpack vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      vatom[nlocal][k] = buf[m++];
+
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigid::reset_dt()
+{
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+  dtq = 0.5 * update->dt;
+}
+
+/* ----------------------------------------------------------------------
+   zero linear momentum of each rigid body
+   set Vcm to 0.0, then reset velocities of particles via set_v()
+------------------------------------------------------------------------- */
+
+void FixRigid::zero_momentum()
+{
+  for (int ibody = 0; ibody < nbody; ibody++)
+    vcm[ibody][0] = vcm[ibody][1] = vcm[ibody][2] = 0.0;
+
+  evflag = 0;
+  set_v();
+}
+
+/* ----------------------------------------------------------------------
+   zero angular momentum of each rigid body
+   set angmom/omega to 0.0, then reset velocities of particles via set_v()
+------------------------------------------------------------------------- */
+
+void FixRigid::zero_rotation()
+{
+  for (int ibody = 0; ibody < nbody; ibody++) {
+    angmom[ibody][0] = angmom[ibody][1] = angmom[ibody][2] = 0.0;
+    omega[ibody][0] = omega[ibody][1] = omega[ibody][2] = 0.0;
+  }
+
+  evflag = 0;
+  set_v();
+}
+
+/* ----------------------------------------------------------------------
+   return temperature of collection of rigid bodies
+   non-active DOF are removed by fflag/tflag and in tfactor
+------------------------------------------------------------------------- */
+
+double FixRigid::compute_scalar()
+{
+  double wbody[3],rot[3][3];
+
+  double t = 0.0;
+  for (int i = 0; i < nbody; i++) {
+    t += masstotal[i] * (fflag[i][0]*vcm[i][0]*vcm[i][0] +
+                         fflag[i][1]*vcm[i][1]*vcm[i][1] +
+                         fflag[i][2]*vcm[i][2]*vcm[i][2]);
+
+    // wbody = angular velocity in body frame
+
+    MathExtra::quat_to_mat(quat[i],rot);
+    MathExtra::transpose_matvec(rot,angmom[i],wbody);
+    if (inertia[i][0] == 0.0) wbody[0] = 0.0;
+    else wbody[0] /= inertia[i][0];
+    if (inertia[i][1] == 0.0) wbody[1] = 0.0;
+    else wbody[1] /= inertia[i][1];
+    if (inertia[i][2] == 0.0) wbody[2] = 0.0;
+    else wbody[2] /= inertia[i][2];
+
+    t += tflag[i][0]*inertia[i][0]*wbody[0]*wbody[0] +
+      tflag[i][1]*inertia[i][1]*wbody[1]*wbody[1] +
+      tflag[i][2]*inertia[i][2]*wbody[2]*wbody[2];
+  }
+
+  t *= tfactor;
+  return t;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void *FixRigid::extract(const char *str, int &dim)
+{
+  if (strcmp(str,"body") == 0) {
+    dim = 1;
+    return body;
+  }
+  if (strcmp(str,"masstotal") == 0) {
+    dim = 1;
+    return masstotal;
+  }
+  if (strcmp(str,"t_target") == 0) {
+    dim = 0;
+    return &t_target;
+  }
+
+  return NULL;
+}
+
+/* ----------------------------------------------------------------------
+   return translational KE for all rigid bodies
+   KE = 1/2 M Vcm^2
+------------------------------------------------------------------------- */
+
+double FixRigid::extract_ke()
+{
+  double ke = 0.0;
+  for (int i = 0; i < nbody; i++)
+    ke += masstotal[i] *
+      (vcm[i][0]*vcm[i][0] + vcm[i][1]*vcm[i][1] + vcm[i][2]*vcm[i][2]);
+
+  return 0.5*ke;
+}
+
+/* ----------------------------------------------------------------------
+   return rotational KE for all rigid bodies
+   Erotational = 1/2 I wbody^2
+------------------------------------------------------------------------- */
+
+double FixRigid::extract_erotational()
+{
+  double wbody[3],rot[3][3];
+
+  double erotate = 0.0;
+  for (int i = 0; i < nbody; i++) {
+
+    // wbody = angular velocity in body frame
+
+    MathExtra::quat_to_mat(quat[i],rot);
+    MathExtra::transpose_matvec(rot,angmom[i],wbody);
+    if (inertia[i][0] == 0.0) wbody[0] = 0.0;
+    else wbody[0] /= inertia[i][0];
+    if (inertia[i][1] == 0.0) wbody[1] = 0.0;
+    else wbody[1] /= inertia[i][1];
+    if (inertia[i][2] == 0.0) wbody[2] = 0.0;
+    else wbody[2] /= inertia[i][2];
+
+    erotate += inertia[i][0]*wbody[0]*wbody[0] +
+      inertia[i][1]*wbody[1]*wbody[1] + inertia[i][2]*wbody[2]*wbody[2];
+  }
+
+  return 0.5*erotate;
+}
+
+/* ----------------------------------------------------------------------
+   return attributes of a rigid body
+   15 values per body
+   xcm = 0,1,2; vcm = 3,4,5; fcm = 6,7,8; torque = 9,10,11; image = 12,13,14
+------------------------------------------------------------------------- */
+
+double FixRigid::compute_array(int i, int j)
+{
+  if (j < 3) return xcm[i][j];
+  if (j < 6) return vcm[i][j-3];
+  if (j < 9) return fcm[i][j-6];
+  if (j < 12) return torque[i][j-9];
+  if (j == 12) return (imagebody[i] & IMGMASK) - IMGMAX;
+  if (j == 13) return (imagebody[i] >> IMGBITS & IMGMASK) - IMGMAX;
+  return (imagebody[i] >> IMG2BITS) - IMGMAX;
+}
diff -uN src/fix_rigid.h src_DFT-CES2/fix_rigid.h
--- src/fix_rigid.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,268 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid,FixRigid)
+
+#else
+
+#ifndef LMP_FIX_RIGID_H
+#define LMP_FIX_RIGID_H
+
+#include "fix.h"
+
+namespace LAMMPS_NS {
+
+class FixRigid : public Fix {
+ public:
+  FixRigid(class LAMMPS *, int, char **);
+  virtual ~FixRigid();
+  virtual int setmask();
+  virtual void init();
+  virtual void setup(int);
+  virtual void initial_integrate(int);
+  void post_force(int);
+  virtual void final_integrate();
+  void initial_integrate_respa(int, int, int);
+  void final_integrate_respa(int, int);
+  void write_restart_file(char *);
+  virtual double compute_scalar();
+  virtual int modify_param(int, char **) {return 0;}
+
+  double memory_usage();
+  void grow_arrays(int);
+  void copy_arrays(int, int, int);
+  void set_arrays(int);
+  int pack_exchange(int, double *);
+  int unpack_exchange(int, double *);
+
+  void setup_pre_neighbor();
+  void pre_neighbor();
+  int dof(int);
+  void deform(int);
+  void enforce2d();
+  void reset_dt();
+  void zero_momentum();
+  void zero_rotation();
+  virtual void *extract(const char*, int &);
+  double extract_ke();
+  double extract_erotational();
+  double compute_array(int, int);
+
+ protected:
+  int me,nprocs;
+  double dtv,dtf,dtq;
+  double *step_respa;
+  int triclinic;
+  double MINUSPI,TWOPI;
+
+  char *infile;             // file to read rigid body attributes from
+  int rstyle;               // SINGLE,MOLECULE,GROUP
+  int setupflag;            // 1 if body properties are setup, else 0
+
+  int dimension;            // # of dimensions
+  int nbody;                // # of rigid bodies
+  int nlinear;              // # of linear rigid bodies
+  int *nrigid;              // # of atoms in each rigid body
+  int *mol2body;            // convert mol-ID to rigid body index
+  int *body2mol;            // convert rigid body index to mol-ID
+  int maxmol;               // size of mol2body = max mol-ID
+
+  int *body;                // which body each atom is part of (-1 if none)
+  double **displace;        // displacement of each atom in body coords
+
+  double *masstotal;        // total mass of each rigid body
+  double **xcm;             // coords of center-of-mass of each rigid body
+  double **vcm;             // velocity of center-of-mass of each
+  double **fcm;             // force on center-of-mass of each
+  double **inertia;         // 3 principal components of inertia of each
+  double **ex_space,**ey_space,**ez_space;
+                            // principal axes of each in space coords
+  double **angmom;          // angular momentum of each in space coords
+  double **omega;           // angular velocity of each in space coords
+  double **torque;          // torque on each rigid body in space coords
+  double **quat;            // quaternion of each rigid body
+  imageint *imagebody;        // image flags of xcm of each rigid body
+  double **fflag;           // flag for on/off of center-of-mass force
+  double **tflag;           // flag for on/off of center-of-mass torque
+  double **langextra;       // Langevin thermostat forces and torques
+
+  double **sum,**all;       // work vectors for each rigid body
+  int **remapflag;          // PBC remap flags for each rigid body
+
+  int extended;             // 1 if any particles have extended attributes
+  int orientflag;           // 1 if particles store spatial orientation
+  int dorientflag;          // 1 if particles store dipole orientation
+  int reinitflag;           // 1 if re-initialize rigid bodies between runs
+
+  imageint *xcmimage;       // internal image flags for atoms in rigid bodies
+                            // set relative to in-box xcm of each body
+  int *eflags;              // flags for extended particles
+  double **orient;          // orientation vector of particle wrt rigid body
+  double **dorient;         // orientation of dipole mu wrt rigid body
+
+  double tfactor;           // scale factor on temperature of rigid bodies
+  int langflag;             // 0/1 = no/yes Langevin thermostat
+
+  int tstat_flag;           // NVT settings
+  double t_start,t_stop,t_target;
+  double t_period,t_freq;
+  int t_chain,t_iter,t_order;
+
+  int pstat_flag;           // NPT settings
+  double p_start[3],p_stop[3];
+  double p_period[3],p_freq[3];
+  int p_flag[3];
+  int pcouple,pstyle;
+  int p_chain;
+
+  int allremap;              // remap all atoms
+  int dilate_group_bit;      // mask for dilation group
+  char *id_dilate;           // group name to dilate
+
+  class RanMars *random;
+  class AtomVecEllipsoid *avec_ellipsoid;
+  class AtomVecLine *avec_line;
+  class AtomVecTri *avec_tri;
+
+  int POINT,SPHERE,ELLIPSOID,LINE,TRIANGLE,DIPOLE;   // bitmasks for eflags
+  int OMEGA,ANGMOM,TORQUE;
+
+  void image_shift();
+  void set_xv();
+  void set_v();
+  void setup_bodies_static();
+  void setup_bodies_dynamic();
+  void readfile(int, double *, double **, double **, double **,
+                imageint *, int *);
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Fix rigid molecule requires atom attribute molecule
+
+Self-explanatory.
+
+E: Too many molecules for fix rigid
+
+The limit is 2^31 = ~2 billion molecules.
+
+E: Could not find fix rigid group ID
+
+A group ID used in the fix rigid command does not exist.
+
+E: One or more atoms belong to multiple rigid bodies
+
+Two or more rigid bodies defined by the fix rigid command cannot
+contain the same atom.
+
+E: No rigid bodies defined
+
+The fix specification did not end up defining any rigid bodies.
+
+E: Fix rigid z force cannot be on for 2d simulation
+
+Self-explanatory.
+
+E: Fix rigid xy torque cannot be on for 2d simulation
+
+Self-explanatory.
+
+E: Fix rigid langevin period must be > 0.0
+
+Self-explanatory.
+
+E: Fix rigid npt/nph dilate group ID does not exist
+
+Self-explanatory.
+
+E: One or zero atoms in rigid body
+
+Any rigid body defined by the fix rigid command must contain 2 or more
+atoms.
+
+W: More than one fix rigid
+
+It is not efficient to use fix rigid more than once.
+
+E: Rigid fix must come before NPT/NPH fix
+
+NPT/NPH fix must be defined in input script after all rigid fixes,
+else the rigid fix contribution to the pressure virial is
+incorrect.
+
+W: Cannot count rigid body degrees-of-freedom before bodies are initialized
+
+This means the temperature associated with the rigid bodies may be
+incorrect on this timestep.
+
+W: Computing temperature of portions of rigid bodies
+
+The group defined by the temperature compute does not encompass all
+the atoms in one or more rigid bodies, so the change in
+degrees-of-freedom for the atoms in those partial rigid bodies will
+not be accounted for.
+
+E: Fix rigid atom has non-zero image flag in a non-periodic dimension
+
+Image flags for non-periodic dimensions should not be set.
+
+E: Insufficient Jacobi rotations for rigid body
+
+Eigensolve for rigid body was not sufficiently accurate.
+
+E: Fix rigid: Bad principal moments
+
+The principal moments of inertia computed for a rigid body
+are not within the required tolerances.
+
+E: Cannot open fix rigid infile %s
+
+The specified file cannot be opened.  Check that the path and name are
+correct.
+
+E: Unexpected end of fix rigid file
+
+A read operation from the file failed.
+
+E: Fix rigid file has no lines
+
+Self-explanatory.
+
+E: Incorrect rigid body format in fix rigid file
+
+The number of fields per line is not what expected.
+
+E: Invalid rigid body ID in fix rigid file
+
+The ID does not match the number of an existing ID of rigid bodies
+that are defined by the fix rigid command.
+
+E: Cannot open fix rigid restart file %s
+
+The specified file cannot be opened.  Check that the path and name are
+correct.
+
+*/
diff -uN src/fix_rigid_nh.cpp src_DFT-CES2/fix_rigid_nh.cpp
--- src/fix_rigid_nh.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nh.cpp	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,1402 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Tony Sheh (U Michigan), Trung Dac Nguyen (U Michigan)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdio.h>
+#include <string.h>
+#include "fix_rigid_nh.h"
+#include "math_extra.h"
+#include "atom.h"
+#include "compute.h"
+#include "domain.h"
+#include "update.h"
+#include "modify.h"
+#include "fix_deform.h"
+#include "group.h"
+#include "comm.h"
+#include "force.h"
+#include "kspace.h"
+#include "output.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum{NONE,XYZ,XY,YZ,XZ};     // same as in FixRigid
+enum{ISO,ANISO,TRICLINIC};   // same as in FixRigid
+
+#define EPSILON 1.0e-7
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNH::FixRigidNH(LAMMPS *lmp, int narg, char **arg) :
+  FixRigid(lmp, narg, arg), conjqm(NULL), w(NULL), 
+  wdti1(NULL), wdti2(NULL), wdti4(NULL), q_t(NULL), q_r(NULL), 
+  eta_t(NULL), eta_r(NULL), eta_dot_t(NULL), eta_dot_r(NULL), 
+  f_eta_t(NULL), f_eta_r(NULL), q_b(NULL), eta_b(NULL), 
+  eta_dot_b(NULL), f_eta_b(NULL), rfix(NULL), id_temp(NULL), 
+  id_press(NULL), temperature(NULL), pressure(NULL)
+{
+  // error checks: could be moved up to FixRigid
+
+  if ((p_flag[0] == 1 && p_period[0] <= 0.0) ||
+      (p_flag[1] == 1 && p_period[1] <= 0.0) ||
+      (p_flag[2] == 1 && p_period[2] <= 0.0))
+    error->all(FLERR,"Fix rigid npt/nph period must be > 0.0");
+
+  if (dimension == 2 && p_flag[2])
+    error->all(FLERR,"Invalid fix rigid npt/nph command for a 2d simulation");
+  if (dimension == 2 && (pcouple == YZ || pcouple == XZ))
+    error->all(FLERR,"Invalid fix rigid npt/nph command for a 2d simulation");
+
+  if (pcouple == XYZ && (p_flag[0] == 0 || p_flag[1] == 0))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == XYZ && dimension == 3 && p_flag[2] == 0)
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == XY && (p_flag[0] == 0 || p_flag[1] == 0))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == YZ && (p_flag[1] == 0 || p_flag[2] == 0))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == XZ && (p_flag[0] == 0 || p_flag[2] == 0))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+
+  // require periodicity in tensile dimension
+
+  if (p_flag[0] && domain->xperiodic == 0)
+    error->all(FLERR,
+               "Cannot use fix rigid npt/nph on a non-periodic dimension");
+  if (p_flag[1] && domain->yperiodic == 0)
+    error->all(FLERR,
+               "Cannot use fix rigid npt/nph on a non-periodic dimension");
+  if (p_flag[2] && domain->zperiodic == 0)
+    error->all(FLERR,
+               "Cannot use fix rigid npt/nph on a non-periodic dimension");
+
+  if (pcouple == XYZ && dimension == 3 &&
+      (p_start[0] != p_start[1] || p_start[0] != p_start[2] ||
+       p_stop[0] != p_stop[1] || p_stop[0] != p_stop[2] ||
+       p_period[0] != p_period[1] || p_period[0] != p_period[2]))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == XYZ && dimension == 2 &&
+      (p_start[0] != p_start[1] || p_stop[0] != p_stop[1] ||
+       p_period[0] != p_period[1]))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == XY &&
+      (p_start[0] != p_start[1] || p_stop[0] != p_stop[1] ||
+       p_period[0] != p_period[1]))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == YZ &&
+      (p_start[1] != p_start[2] || p_stop[1] != p_stop[2] ||
+       p_period[1] != p_period[2]))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+  if (pcouple == XZ &&
+      (p_start[0] != p_start[2] || p_stop[0] != p_stop[2] ||
+       p_period[0] != p_period[2]))
+    error->all(FLERR,"Invalid fix rigid npt/nph command pressure settings");
+
+  if ((tstat_flag && t_period <= 0.0) ||
+      (p_flag[0] && p_period[0] <= 0.0) ||
+      (p_flag[1] && p_period[1] <= 0.0) ||
+      (p_flag[2] && p_period[2] <= 0.0))
+    error->all(FLERR,"Fix rigid nvt/npt/nph damping parameters must be > 0.0");
+
+  // memory allocation and initialization
+
+  memory->create(conjqm,nbody,4,"rigid_nh:conjqm");
+  if (tstat_flag || pstat_flag) {
+    allocate_chain();
+    allocate_order();
+  }
+
+  if (tstat_flag) {
+    eta_t[0] = eta_r[0] = 0.0;
+    eta_dot_t[0] = eta_dot_r[0] = 0.0;
+    f_eta_t[0] = f_eta_r[0] = 0.0;
+
+    for (int i = 1; i < t_chain; i++) {
+      eta_t[i] = eta_r[i] = 0.0;
+      eta_dot_t[i] = eta_dot_r[i] = 0.0;
+    }
+  }
+
+  if (pstat_flag) {
+    epsilon_dot[0] = epsilon_dot[1] = epsilon_dot[2] = 0.0;
+    eta_b[0] = eta_dot_b[0] = f_eta_b[0] = 0.0;
+    for (int i = 1; i < p_chain; i++)
+      eta_b[i] = eta_dot_b[i] = 0.0;
+  }
+
+  // rigid body pointers
+
+  nrigidfix = 0;
+  rfix = NULL;
+
+  vol0 = 0.0;
+  t0 = 1.0;
+
+  tcomputeflag = 0;
+  pcomputeflag = 0;
+
+  id_temp = NULL;
+  id_press = NULL;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNH::~FixRigidNH()
+{
+  memory->destroy(conjqm);
+  if (tstat_flag || pstat_flag) {
+    deallocate_chain();
+    deallocate_order();
+  }
+
+  if (rfix) delete [] rfix;
+
+  if (tcomputeflag) modify->delete_compute(id_temp);
+  delete [] id_temp;
+
+  // delete pressure if fix created it
+
+  if (pstat_flag) {
+    if (pcomputeflag) modify->delete_compute(id_press);
+    delete [] id_press;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRigidNH::setmask()
+{
+  int mask = 0;
+  mask = FixRigid::setmask();
+  if (tstat_flag || pstat_flag) mask |= THERMO_ENERGY;
+
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::init()
+{
+  FixRigid::init();
+
+  // recheck that dilate group has not been deleted
+
+  if (allremap == 0) {
+    int idilate = group->find(id_dilate);
+    if (idilate == -1)
+      error->all(FLERR,"Fix rigid npt/nph dilate group ID does not exist");
+    dilate_group_bit = group->bitmask[idilate];
+  }
+
+  // initialize thermostats
+  // set timesteps, constants
+  // store Yoshida-Suzuki integrator parameters
+
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+  dtq = 0.5 * update->dt;
+
+  boltz = force->boltz;
+  nktv2p = force->nktv2p;
+  mvv2e = force->mvv2e;
+
+  if (force->kspace) kspace_flag = 1;
+  else kspace_flag = 0;
+
+  nf_t = dimension * nbody;
+  if (dimension == 3) {
+    nf_r = dimension * nbody;
+    for (int ibody = 0; ibody < nbody; ibody++)
+      for (int k = 0; k < domain->dimension; k++)
+        if (fabs(inertia[ibody][k]) < EPSILON) nf_r--;
+  } else if (dimension == 2) {
+    nf_r = nbody;
+    for (int ibody = 0; ibody < nbody; ibody++)
+      if (fabs(inertia[ibody][2]) < EPSILON) nf_r--;
+  }
+
+  g_f = nf_t + nf_r;
+  onednft = 1.0 + (double)(dimension) / (double)g_f;
+  onednfr = (double) (dimension) / (double)g_f;
+
+  // see Table 1 in Kamberaj et al
+
+  if (tstat_flag || pstat_flag) {
+    if (t_order == 3) {
+      w[0] = 1.0 / (2.0 - pow(2.0, 1.0/3.0));
+      w[1] = 1.0 - 2.0*w[0];
+      w[2] = w[0];
+    } else if (t_order == 5) {
+      w[0] = 1.0 / (4.0 - pow(4.0, 1.0/3.0));
+      w[1] = w[0];
+      w[2] = 1.0 - 4.0 * w[0];
+      w[3] = w[0];
+      w[4] = w[0];
+    }
+  }
+
+  int icompute;
+  if (tcomputeflag) {
+    icompute = modify->find_compute(id_temp);
+    if (icompute < 0)
+      error->all(FLERR,"Temperature ID for fix rigid nvt/npt/nph does not exist");
+    temperature = modify->compute[icompute];
+  }
+
+  if (pstat_flag) {
+    if (domain->triclinic)
+      error->all(FLERR,"Fix rigid npt/nph does not yet allow triclinic box");
+
+    // ensure no conflict with fix deform
+
+    for (int i = 0; i < modify->nfix; i++)
+      if (strcmp(modify->fix[i]->style,"deform") == 0) {
+      	int *dimflag = ((FixDeform *) modify->fix[i])->dimflag;
+      	if ((p_flag[0] && dimflag[0]) || (p_flag[1] && dimflag[1]) ||
+      	    (p_flag[2] && dimflag[2]))
+          error->all(FLERR,"Cannot use fix rigid npt/nph and fix deform on "
+                     "same component of stress tensor");
+      }
+
+    // set frequency
+
+    p_freq_max = 0.0;
+    p_freq_max = MAX(p_freq[0],p_freq[1]);
+    p_freq_max = MAX(p_freq_max,p_freq[2]);
+
+    // tally the number of dimensions that are barostatted
+    // set initial volume and reference cell, if not already done
+
+    pdim = p_flag[0] + p_flag[1] + p_flag[2];
+    if (vol0 == 0.0) {
+      if (dimension == 2) vol0 = domain->xprd * domain->yprd;
+      else vol0 = domain->xprd * domain->yprd * domain->zprd;
+    }
+
+    // set pressure compute ptr
+
+    icompute = modify->find_compute(id_press);
+    if (icompute < 0)
+      error->all(FLERR,"Pressure ID for fix rigid npt/nph does not exist");
+    pressure = modify->compute[icompute];
+
+    // detect if any rigid fixes exist so rigid bodies move on remap
+    // rfix[] = indices to each fix rigid
+    // this will include self
+
+    if (rfix) delete [] rfix;
+    nrigidfix = 0;
+    rfix = NULL;
+
+    for (int i = 0; i < modify->nfix; i++)
+      if (modify->fix[i]->rigid_flag) nrigidfix++;
+    if (nrigidfix) {
+      rfix = new int[nrigidfix];
+      nrigidfix = 0;
+      for (int i = 0; i < modify->nfix; i++)
+        if (modify->fix[i]->rigid_flag) rfix[nrigidfix++] = i;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::setup(int vflag)
+{
+  FixRigid::setup(vflag);
+
+  double mbody[3];
+  akin_t = akin_r = 0.0;
+  for (int ibody = 0; ibody < nbody; ibody++) {
+    MathExtra::transpose_matvec(ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                                angmom[ibody],mbody);
+    MathExtra::quatvec(quat[ibody],mbody,conjqm[ibody]);
+    conjqm[ibody][0] *= 2.0;
+    conjqm[ibody][1] *= 2.0;
+    conjqm[ibody][2] *= 2.0;
+    conjqm[ibody][3] *= 2.0;
+
+    if (tstat_flag || pstat_flag) {
+      akin_t += masstotal[ibody]*(vcm[ibody][0]*vcm[ibody][0] +
+        vcm[ibody][1]*vcm[ibody][1] + vcm[ibody][2]*vcm[ibody][2]);
+      akin_r += angmom[ibody][0]*omega[ibody][0] +
+        angmom[ibody][1]*omega[ibody][1] + angmom[ibody][2]*omega[ibody][2];
+    }
+  }
+
+  // compute target temperature
+
+  if (tstat_flag) compute_temp_target();
+  else if (pstat_flag) {
+    t0 = temperature->compute_scalar();
+    if (t0 == 0.0) {
+      if (strcmp(update->unit_style,"lj") == 0) t0 = 1.0;
+      else t0 = 300.0;
+    }
+    t_target = t0;
+  }
+
+  // compute target pressure
+  // compute current pressure
+  // trigger virial computation on next timestep
+
+  if (pstat_flag) {
+    if (pstyle == ISO) {
+      temperature->compute_scalar();
+      pressure->compute_scalar();
+    } else {
+      temperature->compute_vector();
+      pressure->compute_vector();
+    }
+    couple();
+    pressure->addstep(update->ntimestep+1);
+  }
+
+  // initialize thermostat/barostat settings
+
+  double kt, t_mass, tb_mass;
+  kt = boltz * t_target;
+
+  if (tstat_flag) {
+    t_mass = kt / (t_freq*t_freq);
+    q_t[0] = nf_t * t_mass;
+    q_r[0] = nf_r * t_mass;
+    for (int i = 1; i < t_chain; i++)
+      q_t[i] = q_r[i] = t_mass;
+
+    for (int i = 1; i < t_chain; i++) {
+      f_eta_t[i] = (q_t[i-1] * eta_dot_t[i-1] * eta_dot_t[i-1] - kt)/q_t[i];
+      f_eta_r[i] = (q_r[i-1] * eta_dot_r[i-1] * eta_dot_r[i-1] - kt)/q_r[i];
+    }
+  }
+
+  // initial forces on barostat thermostat variables
+
+  if (pstat_flag) {
+    for (int i = 0; i < 3; i++)
+      if (p_flag[i]) {
+        epsilon_mass[i] = (g_f + dimension) * kt / (p_freq[i]*p_freq[i]);
+        epsilon[i] = log(vol0)/dimension;
+      }
+
+    tb_mass = kt / (p_freq_max * p_freq_max);
+    q_b[0] = dimension * dimension * tb_mass;
+    for (int i = 1; i < p_chain; i++) {
+      q_b[i] = tb_mass;
+      f_eta_b[i] = (q_b[i] * eta_dot_b[i-1] * eta_dot_b[i-1] - kt)/q_b[i];
+    }
+  }
+
+  // update order/timestep dependent coefficients
+
+  if (tstat_flag || pstat_flag) {
+    for (int i = 0; i < t_order; i++) {
+      wdti1[i] = w[i] * dtv / t_iter;
+      wdti2[i] = wdti1[i] / 2.0;
+      wdti4[i] = wdti1[i] / 4.0;
+    }
+  }
+
+  if (pstat_flag) {
+    compute_press_target();
+    nh_epsilon_dot();
+  }
+}
+
+/* ----------------------------------------------------------------------
+   perform preforce velocity Verlet integration
+   see Kamberaj paper for step references
+------------------------------------------------------------------------- */
+
+void FixRigidNH::initial_integrate(int vflag)
+{
+  double tmp,scale_r,scale_t[3],scale_v[3];
+  double dtfm,mbody[3],tbody[3],fquat[4];
+  double dtf2 = dtf * 2.0;
+
+  // compute scale variables
+
+  scale_t[0] = scale_t[1] = scale_t[2] = 1.0;
+  scale_v[0] = scale_v[1] = scale_v[2] = 1.0;
+  scale_r = 1.0;
+
+  if (tstat_flag) {
+    akin_t = akin_r = 0.0;
+    tmp = exp(-dtq * eta_dot_t[0]);
+    scale_t[0] = scale_t[1] = scale_t[2] = tmp;
+    tmp = exp(-dtq * eta_dot_r[0]);
+    scale_r = tmp;
+  }
+
+  if (pstat_flag) {
+    akin_t = akin_r = 0.0;
+    scale_t[0] *= exp(-dtq * (epsilon_dot[0] + mtk_term2));
+    scale_t[1] *= exp(-dtq * (epsilon_dot[1] + mtk_term2));
+    scale_t[2] *= exp(-dtq * (epsilon_dot[2] + mtk_term2));
+    scale_r *= exp(-dtq * (pdim * mtk_term2));
+
+    tmp = dtq * epsilon_dot[0];
+    scale_v[0] = dtv * exp(tmp) * maclaurin_series(tmp);
+    tmp = dtq * epsilon_dot[1];
+    scale_v[1] = dtv * exp(tmp) * maclaurin_series(tmp);
+    tmp = dtq * epsilon_dot[2];
+    scale_v[2] = dtv * exp(tmp) * maclaurin_series(tmp);
+  }
+
+  // update xcm, vcm, quat, conjqm and angmom
+
+  for (int ibody = 0; ibody < nbody; ibody++) {
+
+    // step 1.1 - update vcm by 1/2 step
+
+    dtfm = dtf / masstotal[ibody];
+    vcm[ibody][0] += dtfm * fcm[ibody][0] * fflag[ibody][0];
+    vcm[ibody][1] += dtfm * fcm[ibody][1] * fflag[ibody][1];
+    vcm[ibody][2] += dtfm * fcm[ibody][2] * fflag[ibody][2];
+
+    if (tstat_flag || pstat_flag) {
+      vcm[ibody][0] *= scale_t[0];
+      vcm[ibody][1] *= scale_t[1];
+      vcm[ibody][2] *= scale_t[2];
+
+      tmp = vcm[ibody][0]*vcm[ibody][0] + vcm[ibody][1]*vcm[ibody][1] +
+        vcm[ibody][2]*vcm[ibody][2];
+      akin_t += masstotal[ibody]*tmp;
+    }
+
+    // step 1.2 - update xcm by full step
+
+    if (!pstat_flag) {
+      xcm[ibody][0] += dtv * vcm[ibody][0];
+      xcm[ibody][1] += dtv * vcm[ibody][1];
+      xcm[ibody][2] += dtv * vcm[ibody][2];
+    } else {
+      xcm[ibody][0] += scale_v[0] * vcm[ibody][0];
+      xcm[ibody][1] += scale_v[1] * vcm[ibody][1];
+      xcm[ibody][2] += scale_v[2] * vcm[ibody][2];
+    }
+
+    // step 1.3 - apply torque (body coords) to quaternion momentum
+
+    torque[ibody][0] *= tflag[ibody][0];
+    torque[ibody][1] *= tflag[ibody][1];
+    torque[ibody][2] *= tflag[ibody][2];
+
+    MathExtra::transpose_matvec(ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                                torque[ibody],tbody);
+    MathExtra::quatvec(quat[ibody],tbody,fquat);
+
+    conjqm[ibody][0] += dtf2 * fquat[0];
+    conjqm[ibody][1] += dtf2 * fquat[1];
+    conjqm[ibody][2] += dtf2 * fquat[2];
+    conjqm[ibody][3] += dtf2 * fquat[3];
+
+    if (tstat_flag || pstat_flag) {
+      conjqm[ibody][0] *= scale_r;
+      conjqm[ibody][1] *= scale_r;
+      conjqm[ibody][2] *= scale_r;
+      conjqm[ibody][3] *= scale_r;
+    }
+
+    // step 1.4 to 1.13 - use no_squish rotate to update p and q
+
+    MathExtra::no_squish_rotate(3,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+    MathExtra::no_squish_rotate(2,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+    MathExtra::no_squish_rotate(1,conjqm[ibody],quat[ibody],inertia[ibody],dtv);
+    MathExtra::no_squish_rotate(2,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+    MathExtra::no_squish_rotate(3,conjqm[ibody],quat[ibody],inertia[ibody],dtq);
+
+    // update exyz_space
+    // transform p back to angmom
+    // update angular velocity
+
+    MathExtra::q_to_exyz(quat[ibody],ex_space[ibody],ey_space[ibody],
+                         ez_space[ibody]);
+    MathExtra::invquatvec(quat[ibody],conjqm[ibody],mbody);
+    MathExtra::matvec(ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                      mbody,angmom[ibody]);
+
+    angmom[ibody][0] *= 0.5;
+    angmom[ibody][1] *= 0.5;
+    angmom[ibody][2] *= 0.5;
+
+    MathExtra::angmom_to_omega(angmom[ibody],ex_space[ibody],ey_space[ibody],
+                               ez_space[ibody],inertia[ibody],omega[ibody]);
+
+    if (tstat_flag || pstat_flag) {
+      akin_r += angmom[ibody][0]*omega[ibody][0] +
+        angmom[ibody][1]*omega[ibody][1] + angmom[ibody][2]*omega[ibody][2];
+    }
+  }
+
+  // compute target temperature
+  // update thermostat chains using akin_t and akin_r
+  // refer to update_nhcp() in Kamberaj et al.
+
+  if (tstat_flag) {
+    compute_temp_target();
+    nhc_temp_integrate();
+  }
+
+  // update thermostat chains coupled with barostat
+  // refer to update_nhcb() in Kamberaj et al.
+
+  if (pstat_flag) {
+    nhc_press_integrate();
+  }
+
+  // virial setup before call to set_xv
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // remap simulation box by 1/2 step
+
+  if (pstat_flag) remap();
+
+  // set coords/orient and velocity/rotation of atoms in rigid bodies
+  // from quarternion and omega
+
+  set_xv();
+
+  // remap simulation box by full step
+  // redo KSpace coeffs since volume has changed
+
+  if (pstat_flag) {
+    remap();
+    if (kspace_flag) force->kspace->setup();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::final_integrate()
+{
+  int i,ibody;
+  double tmp,scale_t[3],scale_r;
+  double dtfm,xy,xz,yz;
+  double mbody[3],tbody[3],fquat[4];
+
+  double dtf2 = dtf * 2.0;
+
+  // compute scale variables
+
+  scale_t[0] = scale_t[1] = scale_t[2] = 1.0;
+  scale_r = 1.0;
+
+  if (tstat_flag) {
+    tmp = exp(-1.0 * dtq * eta_dot_t[0]);
+    scale_t[0] = scale_t[1] = scale_t[2] = tmp;
+    scale_r = exp(-1.0 * dtq * eta_dot_r[0]);
+  }
+
+  if (pstat_flag) {
+    scale_t[0] *= exp(-dtq * (epsilon_dot[0] + mtk_term2));
+    scale_t[1] *= exp(-dtq * (epsilon_dot[1] + mtk_term2));
+    scale_t[2] *= exp(-dtq * (epsilon_dot[2] + mtk_term2));
+    scale_r *= exp(-dtq * (pdim * mtk_term2));
+
+    // reset akin_t and akin_r, to be accumulated for use in nh_epsilon_dot()
+
+    akin_t = akin_r = 0.0;
+  }
+
+  // sum over atoms to get force and torque on rigid body
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int nlocal = atom->nlocal;
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+  if (triclinic) {
+    xy = domain->xy;
+    xz = domain->xz;
+    yz = domain->yz;
+  }
+
+  int xbox,ybox,zbox;
+  double xunwrap,yunwrap,zunwrap,dx,dy,dz;
+  for (ibody = 0; ibody < nbody; ibody++)
+    for (i = 0; i < 6; i++) sum[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (body[i] < 0) continue;
+    ibody = body[i];
+
+    sum[ibody][0] += f[i][0];
+    sum[ibody][1] += f[i][1];
+    sum[ibody][2] += f[i][2];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+    if (triclinic == 0) {
+      xunwrap = x[i][0] + xbox*xprd;
+      yunwrap = x[i][1] + ybox*yprd;
+      zunwrap = x[i][2] + zbox*zprd;
+    } else {
+      xunwrap = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+      yunwrap = x[i][1] + ybox*yprd + zbox*yz;
+      zunwrap = x[i][2] + zbox*zprd;
+    }
+
+    dx = xunwrap - xcm[ibody][0];
+    dy = yunwrap - xcm[ibody][1];
+    dz = zunwrap - xcm[ibody][2];
+
+    sum[ibody][3] += dy*f[i][2] - dz*f[i][1];
+    sum[ibody][4] += dz*f[i][0] - dx*f[i][2];
+    sum[ibody][5] += dx*f[i][1] - dy*f[i][0];
+  }
+
+  // extended particles add their torque to torque of body
+
+  if (extended) {
+    double **torque_one = atom->torque;
+
+    for (i = 0; i < nlocal; i++) {
+      if (body[i] < 0) continue;
+      ibody = body[i];
+
+      if (eflags[i] & TORQUE) {
+        sum[ibody][3] += torque_one[i][0];
+        sum[ibody][4] += torque_one[i][1];
+        sum[ibody][5] += torque_one[i][2];
+      }
+    }
+  }
+
+  MPI_Allreduce(sum[0],all[0],6*nbody,MPI_DOUBLE,MPI_SUM,world);
+
+  // update vcm and angmom
+  // include Langevin thermostat forces
+  // fflag,tflag = 0 for some dimensions in 2d
+
+  for (ibody = 0; ibody < nbody; ibody++) {
+    fcm[ibody][0] = all[ibody][0] + langextra[ibody][0];
+    fcm[ibody][1] = all[ibody][1] + langextra[ibody][1];
+    fcm[ibody][2] = all[ibody][2] + langextra[ibody][2];
+    torque[ibody][0] = all[ibody][3] + langextra[ibody][3];
+    torque[ibody][1] = all[ibody][4] + langextra[ibody][4];
+    torque[ibody][2] = all[ibody][5] + langextra[ibody][5];
+
+    // update vcm by 1/2 step
+
+    dtfm = dtf / masstotal[ibody];
+    if (tstat_flag || pstat_flag) {
+      vcm[ibody][0] *= scale_t[0];
+      vcm[ibody][1] *= scale_t[1];
+      vcm[ibody][2] *= scale_t[2];
+    }
+
+    vcm[ibody][0] += dtfm * fcm[ibody][0] * fflag[ibody][0];
+    vcm[ibody][1] += dtfm * fcm[ibody][1] * fflag[ibody][1];
+    vcm[ibody][2] += dtfm * fcm[ibody][2] * fflag[ibody][2];
+
+    if (pstat_flag) {
+      tmp = vcm[ibody][0]*vcm[ibody][0] + vcm[ibody][1]*vcm[ibody][1] +
+        vcm[ibody][2]*vcm[ibody][2];
+      akin_t += masstotal[ibody]*tmp;
+    }
+
+    // update conjqm, then transform to angmom, set velocity again
+    // virial is already setup from initial_integrate
+
+    torque[ibody][0] *= tflag[ibody][0];
+    torque[ibody][1] *= tflag[ibody][1];
+    torque[ibody][2] *= tflag[ibody][2];
+
+    MathExtra::transpose_matvec(ex_space[ibody],ey_space[ibody],
+                                ez_space[ibody],torque[ibody],tbody);
+    MathExtra::quatvec(quat[ibody],tbody,fquat);
+
+    if (tstat_flag || pstat_flag) {
+      conjqm[ibody][0] = scale_r * conjqm[ibody][0] + dtf2 * fquat[0];
+      conjqm[ibody][1] = scale_r * conjqm[ibody][1] + dtf2 * fquat[1];
+      conjqm[ibody][2] = scale_r * conjqm[ibody][2] + dtf2 * fquat[2];
+      conjqm[ibody][3] = scale_r * conjqm[ibody][3] + dtf2 * fquat[3];
+    } else {
+      conjqm[ibody][0] += dtf2 * fquat[0];
+      conjqm[ibody][1] += dtf2 * fquat[1];
+      conjqm[ibody][2] += dtf2 * fquat[2];
+      conjqm[ibody][3] += dtf2 * fquat[3];
+    }
+
+    MathExtra::invquatvec(quat[ibody],conjqm[ibody],mbody);
+    MathExtra::matvec(ex_space[ibody],ey_space[ibody],ez_space[ibody],
+                      mbody,angmom[ibody]);
+
+    angmom[ibody][0] *= 0.5;
+    angmom[ibody][1] *= 0.5;
+    angmom[ibody][2] *= 0.5;
+
+    MathExtra::angmom_to_omega(angmom[ibody],ex_space[ibody],ey_space[ibody],
+                               ez_space[ibody],inertia[ibody],omega[ibody]);
+
+    if (pstat_flag) {
+      akin_r += angmom[ibody][0]*omega[ibody][0] +
+        angmom[ibody][1]*omega[ibody][1] +
+        angmom[ibody][2]*omega[ibody][2];
+    }
+  }
+
+  // set velocity/rotation of atoms in rigid bodies
+  // virial is already setup from initial_integrate
+
+  set_v();
+
+  // compute current temperature
+  if (tcomputeflag) t_current = temperature->compute_scalar();
+
+  // compute current and target pressures
+  // update epsilon dot using akin_t and akin_r
+
+  if (pstat_flag) {
+    if (pstyle == ISO) {
+      temperature->compute_scalar();
+      pressure->compute_scalar();
+    } else {
+      temperature->compute_vector();
+      pressure->compute_vector();
+    }
+    couple();
+    pressure->addstep(update->ntimestep+1);
+
+    compute_press_target();
+
+    nh_epsilon_dot();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::nhc_temp_integrate()
+{
+  int i,j,k;
+  double kt,gfkt_t,gfkt_r,tmp,ms,s,s2;
+
+  kt = boltz * t_target;
+  gfkt_t = nf_t * kt;
+  gfkt_r = nf_r * kt;
+
+  // update thermostat masses
+
+  double t_mass = boltz * t_target / (t_freq * t_freq);
+  q_t[0] = nf_t * t_mass;
+  q_r[0] = nf_r * t_mass;
+  for (i = 1; i < t_chain; i++)
+    q_t[i] = q_r[i] = t_mass;
+
+  // update force of thermostats coupled to particles
+
+  f_eta_t[0] = (akin_t * mvv2e - gfkt_t) / q_t[0];
+  f_eta_r[0] = (akin_r * mvv2e - gfkt_r) / q_r[0];
+
+  // multiple timestep iteration
+
+  for (i = 0; i < t_iter; i++) {
+    for (j = 0; j < t_order; j++) {
+
+      // update thermostat velocities half step
+
+      eta_dot_t[t_chain-1] += wdti2[j] * f_eta_t[t_chain-1];
+      eta_dot_r[t_chain-1] += wdti2[j] * f_eta_r[t_chain-1];
+
+      for (k = 1; k < t_chain; k++) {
+        tmp = wdti4[j] * eta_dot_t[t_chain-k];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_t[t_chain-k-1] = eta_dot_t[t_chain-k-1] * s2 +
+          wdti2[j] * f_eta_t[t_chain-k-1] * s * ms;
+
+        tmp = wdti4[j] * eta_dot_r[t_chain-k];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_r[t_chain-k-1] = eta_dot_r[t_chain-k-1] * s2 +
+          wdti2[j] * f_eta_r[t_chain-k-1] * s * ms;
+      }
+
+      // update thermostat positions a full step
+
+      for (k = 0; k < t_chain; k++) {
+        eta_t[k] += wdti1[j] * eta_dot_t[k];
+        eta_r[k] += wdti1[j] * eta_dot_r[k];
+      }
+
+      // update thermostat forces
+
+      for (k = 1; k < t_chain; k++) {
+        f_eta_t[k] = q_t[k-1] * eta_dot_t[k-1] * eta_dot_t[k-1] - kt;
+        f_eta_t[k] /= q_t[k];
+        f_eta_r[k] = q_r[k-1] * eta_dot_r[k-1] * eta_dot_r[k-1] - kt;
+        f_eta_r[k] /= q_r[k];
+      }
+
+      // update thermostat velocities a full step
+
+      for (k = 0; k < t_chain-1; k++) {
+        tmp = wdti4[j] * eta_dot_t[k+1];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_t[k] = eta_dot_t[k] * s2 + wdti2[j] * f_eta_t[k] * s * ms;
+        tmp = q_t[k] * eta_dot_t[k] * eta_dot_t[k] - kt;
+        f_eta_t[k+1] = tmp / q_t[k+1];
+
+        tmp = wdti4[j] * eta_dot_r[k+1];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_r[k] = eta_dot_r[k] * s2 + wdti2[j] * f_eta_r[k] * s * ms;
+        tmp = q_r[k] * eta_dot_r[k] * eta_dot_r[k] - kt;
+        f_eta_r[k+1] = tmp / q_r[k+1];
+      }
+
+      eta_dot_t[t_chain-1] += wdti2[j] * f_eta_t[t_chain-1];
+      eta_dot_r[t_chain-1] += wdti2[j] * f_eta_r[t_chain-1];
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::nhc_press_integrate()
+{
+  int i,j,k;
+  double tmp,s,s2,ms,kecurrent;
+  double kt = boltz * t_target;
+  double lkt_press = kt;
+
+  // update thermostat masses
+
+  double tb_mass = kt / (p_freq_max * p_freq_max);
+  q_b[0] = dimension * dimension * tb_mass;
+  for (int i = 1; i < p_chain; i++) {
+    q_b[i] = tb_mass;
+    f_eta_b[i] = q_b[i-1] * eta_dot_b[i-1] * eta_dot_b[i-1] - kt;
+    f_eta_b[i] /= q_b[i];
+  }
+
+  // update forces acting on thermostat
+
+  kecurrent = 0.0;
+  for (i = 0; i < 3; i++)
+    if (p_flag[i]) {
+      epsilon_mass[i] = (g_f + dimension) * kt / (p_freq[i] * p_freq[i]);
+      kecurrent += epsilon_mass[i] * epsilon_dot[i] * epsilon_dot[i];
+    }
+  kecurrent /= pdim;
+
+  f_eta_b[0] = (kecurrent - lkt_press) / q_b[0];
+
+  // multiple timestep iteration
+
+  for (i = 0; i < t_iter; i++) {
+    for (j = 0; j < t_order; j++) {
+
+      // update thermostat velocities a half step
+
+      eta_dot_b[p_chain-1] += wdti2[j] * f_eta_b[p_chain-1];
+
+      for (k = 1; k < p_chain; k++) {
+        tmp = wdti4[j] * eta_dot_b[p_chain-k];
+        ms = maclaurin_series(tmp);
+        s = exp(-0.5 * tmp);
+        s2 = s * s;
+        eta_dot_b[p_chain-k-1] = eta_dot_b[p_chain-k-1] * s2 +
+          wdti2[j] * f_eta_b[p_chain-k-1] * s * ms;
+      }
+
+      // update thermostat positions
+
+      for (k = 0; k < p_chain; k++)
+        eta_b[k] += wdti1[j] * eta_dot_b[k];
+
+      // update thermostat forces
+
+      for (k = 1; k < p_chain; k++) {
+        f_eta_b[k] = q_b[k-1] * eta_dot_b[k-1] * eta_dot_b[k-1] - kt;
+        f_eta_b[k] /= q_b[k];
+      }
+
+      // update thermostat velocites a full step
+
+      for (k = 0; k < p_chain-1; k++) {
+        tmp = wdti4[j] * eta_dot_b[k+1];
+        ms = maclaurin_series(tmp);
+        s = exp(-0.5 * tmp);
+        s2 = s * s;
+        eta_dot_b[k] = eta_dot_b[k] * s2 + wdti2[j] * f_eta_b[k] * s * ms;
+        tmp = q_b[k] * eta_dot_b[k] * eta_dot_b[k] - kt;
+        f_eta_b[k+1] = tmp / q_b[k+1];
+      }
+
+      eta_dot_b[p_chain-1] += wdti2[j] * f_eta_b[p_chain-1];
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   compute kinetic energy in the extended Hamiltonian
+   conserved quantity = sum of returned energy and potential energy
+-----------------------------------------------------------------------*/
+
+double FixRigidNH::compute_scalar()
+{
+  const double kt = boltz * t_target;
+  double energy;
+  int i;
+
+  energy = FixRigid::compute_scalar();
+
+  if (tstat_flag) {
+
+    // thermostat chain energy: from equation 12 in Kameraj et al (JCP 2005)
+
+    energy += kt * (nf_t * eta_t[0] + nf_r * eta_r[0]);
+
+    for (i = 1; i < t_chain; i++)
+      energy += kt * (eta_t[i] + eta_r[i]);
+
+    for (i = 0;  i < t_chain; i++) {
+      energy += 0.5 * q_t[i] * (eta_dot_t[i] * eta_dot_t[i]);
+      energy += 0.5 * q_r[i] * (eta_dot_r[i] * eta_dot_r[i]);
+    }
+  }
+
+  if (pstat_flag) {
+
+    // using equation 22 in Kameraj et al for H_NPT
+
+    double e = 0.0;
+    for (i = 0; i < 3; i++)
+      if (p_flag[i])
+        e += epsilon_mass[i] * epsilon_dot[i] * epsilon_dot[i];
+    energy += e*(0.5/pdim);
+
+    double vol;
+    if (dimension == 2) vol = domain->xprd * domain->yprd;
+    else vol = domain->xprd * domain->yprd * domain->zprd;
+
+    double p0 = (p_target[0] + p_target[1] + p_target[2]) / 3.0;
+    energy += p0 * vol / nktv2p;
+
+    for (i = 0;  i < p_chain; i++) {
+      energy += kt * eta_b[i];
+      energy += 0.5 * q_b[i] * (eta_dot_b[i] * eta_dot_b[i]);
+    }
+  }
+
+  return energy;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::couple()
+{
+  double *tensor = pressure->vector;
+
+  if (pstyle == ISO) {
+    p_current[0] = p_current[1] = p_current[2] = pressure->scalar;
+  } else if (pcouple == XYZ) {
+    double ave = 1.0/3.0 * (tensor[0] + tensor[1] + tensor[2]);
+    p_current[0] = p_current[1] = p_current[2] = ave;
+  } else if (pcouple == XY) {
+    double ave = 0.5 * (tensor[0] + tensor[1]);
+    p_current[0] = p_current[1] = ave;
+    p_current[2] = tensor[2];
+  } else if (pcouple == YZ) {
+    double ave = 0.5 * (tensor[1] + tensor[2]);
+    p_current[1] = p_current[2] = ave;
+    p_current[0] = tensor[0];
+  } else if (pcouple == XZ) {
+    double ave = 0.5 * (tensor[0] + tensor[2]);
+    p_current[0] = p_current[2] = ave;
+    p_current[1] = tensor[1];
+  } else {
+    p_current[0] = tensor[0];
+    p_current[1] = tensor[1];
+    p_current[2] = tensor[2];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::remap()
+{
+  int i;
+  double oldlo,oldhi,ctr,expfac;
+
+  double **x = atom->x;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  // epsilon is not used, except for book-keeping
+
+  for (i = 0; i < 3; i++) epsilon[i] += dtq * epsilon_dot[i];
+
+  // convert pertinent atoms and rigid bodies to lamda coords
+
+  if (allremap) domain->x2lamda(nlocal);
+  else {
+    for (i = 0; i < nlocal; i++)
+      if (mask[i] & dilate_group_bit)
+        domain->x2lamda(x[i],x[i]);
+  }
+
+  if (nrigidfix)
+    for (i = 0; i < nrigidfix; i++)
+      modify->fix[rfix[i]]->deform(0);
+
+  // reset global and local box to new size/shape
+
+  for (i = 0; i < 3; i++) {
+    if (p_flag[i]) {
+      oldlo = domain->boxlo[i];
+      oldhi = domain->boxhi[i];
+      ctr = 0.5 * (oldlo + oldhi);
+      expfac = exp(dtq * epsilon_dot[i]);
+      domain->boxlo[i] = (oldlo-ctr)*expfac + ctr;
+      domain->boxhi[i] = (oldhi-ctr)*expfac + ctr;
+    }
+  }
+
+  domain->set_global_box();
+  domain->set_local_box();
+
+  // convert pertinent atoms and rigid bodies back to box coords
+
+  if (allremap) domain->lamda2x(nlocal);
+  else {
+    for (i = 0; i < nlocal; i++)
+      if (mask[i] & dilate_group_bit)
+        domain->lamda2x(x[i],x[i]);
+  }
+
+  if (nrigidfix)
+    for (i = 0; i< nrigidfix; i++)
+      modify->fix[rfix[i]]->deform(1);
+}
+
+/* ----------------------------------------------------------------------
+   compute target temperature and kinetic energy
+-----------------------------------------------------------------------*/
+
+void FixRigidNH::compute_temp_target()
+{
+  double delta = update->ntimestep - update->beginstep;
+  if (delta != 0.0) delta /= update->endstep - update->beginstep;
+
+  t_target = t_start + delta * (t_stop-t_start);
+}
+
+/* ----------------------------------------------------------------------
+   compute hydrostatic target pressure
+-----------------------------------------------------------------------*/
+
+void FixRigidNH::compute_press_target()
+{
+  double delta = update->ntimestep - update->beginstep;
+  if (delta != 0.0) delta /= update->endstep - update->beginstep;
+
+  p_hydro = 0.0;
+  for (int i = 0; i < 3; i++)
+    if (p_flag[i]) {
+      p_target[i] = p_start[i] + delta * (p_stop[i]-p_start[i]);
+      p_hydro += p_target[i];
+    }
+  p_hydro /= pdim;
+}
+
+/* ----------------------------------------------------------------------
+   update epsilon_dot
+-----------------------------------------------------------------------*/
+
+void FixRigidNH::nh_epsilon_dot()
+{
+  int i;
+  double volume,scale,f_epsilon;
+
+  if (dimension == 2) volume = domain->xprd*domain->yprd;
+  else volume = domain->xprd*domain->yprd*domain->zprd;
+
+  // MTK terms
+
+  mtk_term1 = (akin_t + akin_r) * mvv2e / g_f;
+
+  scale = exp(-1.0 * dtq * eta_dot_b[0]);
+
+  for (i = 0; i < 3; i++)
+    if (p_flag[i]) {
+      f_epsilon = (p_current[i]-p_hydro)*volume / nktv2p + mtk_term1;
+      f_epsilon /= epsilon_mass[i];
+      epsilon_dot[i] += dtq * f_epsilon;
+      epsilon_dot[i] *= scale;
+    }
+
+  mtk_term2 = 0.0;
+  for (i = 0; i < 3; i++)
+    if (p_flag[i]) mtk_term2 += epsilon_dot[i];
+  mtk_term2 /= g_f;
+}
+
+/* ----------------------------------------------------------------------
+   pack entire state of Fix into one write
+------------------------------------------------------------------------- */
+
+void FixRigidNH::write_restart(FILE *fp)
+{
+  if (tstat_flag == 0 && pstat_flag == 0) return;
+
+  int nsize = 2; // tstat_flag and pstat_flag
+
+  if (tstat_flag) {
+    nsize += 1;         // t_chain
+    nsize += 4*t_chain; // eta_t, eta_r, eta_dot_t, eta_dot_r
+  }
+
+  if (pstat_flag) {
+    nsize += 7;         // p_chain, epsilon(3) and epsilon_dot(3)
+    nsize += 2*p_chain;
+  }
+
+  double *list;
+  memory->create(list,nsize,"rigid_nh:list");
+
+  int n = 0;
+
+  list[n++] = tstat_flag;
+  if (tstat_flag) {
+    list[n++] = t_chain;
+    for (int i = 0; i < t_chain; i++) {
+      list[n++] = eta_t[i];
+      list[n++] = eta_r[i];
+      list[n++] = eta_dot_t[i];
+      list[n++] = eta_dot_r[i];
+    }
+  }
+
+  list[n++] = pstat_flag;
+  if (pstat_flag) {
+    list[n++] = epsilon[0];
+    list[n++] = epsilon[1];
+    list[n++] = epsilon[2];
+    list[n++] = epsilon_dot[0];
+    list[n++] = epsilon_dot[1];
+    list[n++] = epsilon_dot[2];
+
+    list[n++] = p_chain;
+    for (int i = 0; i < p_chain; i++) {
+      list[n++] = eta_b[i];
+      list[n++] = eta_dot_b[i];
+    }
+  }
+
+  if (comm->me == 0) {
+    int size = (nsize)*sizeof(double);
+    fwrite(&size,sizeof(int),1,fp);
+    fwrite(list,sizeof(double),nsize,fp);
+  }
+
+  memory->destroy(list);
+}
+
+/* ----------------------------------------------------------------------
+   use state info from restart file to restart the Fix
+------------------------------------------------------------------------- */
+
+void FixRigidNH::restart(char *buf)
+{
+  int n = 0;
+  double *list = (double *) buf;
+  int flag = static_cast<int> (list[n++]);
+
+  if (flag) {
+    int m = static_cast<int> (list[n++]);
+    if (tstat_flag && m == t_chain) {
+      for (int i = 0; i < t_chain; i++) {
+        eta_t[i] = list[n++];
+        eta_r[i] = list[n++];
+        eta_dot_t[i] = list[n++];
+        eta_dot_r[i] = list[n++];
+      }
+    } else n += 4*m;
+  }
+
+  flag = static_cast<int> (list[n++]);
+  if (flag) {
+    epsilon[0] = list[n++];
+    epsilon[1] = list[n++];
+    epsilon[2] = list[n++];
+    epsilon_dot[0] = list[n++];
+    epsilon_dot[1] = list[n++];
+    epsilon_dot[2] = list[n++];
+
+    int m = static_cast<int> (list[n++]);
+    if (pstat_flag && m == p_chain) {
+      for (int i = 0; i < p_chain; i++) {
+        eta_b[i] = list[n++];
+        eta_dot_b[i] = list[n++];
+      }
+    } else n += 2*m;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRigidNH::modify_param(int narg, char **arg)
+{
+  if (strcmp(arg[0],"temp") == 0) {
+    if (narg < 2) error->all(FLERR,"Illegal fix_modify command");
+    if (tcomputeflag) {
+      modify->delete_compute(id_temp);
+      tcomputeflag = 0;
+    }
+    delete [] id_temp;
+    int n = strlen(arg[1]) + 1;
+    id_temp = new char[n];
+    strcpy(id_temp,arg[1]);
+
+    int icompute = modify->find_compute(arg[1]);
+    if (icompute < 0)
+      error->all(FLERR,"Could not find fix_modify temperature ID");
+    temperature = modify->compute[icompute];
+
+    if (temperature->tempflag == 0)
+      error->all(FLERR,
+                 "Fix_modify temperature ID does not compute temperature");
+    if (temperature->igroup != 0 && comm->me == 0)
+      error->warning(FLERR,"Temperature for fix modify is not for group all");
+
+    // reset id_temp of pressure to new temperature ID
+
+    if (pstat_flag) {
+      icompute = modify->find_compute(id_press);
+      if (icompute < 0)
+        error->all(FLERR,"Pressure ID for fix modify does not exist");
+      modify->compute[icompute]->reset_extra_compute_fix(id_temp);
+    }
+
+    return 2;
+
+  } else if (strcmp(arg[0],"press") == 0) {
+    if (narg < 2) error->all(FLERR,"Illegal fix_modify command");
+    if (!pstat_flag) error->all(FLERR,"Illegal fix_modify command");
+    if (pcomputeflag) {
+      modify->delete_compute(id_press);
+      pcomputeflag = 0;
+    }
+    delete [] id_press;
+    int n = strlen(arg[1]) + 1;
+    id_press = new char[n];
+    strcpy(id_press,arg[1]);
+
+    int icompute = modify->find_compute(arg[1]);
+    if (icompute < 0) error->all(FLERR,"Could not find fix_modify pressure ID");
+    pressure = modify->compute[icompute];
+
+    if (pressure->pressflag == 0)
+      error->all(FLERR,"Fix_modify pressure ID does not compute pressure");
+    return 2;
+  }
+
+  return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::allocate_chain()
+{
+  if (tstat_flag) {
+    q_t = new double[t_chain];
+    q_r = new double[t_chain];
+    eta_t = new double[t_chain];
+    eta_r = new double[t_chain];
+    eta_dot_t = new double[t_chain];
+    eta_dot_r = new double[t_chain];
+    f_eta_t = new double[t_chain];
+    f_eta_r = new double[t_chain];
+  }
+
+  if (pstat_flag) {
+    q_b = new double[p_chain];
+    eta_b = new double[p_chain];
+    eta_dot_b = new double[p_chain];
+    f_eta_b = new double[p_chain];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::reset_target(double t_new)
+{
+  t_start = t_stop = t_new;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::allocate_order()
+{
+  w = new double[t_order];
+  wdti1 = new double[t_order];
+  wdti2 = new double[t_order];
+  wdti4 = new double[t_order];
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::deallocate_chain()
+{
+  if (tstat_flag) {
+    delete [] q_t;
+    delete [] q_r;
+    delete [] eta_t;
+    delete [] eta_r;
+    delete [] eta_dot_t;
+    delete [] eta_dot_r;
+    delete [] f_eta_t;
+    delete [] f_eta_r;
+  }
+
+  if (pstat_flag) {
+    delete [] q_b;
+    delete [] eta_b;
+    delete [] eta_dot_b;
+    delete [] f_eta_b;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNH::deallocate_order()
+{
+  delete [] w;
+  delete [] wdti1;
+  delete [] wdti2;
+  delete [] wdti4;
+}
+
diff -uN src/fix_rigid_nh.h src_DFT-CES2/fix_rigid_nh.h
--- src/fix_rigid_nh.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nh.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,179 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifndef LMP_FIX_RIGID_NH_H
+#define LMP_FIX_RIGID_NH_H
+
+#include "fix_rigid.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNH : public FixRigid {
+ public:
+  FixRigidNH(class LAMMPS *, int, char **);
+  virtual ~FixRigidNH();
+  virtual int setmask();
+  virtual void init();
+  virtual void setup(int);
+  virtual void initial_integrate(int);
+  virtual void final_integrate();
+  virtual double compute_scalar();
+  int modify_param(int, char **);
+  void write_restart(FILE *);
+  void restart(char *buf);
+  void reset_target(double);
+
+ protected:
+  double **conjqm;                    // conjugate quaternion momentum
+  double boltz,nktv2p,mvv2e;          // boltzman constant, conversion factors
+
+  int nf_t,nf_r;                      // trans/rot degrees of freedom
+  double onednft,onednfr;             // factors 1 + dimension/trans(rot)
+                                      //   degrees of freedom
+  double *w,*wdti1,*wdti2,*wdti4;     // Yoshida-Suzuki coefficients
+  double *q_t,*q_r;                   // trans/rot thermostat masses
+  double *eta_t,*eta_r;               // trans/rot thermostat positions
+  double *eta_dot_t,*eta_dot_r;       // trans/rot thermostat velocities
+  double *f_eta_t,*f_eta_r;           // trans/rot thermostat forces
+
+  double epsilon_mass[3], *q_b;       // baro/thermo masses
+  double epsilon[3],*eta_b;           // baro/thermo positions
+  double epsilon_dot[3],*eta_dot_b;   // baro/thermo velocities
+  double *f_eta_b;                    // thermo forces
+  double akin_t,akin_r;               // translational/rotational kinetic energies
+
+  int kspace_flag;                    // 1 if KSpace invoked, 0 if not
+  int nrigidfix;                      // number of rigid fixes
+  int *rfix;                          // indicies of rigid fixes
+
+  double vol0;                        // reference volume
+  double t0;                          // reference temperature
+  int pdim,g_f;                       // number of barostatted dims, total DoFs
+  double p_hydro;                     // hydrostatic target pressure
+  double p_freq_max;                  // maximum barostat frequency
+
+  double mtk_term1,mtk_term2;         // Martyna-Tobias-Klein corrections
+
+  double t_current,t_target;
+  double p_current[3],p_target[3];
+
+  char *id_temp,*id_press;
+  class Compute *temperature,*pressure;
+  int tcomputeflag,pcomputeflag;      // 1 = compute was created by fix. 0 = external
+
+  void couple();
+  void remap();
+  void nhc_temp_integrate();
+  void nhc_press_integrate();
+
+  virtual void compute_temp_target();
+  void compute_press_target();
+  void nh_epsilon_dot();
+
+  void allocate_chain();
+  void allocate_order();
+  void deallocate_chain();
+  void deallocate_order();
+
+  inline double maclaurin_series(double);
+};
+
+inline double FixRigidNH::maclaurin_series(double x)
+{
+  double x2,x4;
+  x2 = x * x;
+  x4 = x2 * x2;
+  return (1.0 + (1.0/6.0) * x2 + (1.0/120.0) * x4 + (1.0/5040.0) * x2 * x4 +
+         (1.0/362880.0) * x4 * x4);
+}
+
+}
+
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Fix rigid npt/nph period must be > 0.0
+
+Self-explanatory.
+
+E: Invalid fix rigid npt/nph command for a 2d simulation
+
+Cannot control z dimension in a 2d model.
+
+E: Invalid fix rigid npt/nph command pressure settings
+
+If multiple dimensions are coupled, those dimensions must be
+specified.
+
+E: Cannot use fix rigid npt/nph on a non-periodic dimension
+
+When specifying a diagonal pressure component, the dimension must be
+periodic.
+
+E: Fix rigid nvt/npt/nph damping parameters must be > 0.0
+
+Self-explanatory.
+
+E: Fix rigid npt/nph dilate group ID does not exist
+
+Self-explanatory.
+
+E: Temperature ID for fix rigid nvt/npt/nph does not exist
+
+Self-explanatory.
+
+E: Fix rigid npt/nph does not yet allow triclinic box
+
+This is a current restriction in LAMMPS.
+
+E: Cannot use fix rigid npt/nph and fix deform on same component of stress tensor
+
+This would be changing the same box dimension twice.
+
+E: Pressure ID for fix rigid npt/nph does not exist
+
+Self-explanatory.
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Could not find fix_modify temperature ID
+
+The compute ID for computing temperature does not exist.
+
+E: Fix_modify temperature ID does not compute temperature
+
+The compute ID assigned to the fix must compute temperature.
+
+W: Temperature for fix modify is not for group all
+
+The temperature compute is being used with a pressure calculation
+which does operate on group all, so this may be inconsistent.
+
+E: Pressure ID for fix modify does not exist
+
+Self-explanatory.
+
+E: Could not find fix_modify pressure ID
+
+The compute ID for computing pressure does not exist.
+
+E: Fix_modify pressure ID does not compute pressure
+
+The compute ID assigned to the fix must compute pressure.
+
+*/
diff -uN src/fix_rigid_nh_small.cpp src_DFT-CES2/fix_rigid_nh_small.cpp
--- src/fix_rigid_nh_small.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nh_small.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,1517 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Trung Dac Nguyen (ORNL)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdio.h>
+#include <string.h>
+#include "fix_rigid_nh_small.h"
+#include "math_extra.h"
+#include "atom.h"
+#include "compute.h"
+#include "domain.h"
+#include "update.h"
+#include "modify.h"
+#include "fix_deform.h"
+#include "group.h"
+#include "comm.h"
+#include "force.h"
+#include "kspace.h"
+#include "output.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathExtra;
+
+enum{NONE,XYZ,XY,YZ,XZ};     // same as in FixRigid
+enum{ISO,ANISO,TRICLINIC};   // same as in FixRigid
+
+#define EPSILON 1.0e-7
+
+enum{FULL_BODY,INITIAL,FINAL,FORCE_TORQUE,VCM_ANGMOM,XCM_MASS,ITENSOR,DOF};
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNHSmall::FixRigidNHSmall(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidSmall(lmp, narg, arg), w(NULL), wdti1(NULL), 
+  wdti2(NULL), wdti4(NULL), q_t(NULL), q_r(NULL), eta_t(NULL), 
+  eta_r(NULL), eta_dot_t(NULL), eta_dot_r(NULL), f_eta_t(NULL), 
+  f_eta_r(NULL), q_b(NULL), eta_b(NULL), eta_dot_b(NULL), 
+  f_eta_b(NULL), rfix(NULL), id_temp(NULL), id_press(NULL), 
+  temperature(NULL), pressure(NULL)
+{
+  // error checks
+
+  if ((p_flag[0] == 1 && p_period[0] <= 0.0) ||
+      (p_flag[1] == 1 && p_period[1] <= 0.0) ||
+      (p_flag[2] == 1 && p_period[2] <= 0.0))
+    error->all(FLERR,"Fix rigid/small npt/nph period must be > 0.0");
+
+  dimension = domain->dimension;
+
+  if (dimension == 2 && p_flag[2])
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command "
+               "for a 2d simulation");
+  if (dimension == 2 && (pcouple == YZ || pcouple == XZ))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command "
+               "for a 2d simulation");
+
+  if (pcouple == XYZ && (p_flag[0] == 0 || p_flag[1] == 0))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command "
+               "pressure settings");
+  if (pcouple == XYZ && dimension == 3 && p_flag[2] == 0)
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command "
+               "pressure settings");
+  if (pcouple == XY && (p_flag[0] == 0 || p_flag[1] == 0))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command "
+               "pressure settings");
+  if (pcouple == YZ && (p_flag[1] == 0 || p_flag[2] == 0))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command "
+               "pressure settings");
+  if (pcouple == XZ && (p_flag[0] == 0 || p_flag[2] == 0))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command "
+               "pressure settings");
+
+  // require periodicity in tensile dimension
+
+  if (p_flag[0] && domain->xperiodic == 0)
+    error->all(FLERR,
+               "Cannot use fix rigid/small npt/nph on a "
+               "non-periodic dimension");
+  if (p_flag[1] && domain->yperiodic == 0)
+    error->all(FLERR,
+               "Cannot use fix rigid/small npt/nph on a "
+               "non-periodic dimension");
+  if (p_flag[2] && domain->zperiodic == 0)
+    error->all(FLERR,
+               "Cannot use fix rigid/small npt/nph on a "
+               "non-periodic dimension");
+
+  if (pcouple == XYZ && dimension == 3 &&
+      (p_start[0] != p_start[1] || p_start[0] != p_start[2] ||
+       p_stop[0] != p_stop[1] || p_stop[0] != p_stop[2] ||
+       p_period[0] != p_period[1] || p_period[0] != p_period[2]))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command pressure settings");
+  if (pcouple == XYZ && dimension == 2 &&
+      (p_start[0] != p_start[1] || p_stop[0] != p_stop[1] ||
+       p_period[0] != p_period[1]))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command pressure settings");
+  if (pcouple == XY &&
+      (p_start[0] != p_start[1] || p_stop[0] != p_stop[1] ||
+       p_period[0] != p_period[1]))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command pressure settings");
+  if (pcouple == YZ &&
+      (p_start[1] != p_start[2] || p_stop[1] != p_stop[2] ||
+       p_period[1] != p_period[2]))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command pressure settings");
+  if (pcouple == XZ &&
+      (p_start[0] != p_start[2] || p_stop[0] != p_stop[2] ||
+       p_period[0] != p_period[2]))
+    error->all(FLERR,"Invalid fix rigid/small npt/nph command pressure settings");
+
+  if ((tstat_flag && t_period <= 0.0) ||
+      (p_flag[0] && p_period[0] <= 0.0) ||
+      (p_flag[1] && p_period[1] <= 0.0) ||
+      (p_flag[2] && p_period[2] <= 0.0))
+    error->all(FLERR,"Fix rigid/small nvt/npt/nph damping parameters "
+               "must be > 0.0");
+
+  // memory allocation and initialization
+
+  if (tstat_flag || pstat_flag) {
+    allocate_chain();
+    allocate_order();
+  }
+
+  if (tstat_flag) {
+    eta_t[0] = eta_r[0] = 0.0;
+    eta_dot_t[0] = eta_dot_r[0] = 0.0;
+    f_eta_t[0] = f_eta_r[0] = 0.0;
+
+    for (int i = 1; i < t_chain; i++) {
+      eta_t[i] = eta_r[i] = 0.0;
+      eta_dot_t[i] = eta_dot_r[i] = 0.0;
+    }
+  }
+
+  if (pstat_flag) {
+    epsilon_dot[0] = epsilon_dot[1] = epsilon_dot[2] = 0.0;
+    eta_b[0] = eta_dot_b[0] = f_eta_b[0] = 0.0;
+    for (int i = 1; i < p_chain; i++)
+      eta_b[i] = eta_dot_b[i] = 0.0;
+  }
+
+  // rigid body pointers
+
+  nrigidfix = 0;
+  rfix = NULL;
+
+  vol0 = 0.0;
+  t0 = 1.0;
+
+  tcomputeflag = 0;
+  pcomputeflag = 0;
+
+  id_temp = NULL;
+  id_press = NULL;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNHSmall::~FixRigidNHSmall()
+{
+  if (tstat_flag || pstat_flag) {
+    deallocate_chain();
+    deallocate_order();
+  }
+
+  if (rfix) delete [] rfix;
+
+  if (tcomputeflag) modify->delete_compute(id_temp);
+  delete [] id_temp;
+
+  // delete pressure if fix created it
+
+  if (pstat_flag) {
+    if (pcomputeflag) modify->delete_compute(id_press);
+    delete [] id_press;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRigidNHSmall::setmask()
+{
+  int mask = 0;
+  mask = FixRigidSmall::setmask();
+  if (tstat_flag || pstat_flag) mask |= THERMO_ENERGY;
+
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::init()
+{
+  FixRigidSmall::init();
+
+  // recheck that dilate group has not been deleted
+
+  if (allremap == 0) {
+    int idilate = group->find(id_dilate);
+    if (idilate == -1)
+      error->all(FLERR,"Fix rigid npt/nph dilate group ID does not exist");
+    dilate_group_bit = group->bitmask[idilate];
+  }
+
+  // initialize thermostats
+  // set timesteps, constants
+  // store Yoshida-Suzuki integrator parameters
+
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+  dtq = 0.5 * update->dt;
+
+  boltz = force->boltz;
+  nktv2p = force->nktv2p;
+  mvv2e = force->mvv2e;
+
+  if (force->kspace) kspace_flag = 1;
+  else kspace_flag = 0;
+
+  // see Table 1 in Kamberaj et al
+
+  if (tstat_flag || pstat_flag) {
+    if (t_order == 3) {
+      w[0] = 1.0 / (2.0 - pow(2.0, 1.0/3.0));
+      w[1] = 1.0 - 2.0*w[0];
+      w[2] = w[0];
+    } else if (t_order == 5) {
+      w[0] = 1.0 / (4.0 - pow(4.0, 1.0/3.0));
+      w[1] = w[0];
+      w[2] = 1.0 - 4.0 * w[0];
+      w[3] = w[0];
+      w[4] = w[0];
+    }
+  }
+
+  int icompute;
+  if (tcomputeflag) {
+    icompute = modify->find_compute(id_temp);
+    if (icompute < 0)
+      error->all(FLERR,"Temperature ID for fix rigid nvt/npt/nph does not exist");
+    temperature = modify->compute[icompute];
+  }
+
+  if (pstat_flag) {
+    if (domain->triclinic)
+      error->all(FLERR,"Fix rigid npt/nph does not yet allow triclinic box");
+
+    // ensure no conflict with fix deform
+
+    for (int i = 0; i < modify->nfix; i++)
+      if (strcmp(modify->fix[i]->style,"deform") == 0) {
+      	int *dimflag = ((FixDeform *) modify->fix[i])->dimflag;
+      	if ((p_flag[0] && dimflag[0]) || (p_flag[1] && dimflag[1]) ||
+      	    (p_flag[2] && dimflag[2]))
+          error->all(FLERR,"Cannot use fix rigid npt/nph and fix deform on "
+                     "same component of stress tensor");
+      }
+
+    // set frequency
+
+    p_freq_max = 0.0;
+    p_freq_max = MAX(p_freq[0],p_freq[1]);
+    p_freq_max = MAX(p_freq_max,p_freq[2]);
+
+    // tally the number of dimensions that are barostatted
+    // set initial volume and reference cell, if not already done
+
+    pdim = p_flag[0] + p_flag[1] + p_flag[2];
+    if (vol0 == 0.0) {
+      if (dimension == 2) vol0 = domain->xprd * domain->yprd;
+      else vol0 = domain->xprd * domain->yprd * domain->zprd;
+    }
+
+    // set pressure compute ptr
+
+    icompute = modify->find_compute(id_press);
+    if (icompute < 0)
+      error->all(FLERR,"Pressure ID for fix rigid npt/nph does not exist");
+    pressure = modify->compute[icompute];
+
+    // detect if any rigid fixes exist so rigid bodies move on remap
+    // rfix[] = indices to each fix rigid
+    // this will include self
+
+    if (rfix) delete [] rfix;
+    nrigidfix = 0;
+    rfix = NULL;
+
+    for (int i = 0; i < modify->nfix; i++)
+      if (modify->fix[i]->rigid_flag) nrigidfix++;
+    if (nrigidfix) {
+      rfix = new int[nrigidfix];
+      nrigidfix = 0;
+      for (int i = 0; i < modify->nfix; i++)
+        if (modify->fix[i]->rigid_flag) rfix[nrigidfix++] = i;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::setup(int vflag)
+{
+  FixRigidSmall::setup(vflag);
+  compute_dof();
+  
+  double mbody[3];
+  akin_t = akin_r = 0.0;
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    Body *b = &body[ibody];
+    MathExtra::transpose_matvec(b->ex_space,b->ey_space,b->ez_space,
+                                b->angmom,mbody);
+    MathExtra::quatvec(b->quat,mbody,b->conjqm);
+    b->conjqm[0] *= 2.0;
+    b->conjqm[1] *= 2.0;
+    b->conjqm[2] *= 2.0;
+    b->conjqm[3] *= 2.0;
+
+    if (tstat_flag || pstat_flag) {
+      akin_t += b->mass*(b->vcm[0]*b->vcm[0] + b->vcm[1]*b->vcm[1] +
+        b->vcm[2]*b->vcm[2]);
+      akin_r += b->angmom[0]*b->omega[0] + b->angmom[1]*b->omega[1] +
+        b->angmom[2]*b->omega[2];
+    }
+  }
+
+  // accumulate translational and rotational kinetic energies
+
+  if (tstat_flag || pstat_flag) {
+    double ke[2],keall[2];
+    ke[0] = akin_t;
+    ke[1] = akin_r;
+    MPI_Allreduce(ke,keall,2,MPI_DOUBLE,MPI_SUM,world);
+    akin_t = keall[0];
+    akin_r = keall[1];
+  }
+
+  // compute target temperature
+
+  if (tstat_flag) compute_temp_target();
+  else if (pstat_flag) {
+    t0 = temperature->compute_scalar();
+    if (t0 == 0.0) {
+      if (strcmp(update->unit_style,"lj") == 0) t0 = 1.0;
+      else t0 = 300.0;
+    }
+    t_target = t0;
+  }
+
+  // compute target pressure
+  // compute current pressure
+  // trigger virial computation on next timestep
+
+  if (pstat_flag) {
+    compute_press_target();
+
+    if (pstyle == ISO) {
+      temperature->compute_scalar();
+      pressure->compute_scalar();
+    } else {
+      temperature->compute_vector();
+      pressure->compute_vector();
+    }
+
+    couple();
+    pressure->addstep(update->ntimestep+1);
+  }
+
+  // initialize thermostat/barostat settings
+
+  double kt, t_mass, tb_mass;
+  kt = boltz * t_target;
+
+  if (tstat_flag) {
+    t_mass = kt / (t_freq*t_freq);
+    q_t[0] = nf_t * t_mass;
+    q_r[0] = nf_r * t_mass;
+    for (int i = 1; i < t_chain; i++)
+      q_t[i] = q_r[i] = t_mass;
+
+    for (int i = 1; i < t_chain; i++) {
+      f_eta_t[i] = (q_t[i-1] * eta_dot_t[i-1] * eta_dot_t[i-1] - kt)/q_t[i];
+      f_eta_r[i] = (q_r[i-1] * eta_dot_r[i-1] * eta_dot_r[i-1] - kt)/q_r[i];
+    }
+  }
+
+  // initial forces on barostat thermostat variables
+
+  if (pstat_flag) {
+    for (int i = 0; i < 3; i++)
+      if (p_flag[i]) {
+        epsilon_mass[i] = (g_f + dimension) * kt / (p_freq[i]*p_freq[i]);
+        epsilon[i] = log(vol0)/dimension;
+      }
+
+    tb_mass = kt / (p_freq_max * p_freq_max);
+    q_b[0] = dimension * dimension * tb_mass;
+    for (int i = 1; i < p_chain; i++) {
+      q_b[i] = tb_mass;
+      f_eta_b[i] = (q_b[i] * eta_dot_b[i-1] * eta_dot_b[i-1] - kt)/q_b[i];
+    }
+  }
+
+  // update order/timestep dependent coefficients
+
+  if (tstat_flag || pstat_flag) {
+    for (int i = 0; i < t_order; i++) {
+      wdti1[i] = w[i] * dtv / t_iter;
+      wdti2[i] = wdti1[i] / 2.0;
+      wdti4[i] = wdti1[i] / 4.0;
+    }
+  }
+
+  if (pstat_flag) {
+    compute_press_target();
+    nh_epsilon_dot();
+  }
+}
+
+/* ----------------------------------------------------------------------
+   perform preforce velocity Verlet integration
+   see Kamberaj paper for step references
+------------------------------------------------------------------------- */
+
+void FixRigidNHSmall::initial_integrate(int vflag)
+{
+  double tmp,scale_r,scale_t[3],scale_v[3];
+  double dtfm,mbody[3],tbody[3],fquat[4];
+  double dtf2 = dtf * 2.0;
+
+  // compute scale variables
+
+  scale_t[0] = scale_t[1] = scale_t[2] = 1.0;
+  scale_v[0] = scale_v[1] = scale_v[2] = 1.0;
+  scale_r = 1.0;
+
+  if (tstat_flag) {
+    tmp = exp(-dtq * eta_dot_t[0]);
+    scale_t[0] = scale_t[1] = scale_t[2] = tmp;
+    tmp = exp(-dtq * eta_dot_r[0]);
+    scale_r = tmp;
+  }
+
+  if (pstat_flag) {
+    scale_t[0] *= exp(-dtq * (epsilon_dot[0] + mtk_term2));
+    scale_t[1] *= exp(-dtq * (epsilon_dot[1] + mtk_term2));
+    scale_t[2] *= exp(-dtq * (epsilon_dot[2] + mtk_term2));
+    scale_r *= exp(-dtq * (pdim * mtk_term2));
+
+    tmp = dtq * epsilon_dot[0];
+    scale_v[0] = dtv * exp(tmp) * maclaurin_series(tmp);
+    tmp = dtq * epsilon_dot[1];
+    scale_v[1] = dtv * exp(tmp) * maclaurin_series(tmp);
+    tmp = dtq * epsilon_dot[2];
+    scale_v[2] = dtv * exp(tmp) * maclaurin_series(tmp);
+  }
+
+  // update xcm, vcm, quat, conjqm and angmom
+
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    Body *b = &body[ibody];
+
+    // step 1.1 - update vcm by 1/2 step
+
+    dtfm = dtf / b->mass;
+    b->vcm[0] += dtfm * b->fcm[0];
+    b->vcm[1] += dtfm * b->fcm[1];
+    b->vcm[2] += dtfm * b->fcm[2];
+
+    if (tstat_flag || pstat_flag) {
+      b->vcm[0] *= scale_t[0];
+      b->vcm[1] *= scale_t[1];
+      b->vcm[2] *= scale_t[2];
+    }
+
+    // step 1.2 - update xcm by full step
+
+    if (!pstat_flag) {
+      b->xcm[0] += dtv * b->vcm[0];
+      b->xcm[1] += dtv * b->vcm[1];
+      b->xcm[2] += dtv * b->vcm[2];
+    } else {
+      b->xcm[0] += scale_v[0] * b->vcm[0];
+      b->xcm[1] += scale_v[1] * b->vcm[1];
+      b->xcm[2] += scale_v[2] * b->vcm[2];
+    }
+
+    // step 1.3 - apply torque (body coords) to quaternion momentum
+
+    MathExtra::transpose_matvec(b->ex_space,b->ey_space,b->ez_space,
+                                b->torque,tbody);
+    MathExtra::quatvec(b->quat,tbody,fquat);
+
+    b->conjqm[0] += dtf2 * fquat[0];
+    b->conjqm[1] += dtf2 * fquat[1];
+    b->conjqm[2] += dtf2 * fquat[2];
+    b->conjqm[3] += dtf2 * fquat[3];
+
+    if (tstat_flag || pstat_flag) {
+      b->conjqm[0] *= scale_r;
+      b->conjqm[1] *= scale_r;
+      b->conjqm[2] *= scale_r;
+      b->conjqm[3] *= scale_r;
+    }
+
+    // step 1.4 to 1.13 - use no_squish rotate to update p and q
+
+    no_squish_rotate(3,b->conjqm,b->quat,b->inertia,dtq);
+    no_squish_rotate(2,b->conjqm,b->quat,b->inertia,dtq);
+    no_squish_rotate(1,b->conjqm,b->quat,b->inertia,dtv);
+    no_squish_rotate(2,b->conjqm,b->quat,b->inertia,dtq);
+    no_squish_rotate(3,b->conjqm,b->quat,b->inertia,dtq);
+
+    // update exyz_space
+    // transform p back to angmom
+    // update angular velocity
+
+    MathExtra::q_to_exyz(b->quat,b->ex_space,b->ey_space,
+                         b->ez_space);
+    MathExtra::invquatvec(b->quat,b->conjqm,mbody);
+    MathExtra::matvec(b->ex_space,b->ey_space,b->ez_space,
+                      mbody,b->angmom);
+
+    b->angmom[0] *= 0.5;
+    b->angmom[1] *= 0.5;
+    b->angmom[2] *= 0.5;
+
+    MathExtra::angmom_to_omega(b->angmom,b->ex_space,b->ey_space,
+                               b->ez_space,b->inertia,b->omega);
+  }
+
+  // forward communicate updated info of all bodies
+
+  commflag = INITIAL;
+  comm->forward_comm_fix(this,26);
+
+  // accumulate translational and rotational kinetic energies
+
+  if (tstat_flag || pstat_flag) {
+
+    akin_t = akin_r = 0.0;
+    for (int ibody = 0; ibody < nlocal_body; ibody++) {
+      Body *b = &body[ibody];
+      akin_t += b->mass*(b->vcm[0]*b->vcm[0] + b->vcm[1]*b->vcm[1] +
+        b->vcm[2]*b->vcm[2]);
+      akin_r += b->angmom[0]*b->omega[0] + b->angmom[1]*b->omega[1] +
+        b->angmom[2]*b->omega[2];
+    }
+
+    double ke[2],keall[2];
+    ke[0] = akin_t;
+    ke[1] = akin_r;
+    MPI_Allreduce(ke,keall,2,MPI_DOUBLE,MPI_SUM,world);
+    akin_t = keall[0];
+    akin_r = keall[1];
+  }
+
+  // compute target temperature
+  // update thermostat chains using akin_t and akin_r
+  // refer to update_nhcp() in Kamberaj et al.
+
+  if (tstat_flag) {
+    compute_temp_target();
+    if (dynamic) compute_dof();
+    nhc_temp_integrate();
+  }
+
+  // update thermostat chains coupled with barostat
+  // refer to update_nhcb() in Kamberaj et al.
+
+  if (pstat_flag) {
+    nhc_press_integrate();
+  }
+
+  // virial setup before call to set_xv
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // remap simulation box by 1/2 step
+
+  if (pstat_flag) remap();
+
+  // set coords/orient and velocity/rotation of atoms in rigid bodies
+  // from quarternion and omega
+
+  set_xv();
+
+  // remap simulation box by full step
+  // redo KSpace coeffs since volume has changed
+
+  if (pstat_flag) {
+    remap();
+    if (kspace_flag) force->kspace->setup();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::final_integrate()
+{
+  int i,ibody;
+  double tmp,scale_t[3],scale_r;
+  double dtfm;
+  double mbody[3],tbody[3],fquat[4];
+
+  double dtf2 = dtf * 2.0;
+
+  // compute scale variables
+
+  scale_t[0] = scale_t[1] = scale_t[2] = 1.0;
+  scale_r = 1.0;
+
+  if (tstat_flag) {
+    tmp = exp(-1.0 * dtq * eta_dot_t[0]);
+    scale_t[0] = scale_t[1] = scale_t[2] = tmp;
+    scale_r = exp(-1.0 * dtq * eta_dot_r[0]);
+  }
+
+  if (pstat_flag) {
+    scale_t[0] *= exp(-dtq * (epsilon_dot[0] + mtk_term2));
+    scale_t[1] *= exp(-dtq * (epsilon_dot[1] + mtk_term2));
+    scale_t[2] *= exp(-dtq * (epsilon_dot[2] + mtk_term2));
+    scale_r *= exp(-dtq * (pdim * mtk_term2));
+  }
+
+  // sum over atoms to get force and torque on rigid body
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int nlocal = atom->nlocal;
+
+  double dx,dy,dz;
+  double unwrap[3];
+  double *xcm,*fcm,*tcm;
+
+  for (ibody = 0; ibody < nlocal_body+nghost_body; ibody++) {
+    fcm = body[ibody].fcm;
+    fcm[0] = fcm[1] = fcm[2] = 0.0;
+    tcm = body[ibody].torque;
+    tcm[0] = tcm[1] = tcm[2] = 0.0;
+  }
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    fcm = b->fcm;
+    fcm[0] += f[i][0];
+    fcm[1] += f[i][1];
+    fcm[2] += f[i][2];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    xcm = b->xcm;
+    dx = unwrap[0] - xcm[0];
+    dy = unwrap[1] - xcm[1];
+    dz = unwrap[2] - xcm[2];
+
+    tcm = b->torque;
+    tcm[0] += dy*f[i][2] - dz*f[i][1];
+    tcm[1] += dz*f[i][0] - dx*f[i][2];
+    tcm[2] += dx*f[i][1] - dy*f[i][0];
+  }
+
+  // extended particles add their torque to torque of body
+
+  if (extended) {
+    double **torque = atom->torque;
+
+    for (i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+
+      if (eflags[i] & TORQUE) {
+        tcm = body[atom2body[i]].torque;
+        tcm[0] += torque[i][0];
+        tcm[1] += torque[i][1];
+        tcm[2] += torque[i][2];
+      }
+    }
+  }
+
+  // reverse communicate fcm, torque of all bodies
+
+  commflag = FORCE_TORQUE;
+  comm->reverse_comm_fix(this,6);
+
+  // include Langevin thermostat forces and torques
+
+  if (langflag) {
+    for (int ibody = 0; ibody < nlocal_body; ibody++) {
+      fcm = body[ibody].fcm;
+      fcm[0] += langextra[ibody][0];
+      fcm[1] += langextra[ibody][1];
+      fcm[2] += langextra[ibody][2];
+      tcm = body[ibody].torque;
+      tcm[0] += langextra[ibody][3];
+      tcm[1] += langextra[ibody][4];
+      tcm[2] += langextra[ibody][5];
+    }
+  }
+
+  // update vcm and angmom
+  // include Langevin thermostat forces
+  // fflag,tflag = 0 for some dimensions in 2d
+
+  for (ibody = 0; ibody < nlocal_body; ibody++) {
+    Body *b = &body[ibody];
+
+    // update vcm by 1/2 step
+
+    dtfm = dtf / b->mass;
+    if (tstat_flag || pstat_flag) {
+      b->vcm[0] *= scale_t[0];
+      b->vcm[1] *= scale_t[1];
+      b->vcm[2] *= scale_t[2];
+    }
+
+    b->vcm[0] += dtfm * b->fcm[0];
+    b->vcm[1] += dtfm * b->fcm[1];
+    b->vcm[2] += dtfm * b->fcm[2];
+
+    // update conjqm, then transform to angmom, set velocity again
+    // virial is already setup from initial_integrate
+
+    MathExtra::transpose_matvec(b->ex_space,b->ey_space,
+                                b->ez_space,b->torque,tbody);
+    MathExtra::quatvec(b->quat,tbody,fquat);
+
+    if (tstat_flag || pstat_flag) {
+      b->conjqm[0] = scale_r * b->conjqm[0] + dtf2 * fquat[0];
+      b->conjqm[1] = scale_r * b->conjqm[1] + dtf2 * fquat[1];
+      b->conjqm[2] = scale_r * b->conjqm[2] + dtf2 * fquat[2];
+      b->conjqm[3] = scale_r * b->conjqm[3] + dtf2 * fquat[3];
+    } else {
+      b->conjqm[0] += dtf2 * fquat[0];
+      b->conjqm[1] += dtf2 * fquat[1];
+      b->conjqm[2] += dtf2 * fquat[2];
+      b->conjqm[3] += dtf2 * fquat[3];
+    }
+
+    MathExtra::invquatvec(b->quat,b->conjqm,mbody);
+    MathExtra::matvec(b->ex_space,b->ey_space,b->ez_space,mbody,b->angmom);
+
+    b->angmom[0] *= 0.5;
+    b->angmom[1] *= 0.5;
+    b->angmom[2] *= 0.5;
+
+    MathExtra::angmom_to_omega(b->angmom,b->ex_space,b->ey_space,
+                               b->ez_space,b->inertia,b->omega);
+  }
+
+  // forward communicate updated info of all bodies
+
+  commflag = FINAL;
+  comm->forward_comm_fix(this,10);
+
+  // accumulate translational and rotational kinetic energies
+
+  if (pstat_flag) {
+
+    akin_t = akin_r = 0.0;
+    for (int ibody = 0; ibody < nlocal_body; ibody++) {
+      Body *b = &body[ibody];
+      akin_t += b->mass*(b->vcm[0]*b->vcm[0] + b->vcm[1]*b->vcm[1] +
+        b->vcm[2]*b->vcm[2]);
+      akin_r += b->angmom[0]*b->omega[0] + b->angmom[1]*b->omega[1] +
+        b->angmom[2]*b->omega[2];
+    }
+
+    double ke[2],keall[2];
+    ke[0] = akin_t;
+    ke[1] = akin_r;
+    MPI_Allreduce(ke,keall,2,MPI_DOUBLE,MPI_SUM,world);
+    akin_t = keall[0];
+    akin_r = keall[1];
+  }
+
+  // set velocity/rotation of atoms in rigid bodies
+  // virial is already setup from initial_integrate
+
+  set_v();
+
+  // compute current temperature
+  if (tcomputeflag) t_current = temperature->compute_scalar();
+
+  // compute current and target pressures
+  // update epsilon dot using akin_t and akin_r
+
+  if (pstat_flag) {
+    if (pstyle == ISO) {
+      temperature->compute_scalar();
+      pressure->compute_scalar();
+    } else {
+      temperature->compute_vector();
+      pressure->compute_vector();
+    }
+    couple();
+    pressure->addstep(update->ntimestep+1);
+
+    compute_press_target();
+
+    nh_epsilon_dot();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::nhc_temp_integrate()
+{
+  int i,j,k;
+  double kt,gfkt_t,gfkt_r,tmp,ms,s,s2;
+
+  kt = boltz * t_target;
+  gfkt_t = nf_t * kt;
+  gfkt_r = nf_r * kt;
+
+  // update thermostat masses
+
+  double t_mass = boltz * t_target / (t_freq * t_freq);
+  q_t[0] = nf_t * t_mass;
+  q_r[0] = nf_r * t_mass;
+  for (i = 1; i < t_chain; i++)
+    q_t[i] = q_r[i] = t_mass;
+
+  // update force of thermostats coupled to particles
+
+  f_eta_t[0] = (akin_t * mvv2e - gfkt_t) / q_t[0];
+  f_eta_r[0] = (akin_r * mvv2e - gfkt_r) / q_r[0];
+
+  // multiple timestep iteration
+
+  for (i = 0; i < t_iter; i++) {
+    for (j = 0; j < t_order; j++) {
+
+      // update thermostat velocities half step
+
+      eta_dot_t[t_chain-1] += wdti2[j] * f_eta_t[t_chain-1];
+      eta_dot_r[t_chain-1] += wdti2[j] * f_eta_r[t_chain-1];
+
+      for (k = 1; k < t_chain; k++) {
+        tmp = wdti4[j] * eta_dot_t[t_chain-k];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_t[t_chain-k-1] = eta_dot_t[t_chain-k-1] * s2 +
+          wdti2[j] * f_eta_t[t_chain-k-1] * s * ms;
+
+        tmp = wdti4[j] * eta_dot_r[t_chain-k];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_r[t_chain-k-1] = eta_dot_r[t_chain-k-1] * s2 +
+          wdti2[j] * f_eta_r[t_chain-k-1] * s * ms;
+      }
+
+      // update thermostat positions a full step
+
+      for (k = 0; k < t_chain; k++) {
+        eta_t[k] += wdti1[j] * eta_dot_t[k];
+        eta_r[k] += wdti1[j] * eta_dot_r[k];
+      }
+
+      // update thermostat forces
+
+      for (k = 1; k < t_chain; k++) {
+        f_eta_t[k] = q_t[k-1] * eta_dot_t[k-1] * eta_dot_t[k-1] - kt;
+        f_eta_t[k] /= q_t[k];
+        f_eta_r[k] = q_r[k-1] * eta_dot_r[k-1] * eta_dot_r[k-1] - kt;
+        f_eta_r[k] /= q_r[k];
+      }
+
+      // update thermostat velocities a full step
+
+      for (k = 0; k < t_chain-1; k++) {
+        tmp = wdti4[j] * eta_dot_t[k+1];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_t[k] = eta_dot_t[k] * s2 + wdti2[j] * f_eta_t[k] * s * ms;
+        tmp = q_t[k] * eta_dot_t[k] * eta_dot_t[k] - kt;
+        f_eta_t[k+1] = tmp / q_t[k+1];
+
+        tmp = wdti4[j] * eta_dot_r[k+1];
+        ms = maclaurin_series(tmp);
+        s = exp(-1.0 * tmp);
+        s2 = s * s;
+        eta_dot_r[k] = eta_dot_r[k] * s2 + wdti2[j] * f_eta_r[k] * s * ms;
+        tmp = q_r[k] * eta_dot_r[k] * eta_dot_r[k] - kt;
+        f_eta_r[k+1] = tmp / q_r[k+1];
+      }
+
+      eta_dot_t[t_chain-1] += wdti2[j] * f_eta_t[t_chain-1];
+      eta_dot_r[t_chain-1] += wdti2[j] * f_eta_r[t_chain-1];
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::nhc_press_integrate()
+{
+  int i,j,k;
+  double tmp,s,s2,ms,kecurrent;
+  double kt = boltz * t_target;
+  double lkt_press = kt;
+
+  // update thermostat masses
+
+  double tb_mass = kt / (p_freq_max * p_freq_max);
+  q_b[0] = dimension * dimension * tb_mass;
+  for (int i = 1; i < p_chain; i++) {
+    q_b[i] = tb_mass;
+    f_eta_b[i] = q_b[i-1] * eta_dot_b[i-1] * eta_dot_b[i-1] - kt;
+    f_eta_b[i] /= q_b[i];
+  }
+
+  // update forces acting on thermostat
+
+  kecurrent = 0.0;
+  for (i = 0; i < 3; i++)
+    if (p_flag[i]) {
+      epsilon_mass[i] = (g_f + dimension) * kt / (p_freq[i] * p_freq[i]);
+      kecurrent += epsilon_mass[i] * epsilon_dot[i] * epsilon_dot[i];
+    }
+  kecurrent /= pdim;
+
+  f_eta_b[0] = (kecurrent - lkt_press) / q_b[0];
+
+  // multiple timestep iteration
+
+  for (i = 0; i < t_iter; i++) {
+    for (j = 0; j < t_order; j++) {
+
+      // update thermostat velocities a half step
+
+      eta_dot_b[p_chain-1] += wdti2[j] * f_eta_b[p_chain-1];
+
+      for (k = 1; k < p_chain; k++) {
+        tmp = wdti4[j] * eta_dot_b[p_chain-k];
+        ms = maclaurin_series(tmp);
+        s = exp(-0.5 * tmp);
+        s2 = s * s;
+        eta_dot_b[p_chain-k-1] = eta_dot_b[p_chain-k-1] * s2 +
+          wdti2[j] * f_eta_b[p_chain-k-1] * s * ms;
+      }
+
+      // update thermostat positions
+
+      for (k = 0; k < p_chain; k++)
+        eta_b[k] += wdti1[j] * eta_dot_b[k];
+
+      // update thermostat forces
+
+      for (k = 1; k < p_chain; k++) {
+        f_eta_b[k] = q_b[k-1] * eta_dot_b[k-1] * eta_dot_b[k-1] - kt;
+        f_eta_b[k] /= q_b[k];
+      }
+
+      // update thermostat velocites a full step
+
+      for (k = 0; k < p_chain-1; k++) {
+        tmp = wdti4[j] * eta_dot_b[k+1];
+        ms = maclaurin_series(tmp);
+        s = exp(-0.5 * tmp);
+        s2 = s * s;
+        eta_dot_b[k] = eta_dot_b[k] * s2 + wdti2[j] * f_eta_b[k] * s * ms;
+        tmp = q_b[k] * eta_dot_b[k] * eta_dot_b[k] - kt;
+        f_eta_b[k+1] = tmp / q_b[k+1];
+      }
+
+      eta_dot_b[p_chain-1] += wdti2[j] * f_eta_b[p_chain-1];
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   compute kinetic energy in the extended Hamiltonian
+   conserved quantity = sum of returned energy and potential energy
+-----------------------------------------------------------------------*/
+
+double FixRigidNHSmall::compute_scalar()
+{
+  int i,k;
+  double kt = boltz * t_target;
+  double energy,ke_t,ke_q,tmp,Pkq[4];
+
+  double *vcm,*quat;
+
+  // compute the kinetic parts of H_NVE in Kameraj et al (JCP 2005, pp 224114)
+
+  // translational and rotational kinetic energies
+
+  ke_t = 0.0;
+  ke_q = 0.0;
+
+  for (int i = 0; i < nlocal_body; i++) {
+    vcm = body[i].vcm;
+    quat = body[i].quat;
+    ke_t += body[i].mass * (vcm[0]*vcm[0] + vcm[1]*vcm[1] +
+      vcm[2]*vcm[2]);
+
+    for (k = 1; k < 4; k++) {
+      if (k == 1) {
+        Pkq[0] = -quat[1];
+        Pkq[1] =  quat[0];
+        Pkq[2] =  quat[3];
+        Pkq[3] = -quat[2];
+      } else if (k == 2) {
+        Pkq[0] = -quat[2];
+        Pkq[1] = -quat[3];
+        Pkq[2] =  quat[0];
+        Pkq[3] =  quat[1];
+      } else if (k == 3) {
+        Pkq[0] = -quat[3];
+        Pkq[1] =  quat[2];
+        Pkq[2] = -quat[1];
+        Pkq[3] =  quat[0];
+      }
+
+      tmp = body[i].conjqm[0]*Pkq[0] + body[i].conjqm[1]*Pkq[1] +
+        body[i].conjqm[2]*Pkq[2] + body[i].conjqm[3]*Pkq[3];
+      tmp *= tmp;
+
+      if (fabs(body[i].inertia[k-1]) < 1e-6) tmp = 0.0;
+      else tmp /= (8.0 * body[i].inertia[k-1]);
+      ke_q += tmp;
+    }
+  }
+
+  double ke[2],keall[2];
+  ke[0] = ke_t;
+  ke[1] = ke_q;
+  MPI_Allreduce(ke,keall,2,MPI_DOUBLE,MPI_SUM,world);
+  ke_t = keall[0];
+  ke_q = keall[1];
+
+  energy = (ke_t + ke_q) * mvv2e;
+
+  if (tstat_flag) {
+
+    // thermostat chain energy: from equation 12 in Kameraj et al (JCP 2005)
+
+    energy += kt * (nf_t * eta_t[0] + nf_r * eta_r[0]);
+
+    for (i = 1; i < t_chain; i++)
+      energy += kt * (eta_t[i] + eta_r[i]);
+
+    for (i = 0;  i < t_chain; i++) {
+      energy += 0.5 * q_t[i] * (eta_dot_t[i] * eta_dot_t[i]);
+      energy += 0.5 * q_r[i] * (eta_dot_r[i] * eta_dot_r[i]);
+    }
+  }
+
+  if (pstat_flag) {
+
+    // using equation 22 in Kameraj et al for H_NPT
+
+    double e = 0.0;
+    for (i = 0; i < 3; i++)
+      if (p_flag[i])
+        e += epsilon_mass[i] * epsilon_dot[i] * epsilon_dot[i];
+    energy += e*(0.5/pdim);
+
+    double vol;
+    if (dimension == 2) vol = domain->xprd * domain->yprd;
+    else vol = domain->xprd * domain->yprd * domain->zprd;
+
+    double p0 = (p_target[0] + p_target[1] + p_target[2]) / 3.0;
+    energy += p0 * vol / nktv2p;
+
+    for (i = 0;  i < p_chain; i++) {
+      energy += kt * eta_b[i];
+      energy += 0.5 * q_b[i] * (eta_dot_b[i] * eta_dot_b[i]);
+    }
+  }
+
+  return energy;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::couple()
+{
+  double *tensor = pressure->vector;
+
+  if (pstyle == ISO) {
+    p_current[0] = p_current[1] = p_current[2] = pressure->scalar;
+  } else if (pcouple == XYZ) {
+    double ave = 1.0/3.0 * (tensor[0] + tensor[1] + tensor[2]);
+    p_current[0] = p_current[1] = p_current[2] = ave;
+  } else if (pcouple == XY) {
+    double ave = 0.5 * (tensor[0] + tensor[1]);
+    p_current[0] = p_current[1] = ave;
+    p_current[2] = tensor[2];
+  } else if (pcouple == YZ) {
+    double ave = 0.5 * (tensor[1] + tensor[2]);
+    p_current[1] = p_current[2] = ave;
+    p_current[0] = tensor[0];
+  } else if (pcouple == XZ) {
+    double ave = 0.5 * (tensor[0] + tensor[2]);
+    p_current[0] = p_current[2] = ave;
+    p_current[1] = tensor[1];
+  } else {
+    p_current[0] = tensor[0];
+    p_current[1] = tensor[1];
+    p_current[2] = tensor[2];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::remap()
+{
+  int i;
+  double oldlo,oldhi,ctr,expfac;
+
+  double **x = atom->x;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  // epsilon is not used, except for book-keeping
+
+  for (i = 0; i < 3; i++) epsilon[i] += dtq * epsilon_dot[i];
+
+  // convert pertinent atoms and rigid bodies to lamda coords
+
+  if (allremap) domain->x2lamda(nlocal);
+  else {
+    for (i = 0; i < nlocal; i++)
+      if (mask[i] & dilate_group_bit)
+        domain->x2lamda(x[i],x[i]);
+  }
+
+  if (nrigidfix)
+    for (i = 0; i < nrigidfix; i++)
+      modify->fix[rfix[i]]->deform(0);
+
+  // reset global and local box to new size/shape
+
+  for (i = 0; i < 3; i++) {
+    if (p_flag[i]) {
+      oldlo = domain->boxlo[i];
+      oldhi = domain->boxhi[i];
+      ctr = 0.5 * (oldlo + oldhi);
+      expfac = exp(dtq * epsilon_dot[i]);
+      domain->boxlo[i] = (oldlo-ctr)*expfac + ctr;
+      domain->boxhi[i] = (oldhi-ctr)*expfac + ctr;
+    }
+  }
+
+  domain->set_global_box();
+  domain->set_local_box();
+
+  // convert pertinent atoms and rigid bodies back to box coords
+
+  if (allremap) domain->lamda2x(nlocal);
+  else {
+    for (i = 0; i < nlocal; i++)
+      if (mask[i] & dilate_group_bit)
+        domain->lamda2x(x[i],x[i]);
+  }
+
+  if (nrigidfix)
+    for (i = 0; i< nrigidfix; i++)
+      modify->fix[rfix[i]]->deform(1);
+}
+
+/* ----------------------------------------------------------------------
+   compute target temperature and kinetic energy
+-----------------------------------------------------------------------*/
+
+void FixRigidNHSmall::compute_temp_target()
+{
+  double delta = update->ntimestep - update->beginstep;
+  if (delta != 0.0) delta /= update->endstep - update->beginstep;
+
+  t_target = t_start + delta * (t_stop-t_start);
+}
+
+/* ----------------------------------------------------------------------
+   compute hydrostatic target pressure
+-----------------------------------------------------------------------*/
+
+void FixRigidNHSmall::compute_press_target()
+{
+  double delta = update->ntimestep - update->beginstep;
+  if (delta != 0.0) delta /= update->endstep - update->beginstep;
+
+  p_hydro = 0.0;
+  for (int i = 0; i < 3; i++)
+    if (p_flag[i]) {
+      p_target[i] = p_start[i] + delta * (p_stop[i]-p_start[i]);
+      p_hydro += p_target[i];
+    }
+  p_hydro /= pdim;
+}
+
+/* ----------------------------------------------------------------------
+   update epsilon_dot
+-----------------------------------------------------------------------*/
+
+void FixRigidNHSmall::nh_epsilon_dot()
+{
+  int i;
+  double volume,scale,f_epsilon;
+
+  if (dimension == 2) volume = domain->xprd*domain->yprd;
+  else volume = domain->xprd*domain->yprd*domain->zprd;
+
+  // MTK terms
+
+  mtk_term1 = (akin_t + akin_r) * mvv2e / g_f;
+
+  scale = exp(-1.0 * dtq * eta_dot_b[0]);
+
+  for (i = 0; i < 3; i++)
+    if (p_flag[i]) {
+      f_epsilon = (p_current[i]-p_hydro)*volume / nktv2p + mtk_term1;
+      f_epsilon /= epsilon_mass[i];
+      epsilon_dot[i] += dtq * f_epsilon;
+      epsilon_dot[i] *= scale;
+    }
+
+  mtk_term2 = 0.0;
+  for (i = 0; i < 3; i++)
+    if (p_flag[i]) mtk_term2 += epsilon_dot[i];
+  mtk_term2 /= g_f;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::compute_dof()
+{
+  // total translational and rotational degrees of freedom
+
+  nf_t = dimension * nlocal_body;
+  if (dimension == 3) {
+    nf_r = dimension * nlocal_body;
+    for (int ibody = 0; ibody < nlocal_body; ibody++) {
+      Body *b = &body[ibody];
+      for (int k = 0; k < dimension; k++)
+        if (fabs(b->inertia[k]) < EPSILON) nf_r--;
+    }
+  } else if (dimension == 2) {
+    nf_r = nlocal_body;
+    for (int ibody = 0; ibody < nlocal_body; ibody++) {
+      Body *b = &body[ibody];
+      if (fabs(b->inertia[2]) < EPSILON) nf_r--;
+    }
+  }
+
+  double nf[2], nfall[2];
+  nf[0] = nf_t;
+  nf[1] = nf_r;
+  MPI_Allreduce(nf,nfall,2,MPI_DOUBLE,MPI_SUM,world);
+  nf_t = nfall[0];
+  nf_r = nfall[1];
+
+  g_f = nf_t + nf_r;
+  onednft = 1.0 + (double)(dimension) / (double)g_f;
+  onednfr = (double) (dimension) / (double)g_f;
+}
+
+/* ----------------------------------------------------------------------
+   pack entire state of Fix into one write
+------------------------------------------------------------------------- */
+
+void FixRigidNHSmall::write_restart(FILE *fp)
+{
+  if (tstat_flag == 0 && pstat_flag == 0) return;
+
+  int nsize = 2; // tstat_flag and pstat_flag
+
+  if (tstat_flag) {
+    nsize += 1;         // t_chain
+    nsize += 4*t_chain; // eta_t, eta_r, eta_dot_t, eta_dot_r
+  }
+
+  if (pstat_flag) {
+    nsize += 7;         // p_chain, epsilon(3) and epsilon_dot(3)
+    nsize += 2*p_chain;
+  }
+
+  double *list;
+  memory->create(list,nsize,"rigid_nh:list");
+
+  int n = 0;
+
+  list[n++] = tstat_flag;
+  if (tstat_flag) {
+    list[n++] = t_chain;
+    for (int i = 0; i < t_chain; i++) {
+      list[n++] = eta_t[i];
+      list[n++] = eta_r[i];
+      list[n++] = eta_dot_t[i];
+      list[n++] = eta_dot_r[i];
+    }
+  }
+
+  list[n++] = pstat_flag;
+  if (pstat_flag) {
+    list[n++] = epsilon[0];
+    list[n++] = epsilon[1];
+    list[n++] = epsilon[2];
+    list[n++] = epsilon_dot[0];
+    list[n++] = epsilon_dot[1];
+    list[n++] = epsilon_dot[2];
+
+    list[n++] = p_chain;
+    for (int i = 0; i < p_chain; i++) {
+      list[n++] = eta_b[i];
+      list[n++] = eta_dot_b[i];
+    }
+  }
+
+  if (comm->me == 0) {
+    int size = (nsize)*sizeof(double);
+    fwrite(&size,sizeof(int),1,fp);
+    fwrite(list,sizeof(double),nsize,fp);
+  }
+
+  memory->destroy(list);
+}
+
+/* ----------------------------------------------------------------------
+   use state info from restart file to restart the Fix
+------------------------------------------------------------------------- */
+
+void FixRigidNHSmall::restart(char *buf)
+{
+  int n = 0;
+  double *list = (double *) buf;
+  int flag = static_cast<int> (list[n++]);
+
+  if (flag) {
+    int m = static_cast<int> (list[n++]);
+    if (tstat_flag && m == t_chain) {
+      for (int i = 0; i < t_chain; i++) {
+        eta_t[i] = list[n++];
+        eta_r[i] = list[n++];
+        eta_dot_t[i] = list[n++];
+        eta_dot_r[i] = list[n++];
+      }
+    } else n += 4*m;
+  }
+
+  flag = static_cast<int> (list[n++]);
+  if (flag) {
+    epsilon[0] = list[n++];
+    epsilon[1] = list[n++];
+    epsilon[2] = list[n++];
+    epsilon_dot[0] = list[n++];
+    epsilon_dot[1] = list[n++];
+    epsilon_dot[2] = list[n++];
+
+    int m = static_cast<int> (list[n++]);
+    if (pstat_flag && m == p_chain) {
+      for (int i = 0; i < p_chain; i++) {
+        eta_b[i] = list[n++];
+        eta_dot_b[i] = list[n++];
+      }
+    } else n += 2*m;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRigidNHSmall::modify_param(int narg, char **arg)
+{
+  if (strcmp(arg[0],"temp") == 0) {
+    if (narg < 2) error->all(FLERR,"Illegal fix_modify command");
+    if (tcomputeflag) {
+      modify->delete_compute(id_temp);
+      tcomputeflag = 0;
+    }
+    delete [] id_temp;
+    int n = strlen(arg[1]) + 1;
+    id_temp = new char[n];
+    strcpy(id_temp,arg[1]);
+
+    int icompute = modify->find_compute(arg[1]);
+    if (icompute < 0)
+      error->all(FLERR,"Could not find fix_modify temperature ID");
+    temperature = modify->compute[icompute];
+
+    if (temperature->tempflag == 0)
+      error->all(FLERR,
+                 "Fix_modify temperature ID does not compute temperature");
+    if (temperature->igroup != 0 && comm->me == 0)
+      error->warning(FLERR,"Temperature for fix modify is not for group all");
+
+    // reset id_temp of pressure to new temperature ID
+
+    if (pstat_flag) {
+      icompute = modify->find_compute(id_press);
+      if (icompute < 0)
+        error->all(FLERR,"Pressure ID for fix modify does not exist");
+      modify->compute[icompute]->reset_extra_compute_fix(id_temp);
+    }
+
+    return 2;
+
+  } else if (strcmp(arg[0],"press") == 0) {
+    if (narg < 2) error->all(FLERR,"Illegal fix_modify command");
+    if (!pstat_flag) error->all(FLERR,"Illegal fix_modify command");
+    if (pcomputeflag) {
+      modify->delete_compute(id_press);
+      pcomputeflag = 0;
+    }
+    delete [] id_press;
+    int n = strlen(arg[1]) + 1;
+    id_press = new char[n];
+    strcpy(id_press,arg[1]);
+
+    int icompute = modify->find_compute(arg[1]);
+    if (icompute < 0) error->all(FLERR,"Could not find fix_modify pressure ID");
+    pressure = modify->compute[icompute];
+
+    if (pressure->pressflag == 0)
+      error->all(FLERR,"Fix_modify pressure ID does not compute pressure");
+    return 2;
+  }
+
+  return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::allocate_chain()
+{
+  if (tstat_flag) {
+    q_t = new double[t_chain];
+    q_r = new double[t_chain];
+    eta_t = new double[t_chain];
+    eta_r = new double[t_chain];
+    eta_dot_t = new double[t_chain];
+    eta_dot_r = new double[t_chain];
+    f_eta_t = new double[t_chain];
+    f_eta_r = new double[t_chain];
+  }
+
+  if (pstat_flag) {
+    q_b = new double[p_chain];
+    eta_b = new double[p_chain];
+    eta_dot_b = new double[p_chain];
+    f_eta_b = new double[p_chain];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::reset_target(double t_new)
+{
+  t_start = t_stop = t_new;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::allocate_order()
+{
+  w = new double[t_order];
+  wdti1 = new double[t_order];
+  wdti2 = new double[t_order];
+  wdti4 = new double[t_order];
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::deallocate_chain()
+{
+  if (tstat_flag) {
+    delete [] q_t;
+    delete [] q_r;
+    delete [] eta_t;
+    delete [] eta_r;
+    delete [] eta_dot_t;
+    delete [] eta_dot_r;
+    delete [] f_eta_t;
+    delete [] f_eta_r;
+  }
+
+  if (pstat_flag) {
+    delete [] q_b;
+    delete [] eta_b;
+    delete [] eta_dot_b;
+    delete [] f_eta_b;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidNHSmall::deallocate_order()
+{
+  delete [] w;
+  delete [] wdti1;
+  delete [] wdti2;
+  delete [] wdti4;
+}
diff -uN src/fix_rigid_nh_small.h src_DFT-CES2/fix_rigid_nh_small.h
--- src/fix_rigid_nh_small.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nh_small.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,179 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifndef LMP_FIX_RIGID_NH_SMALL_H
+#define LMP_FIX_RIGID_NH_SMALL_H
+
+#include "fix_rigid_small.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNHSmall : public FixRigidSmall {
+ public:
+  FixRigidNHSmall(class LAMMPS *, int, char **);
+  virtual ~FixRigidNHSmall();
+  virtual int setmask();
+  virtual void init();
+  virtual void setup(int);
+  virtual void initial_integrate(int);
+  virtual void final_integrate();
+  virtual double compute_scalar();
+  int modify_param(int, char **);
+  void write_restart(FILE *);
+  void restart(char *buf);
+  void reset_target(double);
+
+ protected:
+  double boltz,nktv2p,mvv2e;          // boltzman constant, conversion factors
+
+  int dimension;                      // # of dimensions
+  int nf_t,nf_r;                      // trans/rot degrees of freedom
+  double onednft,onednfr;             // factors 1 + dimension/trans(rot) degrees of freedom
+  double *w,*wdti1,*wdti2,*wdti4;     // Yoshida-Suzuki coefficients
+  double *q_t,*q_r;                   // trans/rot thermostat masses
+  double *eta_t,*eta_r;               // trans/rot thermostat positions
+  double *eta_dot_t,*eta_dot_r;       // trans/rot thermostat velocities
+  double *f_eta_t,*f_eta_r;           // trans/rot thermostat forces
+
+  double epsilon_mass[3], *q_b;       // baro/thermo masses
+  double epsilon[3],*eta_b;           // baro/thermo positions
+  double epsilon_dot[3],*eta_dot_b;   // baro/thermo velocities
+  double *f_eta_b;                    // thermo forces
+  double akin_t,akin_r;               // translational/rotational kinetic energies
+
+  int kspace_flag;                    // 1 if KSpace invoked, 0 if not
+  int nrigidfix;                      // number of rigid fixes
+  int *rfix;                          // indicies of rigid fixes
+
+  double vol0;                        // reference volume
+  double t0;                          // reference temperature
+  int pdim,g_f;                       // number of barostatted dims, total DoFs
+  double p_hydro;                     // hydrostatic target pressure
+  double p_freq_max;                  // maximum barostat frequency
+
+  double mtk_term1,mtk_term2;         // Martyna-Tobias-Klein corrections
+
+  double t_target,t_current;
+  double t_freq;
+
+  char *id_temp,*id_press;
+  class Compute *temperature,*pressure;
+  int tcomputeflag,pcomputeflag;      // 1 = compute was created by fix. 0 = external
+
+  void couple();
+  void remap();
+  void nhc_temp_integrate();
+  void nhc_press_integrate();
+
+  virtual void compute_temp_target();
+  void compute_press_target();
+  void nh_epsilon_dot();
+  void compute_dof();
+  
+  void allocate_chain();
+  void allocate_order();
+  void deallocate_chain();
+  void deallocate_order();
+
+  inline double maclaurin_series(double);
+};
+
+inline double FixRigidNHSmall::maclaurin_series(double x)
+{
+  double x2,x4;
+  x2 = x * x;
+  x4 = x2 * x2;
+  return (1.0 + (1.0/6.0) * x2 + (1.0/120.0) * x4 + (1.0/5040.0) * x2 * x4 +
+         (1.0/362880.0) * x4 * x4);
+}
+
+}
+
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Fix rigid/small npt/nph period must be > 0.0
+
+Self-explanatory.
+
+E: Invalid fix rigid/small npt/nph command for a 2d simulation
+
+Cannot control z dimension in a 2d model.
+
+E: Invalid fix rigid/small npt/nph command pressure settings
+
+If multiple dimensions are coupled, those dimensions must be
+specified.
+
+E: Cannot use fix rigid/small npt/nph on a non-periodic dimension
+
+When specifying a diagonal pressure component, the dimension must be
+periodic.
+
+E: Fix rigid/small nvt/npt/nph damping parameters must be > 0.0
+
+Self-explanatory.
+
+E: Fix rigid npt/nph dilate group ID does not exist
+
+Self-explanatory.
+
+E: Temperature ID for fix rigid nvt/npt/nph does not exist
+
+Self-explanatory.
+
+E: Fix rigid npt/nph does not yet allow triclinic box
+
+This is a current restriction in LAMMPS.
+
+E: Cannot use fix rigid npt/nph and fix deform on same component of stress tensor
+
+This would be changing the same box dimension twice.
+
+E: Pressure ID for fix rigid npt/nph does not exist
+
+Self-explanatory.
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Could not find fix_modify temperature ID
+
+The compute ID for computing temperature does not exist.
+
+E: Fix_modify temperature ID does not compute temperature
+
+The compute ID assigned to the fix must compute temperature.
+
+W: Temperature for fix modify is not for group all
+
+The temperature compute is being used with a pressure calculation
+which does operate on group all, so this may be inconsistent.
+
+E: Pressure ID for fix modify does not exist
+
+Self-explanatory.
+
+E: Could not find fix_modify pressure ID
+
+The compute ID for computing pressure does not exist.
+
+E: Fix_modify pressure ID does not compute pressure
+
+The compute ID assigned to the fix must compute pressure.
+
+*/
diff -uN src/fix_rigid_nph.cpp src_DFT-CES2/fix_rigid_nph.cpp
--- src/fix_rigid_nph.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nph.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,90 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Tony Sheh (U Michigan), Trung Dac Nguyen (U Michigan)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "fix_rigid_nph.h"
+#include "domain.h"
+#include "modify.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNPH::FixRigidNPH(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNH(lmp, narg, arg)
+{
+  // other setting are made by parent
+
+  scalar_flag = 1;
+  restart_global = 1;
+  box_change_size = 1;
+  extscalar = 1;
+
+  // error checks
+
+  if (pstat_flag == 0)
+    error->all(FLERR,"Did not set pressure for fix rigid/nph");
+  if (tstat_flag == 1)
+    error->all(FLERR,"Cannot set temperature for fix rigid/nph");
+
+  // convert input periods to frequency
+
+  p_freq[0] = p_freq[1] = p_freq[2] = 0.0;
+
+  if (p_flag[0]) p_freq[0] = 1.0 / p_period[0];
+  if (p_flag[1]) p_freq[1] = 1.0 / p_period[1];
+  if (p_flag[2]) p_freq[2] = 1.0 / p_period[2];
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  //   and thus its KE/temperature contribution should use group all
+
+  int n = strlen(id) + 6;
+  id_temp = new char[n];
+  strcpy(id_temp,id);
+  strcat(id_temp,"_temp");
+
+  char **newarg = new char*[3];
+  newarg[0] = id_temp;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "temp";
+  modify->add_compute(3,newarg);
+  delete [] newarg;
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  n = strlen(id) + 7;
+  id_press = new char[n];
+  strcpy(id_press,id);
+  strcat(id_press,"_press");
+
+  newarg = new char*[4];
+  newarg[0] = id_press;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "pressure";
+  newarg[3] = id_temp;
+  modify->add_compute(4,newarg);
+  delete [] newarg;
+  pcomputeflag = 1;
+}
diff -uN src/fix_rigid_nph.h src_DFT-CES2/fix_rigid_nph.h
--- src/fix_rigid_nph.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nph.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,49 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/nph,FixRigidNPH)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NPH_H
+#define LMP_FIX_RIGID_NPH_H
+
+#include "fix_rigid_nh.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNPH : public FixRigidNH {
+ public:
+  FixRigidNPH(class LAMMPS *, int, char **);
+  ~FixRigidNPH() {}
+};
+
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Did not set pressure for fix rigid/nph
+
+The press keyword must be specified.
+
+E: Cannot set temperature for fix rigid/nph
+
+The temp keyword cannot be specified.
+
+*/
diff -uN src/fix_rigid_nph_small.cpp src_DFT-CES2/fix_rigid_nph_small.cpp
--- src/fix_rigid_nph_small.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nph_small.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,93 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Trung Dac Nguyen (ORNL)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "fix_rigid_nph_small.h"
+#include "domain.h"
+#include "modify.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNPHSmall::FixRigidNPHSmall(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNHSmall(lmp, narg, arg)
+{
+  // other setting are made by parent
+
+  scalar_flag = 1;
+  restart_global = 1;
+  box_change_size = 1;
+  extscalar = 1;
+
+  // error checks
+
+  if (pstat_flag == 0)
+    error->all(FLERR,"Pressure control must be used with fix nph/small");
+  if (tstat_flag == 1)
+    error->all(FLERR,"Temperature control must not be used with fix nph/small");
+  if (p_start[0] < 0.0 || p_start[1] < 0.0 || p_start[2] < 0.0 ||
+      p_stop[0] < 0.0 || p_stop[1] < 0.0 || p_stop[2] < 0.0)
+    error->all(FLERR,"Target pressure for fix rigid/nph cannot be < 0.0");
+
+  // convert input periods to frequency
+
+  p_freq[0] = p_freq[1] = p_freq[2] = 0.0;
+
+  if (p_flag[0]) p_freq[0] = 1.0 / p_period[0];
+  if (p_flag[1]) p_freq[1] = 1.0 / p_period[1];
+  if (p_flag[2]) p_freq[2] = 1.0 / p_period[2];
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  //   and thus its KE/temperature contribution should use group all
+
+  int n = strlen(id) + 6;
+  id_temp = new char[n];
+  strcpy(id_temp,id);
+  strcat(id_temp,"_temp");
+
+  char **newarg = new char*[3];
+  newarg[0] = id_temp;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "temp";
+  modify->add_compute(3,newarg);
+  delete [] newarg;
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  n = strlen(id) + 7;
+  id_press = new char[n];
+  strcpy(id_press,id);
+  strcat(id_press,"_press");
+
+  newarg = new char*[4];
+  newarg[0] = id_press;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "pressure";
+  newarg[3] = id_temp;
+  modify->add_compute(4,newarg);
+  delete [] newarg;
+  pcomputeflag = 1;
+}
diff -uN src/fix_rigid_nph_small.h src_DFT-CES2/fix_rigid_nph_small.h
--- src/fix_rigid_nph_small.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nph_small.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,53 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/nph/small,FixRigidNPHSmall)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NPH_SMALL_H
+#define LMP_FIX_RIGID_NPH_SMALL_H
+
+#include "fix_rigid_nh_small.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNPHSmall : public FixRigidNHSmall {
+ public:
+  FixRigidNPHSmall(class LAMMPS *, int, char **);
+  ~FixRigidNPHSmall() {}
+};
+
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Pressure control must be used with fix nph/small
+
+Self-explanatory.
+
+E: Temperature control must not be used with fix nph/small
+
+Self-explanatory.
+
+E: Target pressure for fix rigid/nph cannot be < 0.0
+
+Self-explanatory.
+
+*/
diff -uN src/fix_rigid_npt.cpp src_DFT-CES2/fix_rigid_npt.cpp
--- src/fix_rigid_npt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_npt.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,100 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Tony Sheh (U Michigan), Trung Dac Nguyen (U Michigan)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "fix_rigid_npt.h"
+#include "domain.h"
+#include "modify.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNPT::FixRigidNPT(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNH(lmp, narg, arg)
+{
+  // other setting are made by parent
+
+  scalar_flag = 1;
+  restart_global = 1;
+  box_change_size = 1;
+  extscalar = 1;
+
+  // error checks
+
+  if (tstat_flag == 0 || pstat_flag == 0)
+    error->all(FLERR,"Did not set temperature or pressure for fix rigid/npt");
+  if (t_start <= 0.0 || t_stop <= 0.0)
+    error->all(FLERR,"Target temperature for fix rigid/npt cannot be 0.0");
+  if (t_period <= 0.0) error->all(FLERR,"Fix rigid/npt period must be > 0.0");
+
+  // thermostat chain parameters
+
+  if (t_chain < 1) error->all(FLERR,"Illegal fix rigid/npt command");
+  if (t_iter < 1) error->all(FLERR,"Illegal fix rigid/npt command");
+  if (t_order != 3 && t_order != 5)
+    error->all(FLERR,"Fix rigid/npt temperature order must be 3 or 5");
+
+  // convert input periods to frequency
+
+  t_freq = 0.0;
+  p_freq[0] = p_freq[1] = p_freq[2] = 0.0;
+
+  t_freq = 1.0 / t_period;
+  if (p_flag[0]) p_freq[0] = 1.0 / p_period[0];
+  if (p_flag[1]) p_freq[1] = 1.0 / p_period[1];
+  if (p_flag[2]) p_freq[2] = 1.0 / p_period[2];
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  //   and thus its KE/temperature contribution should use group all
+
+  int n = strlen(id) + 6;
+  id_temp = new char[n];
+  strcpy(id_temp,id);
+  strcat(id_temp,"_temp");
+
+  char **newarg = new char*[3];
+  newarg[0] = id_temp;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "temp";
+  modify->add_compute(3,newarg);
+  delete [] newarg;
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  n = strlen(id) + 7;
+  id_press = new char[n];
+  strcpy(id_press,id);
+  strcat(id_press,"_press");
+
+  newarg = new char*[4];
+  newarg[0] = id_press;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "pressure";
+  newarg[3] = id_temp;
+  modify->add_compute(4,newarg);
+  delete [] newarg;
+  pcomputeflag = 1;
+}
diff -uN src/fix_rigid_npt.h src_DFT-CES2/fix_rigid_npt.h
--- src/fix_rigid_npt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_npt.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,63 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/npt,FixRigidNPT)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NPT_H
+#define LMP_FIX_RIGID_NPT_H
+
+#include "fix_rigid_nh.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNPT : public FixRigidNH {
+ public:
+  FixRigidNPT(class LAMMPS *, int, char **);
+  ~FixRigidNPT() {}
+};
+
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Did not set temperature or pressure for fix rigid/npt
+
+The temp and press keywords must be specified.
+
+E: Target temperature for fix rigid/npt cannot be 0.0
+
+Self-explanatory.
+
+E: Fix rigid/npt period must be > 0.0
+
+Self-explanatory.
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Fix rigid/npt temperature order must be 3 or 5
+
+Self-explanatory.
+
+*/
diff -uN src/fix_rigid_npt_small.cpp src_DFT-CES2/fix_rigid_npt_small.cpp
--- src/fix_rigid_npt_small.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_npt_small.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,104 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Trung Dac Nguyen (ORNL)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include <string.h>
+#include "fix_rigid_npt_small.h"
+#include "domain.h"
+#include "modify.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNPTSmall::FixRigidNPTSmall(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNHSmall(lmp, narg, arg)
+{
+  // other setting are made by parent
+
+  scalar_flag = 1;
+  restart_global = 1;
+  box_change_size = 1;
+  extscalar = 1;
+
+  // error checks
+
+  if (tstat_flag == 0 || pstat_flag == 0)
+    error->all(FLERR,"Did not set temp or press for fix rigid/npt/small");
+  if (t_start <= 0.0 || t_stop <= 0.0)
+    error->all(FLERR,"Target temperature for fix rigid/npt/small cannot be 0.0");
+  if (p_start[0] < 0.0 || p_start[1] < 0.0 || p_start[2] < 0.0 ||
+      p_stop[0] < 0.0 || p_stop[1] < 0.0 || p_stop[2] < 0.0)
+    error->all(FLERR,"Target pressure for fix rigid/npt/small cannot be < 0.0");
+
+  if (t_period <= 0.0) error->all(FLERR,"Fix rigid/npt/small period must be > 0.0");
+
+  // thermostat chain parameters
+
+  if (t_chain < 1) error->all(FLERR,"Fix rigid npt/small t_chain should not be less than 1");
+  if (t_iter < 1) error->all(FLERR,"Fix rigid npt/small t_chain should not be less than 1");
+  if (t_order != 3 && t_order != 5)
+    error->all(FLERR,"Fix rigid npt/small t_order must be 3 or 5");
+
+  // convert input periods to frequency
+
+  t_freq = 0.0;
+  p_freq[0] = p_freq[1] = p_freq[2] = 0.0;
+
+  t_freq = 1.0 / t_period;
+  if (p_flag[0]) p_freq[0] = 1.0 / p_period[0];
+  if (p_flag[1]) p_freq[1] = 1.0 / p_period[1];
+  if (p_flag[2]) p_freq[2] = 1.0 / p_period[2];
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  //   and thus its KE/temperature contribution should use group all
+
+  int n = strlen(id) + 6;
+  id_temp = new char[n];
+  strcpy(id_temp,id);
+  strcat(id_temp,"_temp");
+
+  char **newarg = new char*[3];
+  newarg[0] = id_temp;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "temp";
+  modify->add_compute(3,newarg);
+  delete [] newarg;
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  n = strlen(id) + 7;
+  id_press = new char[n];
+  strcpy(id_press,id);
+  strcat(id_press,"_press");
+
+  newarg = new char*[4];
+  newarg[0] = id_press;
+  newarg[1] = (char *) "all";
+  newarg[2] = (char *) "pressure";
+  newarg[3] = id_temp;
+  modify->add_compute(4,newarg);
+  delete [] newarg;
+  pcomputeflag = 1;
+}
diff -uN src/fix_rigid_npt_small.h src_DFT-CES2/fix_rigid_npt_small.h
--- src/fix_rigid_npt_small.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_npt_small.h	2025-02-11 06:42:37.185608983 +0900
@@ -0,0 +1,65 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/npt/small,FixRigidNPTSmall)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NPT_SMALL_H
+#define LMP_FIX_RIGID_NPT_SMALL_H
+
+#include "fix_rigid_nh_small.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNPTSmall : public FixRigidNHSmall {
+ public:
+  FixRigidNPTSmall(class LAMMPS *, int, char **);
+  ~FixRigidNPTSmall() {}
+};
+
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Did not set temp or press for fix rigid/npt/small
+
+Self-explanatory.
+
+E: Target temperature for fix rigid/npt/small cannot be 0.0
+
+Self-explanatory.
+
+E: Target pressure for fix rigid/npt/small cannot be < 0.0
+
+Self-explanatory.
+
+E: Fix rigid/npt/small period must be > 0.0
+
+Self-explanatory.
+
+E: Fix rigid npt/small t_chain should not be less than 1
+
+Self-explanatory.
+
+E: Fix rigid npt/small t_order must be 3 or 5
+
+Self-explanatory.
+
+*/
diff -uN src/fix_rigid_nve.cpp src_DFT-CES2/fix_rigid_nve.cpp
--- src/fix_rigid_nve.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nve.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,28 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Tony Sheh (U Michigan), Trung Dac Nguyen (U Michigan)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include "fix_rigid_nve.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNVE::FixRigidNVE(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNH(lmp, narg, arg) {}
+
diff -uN src/fix_rigid_nve.h src_DFT-CES2/fix_rigid_nve.h
--- src/fix_rigid_nve.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nve.h	2025-02-11 06:42:37.177608906 +0900
@@ -0,0 +1,36 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/nve,FixRigidNVE)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NVE_H
+#define LMP_FIX_RIGID_NVE_H
+
+#include "fix_rigid_nh.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNVE : public FixRigidNH {
+ public:
+  FixRigidNVE(class LAMMPS *, int, char **);
+  ~FixRigidNVE() {}
+};
+
+}
+
+#endif
+#endif
diff -uN src/fix_rigid_nve_small.cpp src_DFT-CES2/fix_rigid_nve_small.cpp
--- src/fix_rigid_nve_small.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nve_small.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,28 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Trung Dac Nguyen (ORNL)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include "fix_rigid_nve_small.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNVESmall::FixRigidNVESmall(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNHSmall(lmp, narg, arg) {}
+
diff -uN src/fix_rigid_nve_small.h src_DFT-CES2/fix_rigid_nve_small.h
--- src/fix_rigid_nve_small.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nve_small.h	2025-02-11 06:42:37.177608906 +0900
@@ -0,0 +1,36 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/nve/small,FixRigidNVESmall)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NVE_SMALL_H
+#define LMP_FIX_RIGID_NVE_SMALL_H
+
+#include "fix_rigid_nh_small.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNVESmall : public FixRigidNHSmall {
+ public:
+  FixRigidNVESmall(class LAMMPS *, int, char **);
+  ~FixRigidNVESmall() {}
+};
+
+}
+
+#endif
+#endif
diff -uN src/fix_rigid_nvt.cpp src_DFT-CES2/fix_rigid_nvt.cpp
--- src/fix_rigid_nvt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nvt.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Tony Sheh (U Michigan), Trung Dac Nguyen (U Michigan)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include "fix_rigid_nvt.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNVT::FixRigidNVT(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNH(lmp, narg, arg)
+{
+  // other settings are made by parent
+
+  scalar_flag = 1;
+  restart_global = 1;
+  extscalar = 1;
+
+  // error checking
+  // convert input period to frequency
+
+  if (tstat_flag == 0)
+    error->all(FLERR,"Did not set temperature for fix rigid/nvt");
+  if (t_start < 0.0 || t_stop <= 0.0)
+    error->all(FLERR,"Target temperature for fix rigid/nvt cannot be 0.0");
+  if (t_period <= 0.0) error->all(FLERR,"Fix rigid/nvt period must be > 0.0");
+  t_freq = 1.0 / t_period;
+
+  if (t_chain < 1) error->all(FLERR,"Illegal fix rigid/nvt command");
+  if (t_iter < 1) error->all(FLERR,"Illegal fix rigid/nvt  command");
+  if (t_order != 3 && t_order != 5)
+    error->all(FLERR,"Fix rigid/nvt temperature order must be 3 or 5");
+}
diff -uN src/fix_rigid_nvt.h src_DFT-CES2/fix_rigid_nvt.h
--- src/fix_rigid_nvt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nvt.h	2025-02-11 06:42:37.177608906 +0900
@@ -0,0 +1,62 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/nvt,FixRigidNVT)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NVT_H
+#define LMP_FIX_RIGID_NVT_H
+
+#include "fix_rigid_nh.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNVT : public FixRigidNH {
+ public:
+  FixRigidNVT(class LAMMPS *, int, char **);
+  ~FixRigidNVT() {}
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Did not set temperature for fix rigid/nvt
+
+The temp keyword must be specified.
+
+E: Target temperature for fix rigid/nvt cannot be 0.0
+
+Self-explanatory.
+
+E: Fix rigid/nvt period must be > 0.0
+
+Self-explanatory.
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Fix rigid/nvt temperature order must be 3 or 5
+
+Self-explanatory.
+
+*/
diff -uN src/fix_rigid_nvt_small.cpp src_DFT-CES2/fix_rigid_nvt_small.cpp
--- src/fix_rigid_nvt_small.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nvt_small.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,50 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Trung Dac Nguyen (ORNL)
+   references: Kamberaj et al., J. Chem. Phys. 122, 224114 (2005)
+               Miller et al., J Chem Phys. 116, 8649-8659 (2002)
+------------------------------------------------------------------------- */
+
+#include "fix_rigid_nvt_small.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidNVTSmall::FixRigidNVTSmall(LAMMPS *lmp, int narg, char **arg) :
+  FixRigidNHSmall(lmp, narg, arg)
+{
+  // other settings are made by parent
+
+  scalar_flag = 1;
+  restart_global = 1;
+  extscalar = 1;
+
+  // error checking
+  // convert input period to frequency
+
+  if (tstat_flag == 0)
+    error->all(FLERR,"Did not set temp for fix rigid/nvt/small");
+  if (t_start < 0.0 || t_stop <= 0.0)
+    error->all(FLERR,"Target temperature for fix rigid/nvt/small cannot be 0.0");
+  if (t_period <= 0.0) error->all(FLERR,"Fix rigid/nvt/small period must be > 0.0");
+  t_freq = 1.0 / t_period;
+
+  if (t_chain < 1) error->all(FLERR,"Fix rigid nvt/small t_chain should not be less than 1");
+  if (t_iter < 1) error->all(FLERR,"Fix rigid nvt/small t_iter should not be less than 1");
+  if (t_order != 3 && t_order != 5)
+    error->all(FLERR,"Fix rigid nvt/small t_order must be 3 or 5");
+}
diff -uN src/fix_rigid_nvt_small.h src_DFT-CES2/fix_rigid_nvt_small.h
--- src/fix_rigid_nvt_small.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_nvt_small.h	2025-02-11 06:42:37.177608906 +0900
@@ -0,0 +1,64 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/nvt/small,FixRigidNVTSmall)
+
+#else
+
+#ifndef LMP_FIX_RIGID_NVT_SMALL_H
+#define LMP_FIX_RIGID_NVT_SMALL_H
+
+#include "fix_rigid_nh_small.h"
+
+namespace LAMMPS_NS {
+
+class FixRigidNVTSmall : public FixRigidNHSmall {
+ public:
+  FixRigidNVTSmall(class LAMMPS *, int, char **);
+  ~FixRigidNVTSmall() {}
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Did not set temp for fix rigid/nvt/small
+
+Self-explanatory.
+
+E: Target temperature for fix rigid/nvt/small cannot be 0.0
+
+Self-explanatory.
+
+E: Fix rigid/nvt/small period must be > 0.0
+
+Self-explanatory.
+
+E: Fix rigid nvt/small t_chain should not be less than 1
+
+Self-explanatory.
+
+E: Fix rigid nvt/small t_iter should not be less than 1
+
+Self-explanatory.
+
+E: Fix rigid nvt/small t_order must be 3 or 5
+
+Self-explanatory.
+
+*/
diff -uN src/fix_rigid_small.cpp src_DFT-CES2/fix_rigid_small.cpp
--- src/fix_rigid_small.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_small.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,3570 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "fix_rigid_small.h"
+#include "math_extra.h"
+#include "atom.h"
+#include "atom_vec_ellipsoid.h"
+#include "atom_vec_line.h"
+#include "atom_vec_tri.h"
+#include "molecule.h"
+#include "domain.h"
+#include "update.h"
+#include "respa.h"
+#include "modify.h"
+#include "group.h"
+#include "comm.h"
+#include "force.h"
+#include "output.h"
+#include "random_mars.h"
+#include "math_const.h"
+#include "memory.h"
+#include "error.h"
+
+#include <map>
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathConst;
+
+#define MAXLINE 1024
+#define CHUNK 1024
+#define ATTRIBUTE_PERBODY 20
+
+#define TOLERANCE 1.0e-6
+#define EPSILON 1.0e-7
+#define BIG 1.0e20
+
+#define SINERTIA 0.4            // moment of inertia prefactor for sphere
+#define EINERTIA 0.2            // moment of inertia prefactor for ellipsoid
+#define LINERTIA (1.0/12.0)     // moment of inertia prefactor for line segment
+
+#define DELTA_BODY 10000
+
+enum{NONE,XYZ,XY,YZ,XZ};        // same as in FixRigid
+enum{ISO,ANISO,TRICLINIC};      // same as in FixRigid
+
+enum{FULL_BODY,INITIAL,FINAL,FORCE_TORQUE,VCM_ANGMOM,XCM_MASS,ITENSOR,DOF};
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidSmall::FixRigidSmall(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg), step_respa(NULL), 
+  infile(NULL), body(NULL), bodyown(NULL), bodytag(NULL), atom2body(NULL), 
+  xcmimage(NULL), displace(NULL), eflags(NULL), orient(NULL), dorient(NULL), 
+  avec_ellipsoid(NULL), avec_line(NULL), avec_tri(NULL), counts(NULL), 
+  itensor(NULL), mass_body(NULL), langextra(NULL), random(NULL), id_dilate(NULL), 
+  onemols(NULL), hash(NULL), bbox(NULL), ctr(NULL), idclose(NULL), rsqclose(NULL)
+{
+  int i;
+
+  scalar_flag = 1;
+  extscalar = 0;
+  global_freq = 1;
+  time_integrate = 1;
+  rigid_flag = 1;
+  virial_flag = 1;
+  create_attribute = 1;
+  dof_flag = 1;
+  enforce2d_flag = 1;
+
+  MPI_Comm_rank(world,&me);
+  MPI_Comm_size(world,&nprocs);
+
+  // perform initial allocation of atom-based arrays
+  // register with Atom class
+
+  extended = orientflag = dorientflag = 0;
+  bodyown = NULL;
+  bodytag = NULL;
+  atom2body = NULL;
+  xcmimage = NULL;
+  displace = NULL;
+  eflags = NULL;
+  orient = NULL;
+  dorient = NULL;
+  grow_arrays(atom->nmax);
+  atom->add_callback(0);
+
+  // parse args for rigid body specification
+
+  if (narg < 4) error->all(FLERR,"Illegal fix rigid/small command");
+  if (strcmp(arg[3],"molecule") != 0)
+    error->all(FLERR,"Illegal fix rigid/small command");
+
+  if (atom->molecule_flag == 0)
+    error->all(FLERR,"Fix rigid/small requires atom attribute molecule");
+  if (atom->map_style == 0)
+    error->all(FLERR,"Fix rigid/small requires an atom map, see atom_modify");
+
+  // maxmol = largest molecule #
+
+  int *mask = atom->mask;
+  tagint *molecule = atom->molecule;
+  int nlocal = atom->nlocal;
+
+  maxmol = -1;
+  for (i = 0; i < nlocal; i++)
+    if (mask[i] & groupbit) maxmol = MAX(maxmol,molecule[i]);
+
+  tagint itmp;
+  MPI_Allreduce(&maxmol,&itmp,1,MPI_LMP_TAGINT,MPI_MAX,world);
+  maxmol = itmp;
+
+  // number of linear molecules is counted later
+  nlinear = 0;
+
+  // parse optional args
+
+  int seed;
+  langflag = 0;
+  infile = NULL;
+  onemols = NULL;
+  reinitflag = 1;
+
+  tstat_flag = 0;
+  pstat_flag = 0;
+  allremap = 1;
+  id_dilate = NULL;
+  t_chain = 10;
+  t_iter = 1;
+  t_order = 3;
+  p_chain = 10;
+
+  pcouple = NONE;
+  pstyle = ANISO;
+
+  for (int i = 0; i < 3; i++) {
+    p_start[i] = p_stop[i] = p_period[i] = 0.0;
+    p_flag[i] = 0;
+  }
+
+  int iarg = 4;
+  while (iarg < narg) {
+    if (strcmp(arg[iarg],"langevin") == 0) {
+      if (iarg+5 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if ((strcmp(style,"rigid/small") != 0) &&
+          (strcmp(style,"rigid/nve/small") != 0) &&
+          (strcmp(style,"rigid/nph/small") != 0))
+        error->all(FLERR,"Illegal fix rigid/small command");
+      langflag = 1;
+      t_start = force->numeric(FLERR,arg[iarg+1]);
+      t_stop = force->numeric(FLERR,arg[iarg+2]);
+      t_period = force->numeric(FLERR,arg[iarg+3]);
+      seed = force->inumeric(FLERR,arg[iarg+4]);
+      if (t_period <= 0.0)
+        error->all(FLERR,"Fix rigid/small langevin period must be > 0.0");
+      if (seed <= 0) error->all(FLERR,"Illegal fix rigid/small command");
+      iarg += 5;
+
+    } else if (strcmp(arg[iarg],"infile") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      delete [] infile;
+      int n = strlen(arg[iarg+1]) + 1;
+      infile = new char[n];
+      strcpy(infile,arg[iarg+1]);
+      restart_file = 1;
+      reinitflag = 0;
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"reinit") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp("yes",arg[iarg+1]) == 0) reinitflag = 1;
+      else if  (strcmp("no",arg[iarg+1]) == 0) reinitflag = 0;
+      else error->all(FLERR,"Illegal fix rigid/small command");
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"mol") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      int imol = atom->find_molecule(arg[iarg+1]);
+      if (imol == -1)
+        error->all(FLERR,"Molecule template ID for "
+                   "fix rigid/small does not exist");
+      onemols = &atom->molecules[imol];
+      nmol = onemols[0]->nset;
+      restart_file = 1;
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"temp") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp(style,"rigid/nvt/small") != 0 &&
+          strcmp(style,"rigid/npt/small") != 0)
+        error->all(FLERR,"Illegal fix rigid command");
+      tstat_flag = 1;
+      t_start = force->numeric(FLERR,arg[iarg+1]);
+      t_stop = force->numeric(FLERR,arg[iarg+2]);
+      t_period = force->numeric(FLERR,arg[iarg+3]);
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"iso") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp(style,"rigid/npt/small") != 0 &&
+          strcmp(style,"rigid/nph/small") != 0)
+	      error->all(FLERR,"Illegal fix rigid/small command");
+      pcouple = XYZ;
+      p_start[0] = p_start[1] = p_start[2] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[0] = p_stop[1] = p_stop[2] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[0] = p_period[1] = p_period[2] =
+        force->numeric(FLERR,arg[iarg+3]);
+      p_flag[0] = p_flag[1] = p_flag[2] = 1;
+      if (domain->dimension == 2) {
+	      p_start[2] = p_stop[2] = p_period[2] = 0.0;
+      	p_flag[2] = 0;
+      }
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"aniso") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp(style,"rigid/npt/small") != 0 &&
+          strcmp(style,"rigid/nph/small") != 0)
+	      error->all(FLERR,"Illegal fix rigid/small command");
+      p_start[0] = p_start[1] = p_start[2] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[0] = p_stop[1] = p_stop[2] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[0] = p_period[1] = p_period[2] =
+        force->numeric(FLERR,arg[iarg+3]);
+      p_flag[0] = p_flag[1] = p_flag[2] = 1;
+      if (domain->dimension == 2) {
+      	p_start[2] = p_stop[2] = p_period[2] = 0.0;
+	      p_flag[2] = 0;
+      }
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"x") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      p_start[0] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[0] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[0] = force->numeric(FLERR,arg[iarg+3]);
+      p_flag[0] = 1;
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"y") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      p_start[1] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[1] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[1] = force->numeric(FLERR,arg[iarg+3]);
+      p_flag[1] = 1;
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"z") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      p_start[2] = force->numeric(FLERR,arg[iarg+1]);
+      p_stop[2] = force->numeric(FLERR,arg[iarg+2]);
+      p_period[2] = force->numeric(FLERR,arg[iarg+3]);
+      p_flag[2] = 1;
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"couple") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp(arg[iarg+1],"xyz") == 0) pcouple = XYZ;
+      else if (strcmp(arg[iarg+1],"xy") == 0) pcouple = XY;
+      else if (strcmp(arg[iarg+1],"yz") == 0) pcouple = YZ;
+      else if (strcmp(arg[iarg+1],"xz") == 0) pcouple = XZ;
+      else if (strcmp(arg[iarg+1],"none") == 0) pcouple = NONE;
+      else error->all(FLERR,"Illegal fix rigid/small command");
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"dilate") == 0) {
+      if (iarg+2 > narg)
+        error->all(FLERR,"Illegal fix rigid/small nvt/npt/nph command");
+      if (strcmp(arg[iarg+1],"all") == 0) allremap = 1;
+      else {
+        allremap = 0;
+        delete [] id_dilate;
+        int n = strlen(arg[iarg+1]) + 1;
+        id_dilate = new char[n];
+        strcpy(id_dilate,arg[iarg+1]);
+        int idilate = group->find(id_dilate);
+        if (idilate == -1)
+          error->all(FLERR,"Fix rigid/small nvt/npt/nph dilate group ID "
+                     "does not exist");
+      }
+      iarg += 2;
+
+    } else if (strcmp(arg[iarg],"tparam") == 0) {
+      if (iarg+4 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp(style,"rigid/nvt/small") != 0 &&
+          strcmp(style,"rigid/npt/small") != 0)
+        error->all(FLERR,"Illegal fix rigid/small command");
+      t_chain = force->numeric(FLERR,arg[iarg+1]);
+      t_iter = force->numeric(FLERR,arg[iarg+2]);
+      t_order = force->numeric(FLERR,arg[iarg+3]);
+      iarg += 4;
+
+    } else if (strcmp(arg[iarg],"pchain") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix rigid/small command");
+      if (strcmp(style,"rigid/npt/small") != 0 &&
+          strcmp(style,"rigid/nph/small") != 0)
+        error->all(FLERR,"Illegal fix rigid/small command");
+      p_chain = force->numeric(FLERR,arg[iarg+1]);
+      iarg += 2;
+
+
+    } else error->all(FLERR,"Illegal fix rigid/small command");
+  }
+
+  // error check and further setup for Molecule template
+
+  if (onemols) {
+    for (int i = 0; i < nmol; i++) {
+      if (onemols[i]->xflag == 0)
+        error->all(FLERR,"Fix rigid/small molecule must have coordinates");
+      if (onemols[i]->typeflag == 0)
+        error->all(FLERR,"Fix rigid/small molecule must have atom types");
+
+      // fix rigid/small uses center, masstotal, COM, inertia of molecule
+
+      onemols[i]->compute_center();
+      onemols[i]->compute_mass();
+      onemols[i]->compute_com();
+      onemols[i]->compute_inertia();
+    }
+  }
+
+  // set pstat_flag
+
+  pstat_flag = 0;
+  for (int i = 0; i < 3; i++)
+    if (p_flag[i]) pstat_flag = 1;
+
+  if (pcouple == XYZ || (domain->dimension == 2 && pcouple == XY)) pstyle = ISO;
+  else pstyle = ANISO;
+
+  // create rigid bodies based on molecule ID
+  // sets bodytag for owned atoms
+  // body attributes are computed later by setup_bodies()
+
+  create_bodies();
+
+  // set nlocal_body and allocate bodies I own
+
+  tagint *tag = atom->tag;
+
+  nlocal_body = nghost_body = 0;
+  for (i = 0; i < nlocal; i++)
+    if (bodytag[i] == tag[i]) nlocal_body++;
+
+  nmax_body = 0;
+  while (nmax_body < nlocal_body) nmax_body += DELTA_BODY;
+  body = (Body *) memory->smalloc(nmax_body*sizeof(Body),
+                                  "rigid/small:body");
+
+  // set bodyown for owned atoms
+
+  nlocal_body = 0;
+  for (i = 0; i < nlocal; i++)
+    if (bodytag[i] == tag[i]) {
+      body[nlocal_body].ilocal = i;
+      bodyown[i] = nlocal_body++;
+    } else bodyown[i] = -1;
+
+
+  // bodysize = sizeof(Body) in doubles
+
+  bodysize = sizeof(Body)/sizeof(double);
+  if (bodysize*sizeof(double) != sizeof(Body)) bodysize++;
+
+  // set max comm sizes needed by this fix
+
+  comm_forward = 1 + bodysize;
+  comm_reverse = 6;
+
+  // bitmasks for properties of extended particles
+
+  POINT = 1;
+  SPHERE = 2;
+  ELLIPSOID = 4;
+  LINE = 8;
+  TRIANGLE = 16;
+  DIPOLE = 32;
+  OMEGA = 64;
+  ANGMOM = 128;
+  TORQUE = 256;
+
+  MINUSPI = -MY_PI;
+  TWOPI = 2.0*MY_PI;
+
+  // atom style pointers to particles that store extra info
+
+  avec_ellipsoid = (AtomVecEllipsoid *) atom->style_match("ellipsoid");
+  avec_line = (AtomVecLine *) atom->style_match("line");
+  avec_tri = (AtomVecTri *) atom->style_match("tri");
+
+  // print statistics
+
+  int one = 0;
+  bigint atomone = 0;
+  for (int i = 0; i < nlocal; i++) {
+    if (bodyown[i] >= 0) one++;
+    if (bodytag[i] > 0) atomone++;
+  }
+  MPI_Allreduce(&one,&nbody,1,MPI_INT,MPI_SUM,world);
+  bigint atomall;
+  MPI_Allreduce(&atomone,&atomall,1,MPI_LMP_BIGINT,MPI_SUM,world);
+
+  if (me == 0) {
+    if (screen) {
+      fprintf(screen,"%d rigid bodies with " BIGINT_FORMAT " atoms\n",
+              nbody,atomall);
+      fprintf(screen,"  %g = max distance from body owner to body atom\n",
+              maxextent);
+    }
+    if (logfile) {
+      fprintf(logfile,"%d rigid bodies with " BIGINT_FORMAT " atoms\n",
+              nbody,atomall);
+      fprintf(logfile,"  %g = max distance from body owner to body atom\n",
+              maxextent);
+    }
+  }
+
+  // initialize Marsaglia RNG with processor-unique seed
+
+  maxlang = 0;
+  langextra = NULL;
+  random = NULL;
+  if (langflag) random = new RanMars(lmp,seed + comm->me);
+
+  // mass vector for granular pair styles
+
+  mass_body = NULL;
+  nmax_mass = 0;
+
+  // wait to setup bodies until comm stencils are defined
+
+  setupflag = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixRigidSmall::~FixRigidSmall()
+{
+  // unregister callbacks to this fix from Atom class
+
+  atom->delete_callback(id,0);
+
+  // delete locally stored arrays
+
+  memory->sfree(body);
+
+  memory->destroy(bodyown);
+  memory->destroy(bodytag);
+  memory->destroy(atom2body);
+  memory->destroy(xcmimage);
+  memory->destroy(displace);
+  memory->destroy(eflags);
+  memory->destroy(orient);
+  memory->destroy(dorient);
+
+  delete random;
+  delete [] infile;
+
+  memory->destroy(langextra);
+  memory->destroy(mass_body);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixRigidSmall::setmask()
+{
+  int mask = 0;
+  mask |= INITIAL_INTEGRATE;
+  mask |= FINAL_INTEGRATE;
+  if (langflag) mask |= POST_FORCE;
+  mask |= PRE_NEIGHBOR;
+  mask |= INITIAL_INTEGRATE_RESPA;
+  mask |= FINAL_INTEGRATE_RESPA;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSmall::init()
+{
+  int i;
+
+  triclinic = domain->triclinic;
+
+  // warn if more than one rigid fix
+
+  int count = 0;
+  for (i = 0; i < modify->nfix; i++)
+    if (strcmp(modify->fix[i]->style,"rigid") == 0) count++;
+  if (count > 1 && me == 0) error->warning(FLERR,"More than one fix rigid");
+
+  // error if npt,nph fix comes before rigid fix
+
+  for (i = 0; i < modify->nfix; i++) {
+    if (strcmp(modify->fix[i]->style,"npt") == 0) break;
+    if (strcmp(modify->fix[i]->style,"nph") == 0) break;
+  }
+  if (i < modify->nfix) {
+    for (int j = i; j < modify->nfix; j++)
+      if (strcmp(modify->fix[j]->style,"rigid") == 0)
+        error->all(FLERR,"Rigid fix must come before NPT/NPH fix");
+  }
+
+  // timestep info
+
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+  dtq = 0.5 * update->dt;
+
+  if (strstr(update->integrate_style,"respa"))
+    step_respa = ((Respa *) update->integrate)->step;
+}
+
+/* ----------------------------------------------------------------------
+   setup static/dynamic properties of rigid bodies, using current atom info.
+   if reinitflag is not set, do the initialization only once, b/c properties
+   may not be re-computable especially if overlapping particles or bodies
+   are inserted from mol template.
+     do not do dynamic init if read body properties from infile. this
+   is b/c the infile defines the static and dynamic properties and may not
+   be computable if contain overlapping particles setup_bodies_static()
+   reads infile itself.
+     cannot do this until now, b/c requires comm->setup() to have setup stencil
+   invoke pre_neighbor() to insure body xcmimage flags are reset
+     needed if Verlet::setup::pbc() has remapped/migrated atoms for 2nd run
+     setup_bodies_static() invokes pre_neighbor itself
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::setup_pre_neighbor()
+{
+  if (reinitflag || !setupflag)
+    setup_bodies_static();
+  else pre_neighbor();
+
+  if ((reinitflag || !setupflag) && !infile)
+    setup_bodies_dynamic();
+
+  setupflag = 1;
+}
+
+/* ----------------------------------------------------------------------
+   compute initial fcm and torque on bodies, also initial virial
+   reset all particle velocities to be consistent with vcm and omega
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::setup(int vflag)
+{
+  int i,n,ibody;
+
+  //check(1);
+
+  // sum fcm, torque across all rigid bodies
+  // fcm = force on COM
+  // torque = torque around COM
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int nlocal = atom->nlocal;
+
+  double *xcm,*fcm,*tcm;
+  double dx,dy,dz;
+  double unwrap[3];
+
+  for (ibody = 0; ibody < nlocal_body+nghost_body; ibody++) {
+    fcm = body[ibody].fcm;
+    fcm[0] = fcm[1] = fcm[2] = 0.0;
+    tcm = body[ibody].torque;
+    tcm[0] = tcm[1] = tcm[2] = 0.0;
+  }
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    fcm = b->fcm;
+    fcm[0] += f[i][0];
+    fcm[1] += f[i][1];
+    fcm[2] += f[i][2];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    xcm = b->xcm;
+    dx = unwrap[0] - xcm[0];
+    dy = unwrap[1] - xcm[1];
+    dz = unwrap[2] - xcm[2];
+
+    tcm = b->torque;
+    tcm[0] += dy * f[i][2] - dz * f[i][1];
+    tcm[1] += dz * f[i][0] - dx * f[i][2];
+    tcm[2] += dx * f[i][1] - dy * f[i][0];
+  }
+
+  // extended particles add their rotation/torque to angmom/torque of body
+
+  if (extended) {
+    double **torque = atom->torque;
+
+    for (i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+      Body *b = &body[atom2body[i]];
+      if (eflags[i] & TORQUE) {
+        tcm = b->torque;
+        tcm[0] += torque[i][0];
+        tcm[1] += torque[i][1];
+        tcm[2] += torque[i][2];
+      }
+    }
+  }
+
+  // reverse communicate fcm, torque of all bodies
+
+  commflag = FORCE_TORQUE;
+  comm->reverse_comm_fix(this,6);
+
+  // virial setup before call to set_v
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // compute and forward communicate vcm and omega of all bodies
+
+  for (ibody = 0; ibody < nlocal_body; ibody++) {
+    Body *b = &body[ibody];
+    MathExtra::angmom_to_omega(b->angmom,b->ex_space,b->ey_space,
+                               b->ez_space,b->inertia,b->omega);
+  }
+
+  commflag = FINAL;
+  comm->forward_comm_fix(this,10);
+
+  // set velocity/rotation of atoms in rigid bodues
+
+  set_v();
+
+  // guesstimate virial as 2x the set_v contribution
+
+  if (vflag_global)
+    for (n = 0; n < 6; n++) virial[n] *= 2.0;
+  if (vflag_atom) {
+    for (i = 0; i < nlocal; i++)
+      for (n = 0; n < 6; n++)
+        vatom[i][n] *= 2.0;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSmall::initial_integrate(int vflag)
+{
+  double dtfm;
+
+  //check(2);
+
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    Body *b = &body[ibody];
+
+    // update vcm by 1/2 step
+
+    dtfm = dtf / b->mass;
+    b->vcm[0] += dtfm * b->fcm[0];
+    b->vcm[1] += dtfm * b->fcm[1];
+    b->vcm[2] += dtfm * b->fcm[2];
+
+    // update xcm by full step
+
+    b->xcm[0] += dtv * b->vcm[0];
+    b->xcm[1] += dtv * b->vcm[1];
+    b->xcm[2] += dtv * b->vcm[2];
+
+    // update angular momentum by 1/2 step
+
+    b->angmom[0] += dtf * b->torque[0];
+    b->angmom[1] += dtf * b->torque[1];
+    b->angmom[2] += dtf * b->torque[2];
+
+    // compute omega at 1/2 step from angmom at 1/2 step and current q
+    // update quaternion a full step via Richardson iteration
+    // returns new normalized quaternion, also updated omega at 1/2 step
+    // update ex,ey,ez to reflect new quaternion
+
+    MathExtra::angmom_to_omega(b->angmom,b->ex_space,b->ey_space,
+                               b->ez_space,b->inertia,b->omega);
+    MathExtra::richardson(b->quat,b->angmom,b->omega,b->inertia,dtq);
+    MathExtra::q_to_exyz(b->quat,b->ex_space,b->ey_space,b->ez_space);
+  }
+
+  // virial setup before call to set_xv
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // forward communicate updated info of all bodies
+
+  commflag = INITIAL;
+  comm->forward_comm_fix(this,26);
+
+  // set coords/orient and velocity/rotation of atoms in rigid bodies
+
+  set_xv();
+}
+
+/* ----------------------------------------------------------------------
+   apply Langevin thermostat to all 6 DOF of rigid bodies I own
+   unlike fix langevin, this stores extra force in extra arrays,
+     which are added in when final_integrate() calculates a new fcm/torque
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::post_force(int vflag)
+{
+  double gamma1,gamma2;
+
+  // grow langextra if needed
+
+  if (nlocal_body > maxlang) {
+    memory->destroy(langextra);
+    maxlang = nlocal_body + nghost_body;
+    memory->create(langextra,maxlang,6,"rigid/small:langextra");
+  }
+
+  double delta = update->ntimestep - update->beginstep;
+  delta /= update->endstep - update->beginstep;
+  double t_target = t_start + delta * (t_stop-t_start);
+  double tsqrt = sqrt(t_target);
+
+  double boltz = force->boltz;
+  double dt = update->dt;
+  double mvv2e = force->mvv2e;
+  double ftm2v = force->ftm2v;
+
+  double *vcm,*omega,*inertia;
+
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    vcm = body[ibody].vcm;
+    omega = body[ibody].omega;
+    inertia = body[ibody].inertia;
+    
+    gamma1 = -body[ibody].mass / t_period / ftm2v;
+    gamma2 = sqrt(body[ibody].mass) * tsqrt *
+      sqrt(24.0*boltz/t_period/dt/mvv2e) / ftm2v;
+    langextra[ibody][0] = gamma1*vcm[0] + gamma2*(random->uniform()-0.5);
+    langextra[ibody][1] = gamma1*vcm[1] + gamma2*(random->uniform()-0.5);
+    langextra[ibody][2] = gamma1*vcm[2] + gamma2*(random->uniform()-0.5);
+    
+    gamma1 = -1.0 / t_period / ftm2v;
+    gamma2 = tsqrt * sqrt(24.0*boltz/t_period/dt/mvv2e) / ftm2v;
+    langextra[ibody][3] = inertia[0]*gamma1*omega[0] +
+      sqrt(inertia[0])*gamma2*(random->uniform()-0.5);
+    langextra[ibody][4] = inertia[1]*gamma1*omega[1] +
+      sqrt(inertia[1])*gamma2*(random->uniform()-0.5);
+    langextra[ibody][5] = inertia[2]*gamma1*omega[2] +
+      sqrt(inertia[2])*gamma2*(random->uniform()-0.5);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   called from FixEnforce post_force() for 2d problems
+   zero all body values that should be zero for 2d model
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::enforce2d()
+{
+  Body *b;
+
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    b = &body[ibody];
+    b->xcm[2] = 0.0;
+    b->vcm[2] = 0.0;
+    b->fcm[2] = 0.0;
+    b->torque[0] = 0.0;
+    b->torque[1] = 0.0;
+    b->angmom[0] = 0.0;
+    b->angmom[1] = 0.0;
+    b->omega[0] = 0.0;
+    b->omega[1] = 0.0;
+    if (langflag && langextra) {
+      langextra[ibody][2] = 0.0;
+      langextra[ibody][3] = 0.0;
+      langextra[ibody][4] = 0.0;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSmall::final_integrate()
+{
+  int i,ibody;
+  double dtfm;
+
+  //check(3);
+
+  // sum over atoms to get force and torque on rigid body
+
+  double **x = atom->x;
+  double **f = atom->f;
+  int nlocal = atom->nlocal;
+
+  double dx,dy,dz;
+  double unwrap[3];
+  double *xcm,*fcm,*tcm;
+
+  for (ibody = 0; ibody < nlocal_body+nghost_body; ibody++) {
+    fcm = body[ibody].fcm;
+    fcm[0] = fcm[1] = fcm[2] = 0.0;
+    tcm = body[ibody].torque;
+    tcm[0] = tcm[1] = tcm[2] = 0.0;
+  }
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    fcm = b->fcm;
+    fcm[0] += f[i][0];
+    fcm[1] += f[i][1];
+    fcm[2] += f[i][2];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    xcm = b->xcm;
+    dx = unwrap[0] - xcm[0];
+    dy = unwrap[1] - xcm[1];
+    dz = unwrap[2] - xcm[2];
+
+    tcm = b->torque;
+    tcm[0] += dy*f[i][2] - dz*f[i][1];
+    tcm[1] += dz*f[i][0] - dx*f[i][2];
+    tcm[2] += dx*f[i][1] - dy*f[i][0];
+  }
+
+  // extended particles add their torque to torque of body
+
+  if (extended) {
+    double **torque = atom->torque;
+
+    for (i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+
+      if (eflags[i] & TORQUE) {
+        tcm = body[atom2body[i]].torque;
+        tcm[0] += torque[i][0];
+        tcm[1] += torque[i][1];
+        tcm[2] += torque[i][2];
+      }
+    }
+  }
+
+  // reverse communicate fcm, torque of all bodies
+
+  commflag = FORCE_TORQUE;
+  comm->reverse_comm_fix(this,6);
+
+  // include Langevin thermostat forces and torques
+
+  if (langflag) {
+    for (int ibody = 0; ibody < nlocal_body; ibody++) {
+      fcm = body[ibody].fcm;
+      fcm[0] += langextra[ibody][0];
+      fcm[1] += langextra[ibody][1];
+      fcm[2] += langextra[ibody][2];
+      tcm = body[ibody].torque;
+      tcm[0] += langextra[ibody][3];
+      tcm[1] += langextra[ibody][4];
+      tcm[2] += langextra[ibody][5];
+    }
+  }
+
+  // update vcm and angmom, recompute omega
+
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    Body *b = &body[ibody];
+
+    // update vcm by 1/2 step
+
+    dtfm = dtf / b->mass;
+    b->vcm[0] += dtfm * b->fcm[0];
+    b->vcm[1] += dtfm * b->fcm[1];
+    b->vcm[2] += dtfm * b->fcm[2];
+
+    // update angular momentum by 1/2 step
+
+    b->angmom[0] += dtf * b->torque[0];
+    b->angmom[1] += dtf * b->torque[1];
+    b->angmom[2] += dtf * b->torque[2];
+
+    MathExtra::angmom_to_omega(b->angmom,b->ex_space,b->ey_space,
+                               b->ez_space,b->inertia,b->omega);
+  }
+
+  // forward communicate updated info of all bodies
+
+  commflag = FINAL;
+  comm->forward_comm_fix(this,10);
+
+  // set velocity/rotation of atoms in rigid bodies
+  // virial is already setup from initial_integrate
+
+  set_v();
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSmall::initial_integrate_respa(int vflag, int ilevel, int iloop)
+{
+  dtv = step_respa[ilevel];
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+  dtq = 0.5 * step_respa[ilevel];
+
+  if (ilevel == 0) initial_integrate(vflag);
+  else final_integrate();
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSmall::final_integrate_respa(int ilevel, int iloop)
+{
+  dtf = 0.5 * step_respa[ilevel] * force->ftm2v;
+  final_integrate();
+}
+
+/* ----------------------------------------------------------------------
+   remap xcm of each rigid body back into periodic simulation box
+   done during pre_neighbor so will be after call to pbc()
+     and after fix_deform::pre_exchange() may have flipped box
+   use domain->remap() in case xcm is far away from box
+     due to first-time definition of rigid body in setup_bodies_static()
+     or due to box flip
+   also adjust imagebody = rigid body image flags, due to xcm remap
+   then communicate bodies so other procs will know of changes to body xcm
+   then adjust xcmimage flags of all atoms in bodies via image_shift()
+     for two effects
+     (1) change in true image flags due to pbc() call during exchange
+     (2) change in imagebody due to xcm remap
+   xcmimage flags are always -1,0,-1 so that body can be unwrapped
+     around in-box xcm and stay close to simulation box
+   if just inferred unwrapped from atom image flags,
+     then a body could end up very far away
+     when unwrapped by true image flags
+   then set_xv() will compute huge displacements every step to reset coords of
+     all the body atoms to be back inside the box, ditto for triclinic box flip
+     note: so just want to avoid that numeric probem?
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::pre_neighbor()
+{
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    Body *b = &body[ibody];
+    domain->remap(b->xcm,b->image);
+  }
+
+  nghost_body = 0;
+  commflag = FULL_BODY;
+  comm->forward_comm_fix(this);
+  reset_atom2body();
+  //check(4);
+
+  image_shift();
+}
+
+/* ----------------------------------------------------------------------
+   reset body xcmimage flags of atoms in bodies
+   xcmimage flags are relative to xcm so that body can be unwrapped
+   xcmimage = true image flag - imagebody flag
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::image_shift()
+{
+  imageint tdim,bdim,xdim[3];
+
+  imageint *image = atom->image;
+  int nlocal = atom->nlocal;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    tdim = image[i] & IMGMASK;
+    bdim = b->image & IMGMASK;
+    xdim[0] = IMGMAX + tdim - bdim;
+    tdim = (image[i] >> IMGBITS) & IMGMASK;
+    bdim = (b->image >> IMGBITS) & IMGMASK;
+    xdim[1] = IMGMAX + tdim - bdim;
+    tdim = image[i] >> IMG2BITS;
+    bdim = b->image >> IMG2BITS;
+    xdim[2] = IMGMAX + tdim - bdim;
+
+    xcmimage[i] = (xdim[2] << IMG2BITS) | (xdim[1] << IMGBITS) | xdim[0];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   count # of DOF removed by rigid bodies for atoms in igroup
+   return total count of DOF
+------------------------------------------------------------------------- */
+
+int FixRigidSmall::dof(int tgroup)
+{
+  int i,j;
+
+  // cannot count DOF correctly unless setup_bodies_static() has been called
+
+  if (!setupflag) {
+    if (comm->me == 0)
+      error->warning(FLERR,"Cannot count rigid body degrees-of-freedom "
+                     "before bodies are fully initialized");
+    return 0;
+  }
+
+  int tgroupbit = group->bitmask[tgroup];
+
+  // counts = 3 values per rigid body I own
+  // 0 = # of point particles in rigid body and in temperature group
+  // 1 = # of finite-size particles in rigid body and in temperature group
+  // 2 = # of particles in rigid body, disregarding temperature group
+
+  memory->create(counts,nlocal_body+nghost_body,3,"rigid/small:counts");
+  for (int i = 0; i < nlocal_body+nghost_body; i++)
+    counts[i][0] = counts[i][1] = counts[i][2] = 0;
+
+  // tally counts from my owned atoms
+  // 0 = # of point particles in rigid body and in temperature group
+  // 1 = # of finite-size particles in rigid body and in temperature group
+  // 2 = # of particles in rigid body, disregarding temperature group
+
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    j = atom2body[i];
+    counts[j][2]++;
+    if (mask[i] & tgroupbit) {
+      if (extended && (eflags[i] & ~(POINT | DIPOLE))) counts[j][1]++;
+      else counts[j][0]++;
+    }
+  }
+
+  commflag = DOF;
+  comm->reverse_comm_fix(this,3);
+
+  // nall = count0 = # of point particles in each rigid body
+  // mall = count1 = # of finite-size particles in each rigid body
+  // warn if nall+mall != nrigid for any body included in temperature group
+
+  int flag = 0;
+  for (int ibody = 0; ibody < nlocal_body; ibody++) {
+    if (counts[ibody][0]+counts[ibody][1] > 0 &&
+        counts[ibody][0]+counts[ibody][1] != counts[ibody][2]) flag = 1;
+  }
+  int flagall;
+  MPI_Allreduce(&flag,&flagall,1,MPI_INT,MPI_MAX,world);
+  if (flagall && me == 0)
+    error->warning(FLERR,"Computing temperature of portions of rigid bodies");
+
+  // remove appropriate DOFs for each rigid body wholly in temperature group
+  // N = # of point particles in body
+  // M = # of finite-size particles in body
+  // 3d body has 3N + 6M dof to start with
+  // 2d body has 2N + 3M dof to start with
+  // 3d point-particle body with all non-zero I should have 6 dof, remove 3N-6
+  // 3d point-particle body (linear) with a 0 I should have 5 dof, remove 3N-5
+  // 2d point-particle body should have 3 dof, remove 2N-3
+  // 3d body with any finite-size M should have 6 dof, remove (3N+6M) - 6
+  // 2d body with any finite-size M should have 3 dof, remove (2N+3M) - 3
+
+  double *inertia;
+
+  int n = 0;
+  nlinear = 0;
+  if (domain->dimension == 3) {
+    for (int ibody = 0; ibody < nlocal_body; ibody++) {
+      if (counts[ibody][0]+counts[ibody][1] == counts[ibody][2]) {
+        n += 3*counts[ibody][0] + 6*counts[ibody][1] - 6;
+        inertia = body[ibody].inertia;
+        if (inertia[0] == 0.0 || inertia[1] == 0.0 || inertia[2] == 0.0) {
+          n++;
+          nlinear++;
+        }
+      }
+    }
+  } else if (domain->dimension == 2) {
+    for (int ibody = 0; ibody < nlocal_body; ibody++)
+      if (counts[ibody][0]+counts[ibody][1] == counts[ibody][2])
+        n += 2*counts[ibody][0] + 3*counts[ibody][1] - 3;
+  }
+
+  memory->destroy(counts);
+
+  int nall;
+  MPI_Allreduce(&n,&nall,1,MPI_INT,MPI_SUM,world);
+  return nall;
+}
+
+/* ----------------------------------------------------------------------
+   adjust xcm of each rigid body due to box deformation
+   called by various fixes that change box size/shape
+   flag = 0/1 means map from box to lamda coords or vice versa
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::deform(int flag)
+{
+  if (flag == 0)
+    for (int ibody = 0; ibody < nlocal_body; ibody++)
+      domain->x2lamda(body[ibody].xcm,body[ibody].xcm);
+  else
+    for (int ibody = 0; ibody < nlocal_body; ibody++)
+      domain->lamda2x(body[ibody].xcm,body[ibody].xcm);
+}
+
+/* ----------------------------------------------------------------------
+   set space-frame coords and velocity of each atom in each rigid body
+   set orientation and rotation of extended particles
+   x = Q displace + Xcm, mapped back to periodic box
+   v = Vcm + (W cross (x - Xcm))
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::set_xv()
+{
+  int xbox,ybox,zbox;
+  double x0,x1,x2,v0,v1,v2,fc0,fc1,fc2,massone;
+  double ione[3],exone[3],eyone[3],ezone[3],vr[6],p[3][3];
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+  double xy = domain->xy;
+  double xz = domain->xz;
+  double yz = domain->yz;
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  // set x and v of each atom
+
+  for (int i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+    ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+    // save old positions and velocities for virial
+
+    if (evflag) {
+      if (triclinic == 0) {
+        x0 = x[i][0] + xbox*xprd;
+        x1 = x[i][1] + ybox*yprd;
+        x2 = x[i][2] + zbox*zprd;
+      } else {
+        x0 = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+        x1 = x[i][1] + ybox*yprd + zbox*yz;
+        x2 = x[i][2] + zbox*zprd;
+      }
+      v0 = v[i][0];
+      v1 = v[i][1];
+      v2 = v[i][2];
+    }
+
+    // x = displacement from center-of-mass, based on body orientation
+    // v = vcm + omega around center-of-mass
+
+    MathExtra::matvec(b->ex_space,b->ey_space,b->ez_space,displace[i],x[i]);
+
+    v[i][0] = b->omega[1]*x[i][2] - b->omega[2]*x[i][1] + b->vcm[0];
+    v[i][1] = b->omega[2]*x[i][0] - b->omega[0]*x[i][2] + b->vcm[1];
+    v[i][2] = b->omega[0]*x[i][1] - b->omega[1]*x[i][0] + b->vcm[2];
+
+    // add center of mass to displacement
+    // map back into periodic box via xbox,ybox,zbox
+    // for triclinic, add in box tilt factors as well
+
+    if (triclinic == 0) {
+      x[i][0] += b->xcm[0] - xbox*xprd;
+      x[i][1] += b->xcm[1] - ybox*yprd;
+      x[i][2] += b->xcm[2] - zbox*zprd;
+    } else {
+      x[i][0] += b->xcm[0] - xbox*xprd - ybox*xy - zbox*xz;
+      x[i][1] += b->xcm[1] - ybox*yprd - zbox*yz;
+      x[i][2] += b->xcm[2] - zbox*zprd;
+    }
+
+    // virial = unwrapped coords dotted into body constraint force
+    // body constraint force = implied force due to v change minus f external
+    // assume f does not include forces internal to body
+    // 1/2 factor b/c final_integrate contributes other half
+    // assume per-atom contribution is due to constraint force on that atom
+
+    if (evflag) {
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+      fc0 = massone*(v[i][0] - v0)/dtf - f[i][0];
+      fc1 = massone*(v[i][1] - v1)/dtf - f[i][1];
+      fc2 = massone*(v[i][2] - v2)/dtf - f[i][2];
+
+      vr[0] = 0.5*x0*fc0;
+      vr[1] = 0.5*x1*fc1;
+      vr[2] = 0.5*x2*fc2;
+      vr[3] = 0.5*x0*fc1;
+      vr[4] = 0.5*x0*fc2;
+      vr[5] = 0.5*x1*fc2;
+
+      v_tally(1,&i,1.0,vr);
+    }
+  }
+
+  // set orientation, omega, angmom of each extended particle
+
+  if (extended) {
+    double theta_body,theta;
+    double *shape,*quatatom,*inertiaatom;
+
+    AtomVecEllipsoid::Bonus *ebonus;
+    if (avec_ellipsoid) ebonus = avec_ellipsoid->bonus;
+    AtomVecLine::Bonus *lbonus;
+    if (avec_line) lbonus = avec_line->bonus;
+    AtomVecTri::Bonus *tbonus;
+    if (avec_tri) tbonus = avec_tri->bonus;
+    double **omega = atom->omega;
+    double **angmom = atom->angmom;
+    double **mu = atom->mu;
+    int *ellipsoid = atom->ellipsoid;
+    int *line = atom->line;
+    int *tri = atom->tri;
+
+    for (int i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+      Body *b = &body[atom2body[i]];
+
+      if (eflags[i] & SPHERE) {
+        omega[i][0] = b->omega[0];
+        omega[i][1] = b->omega[1];
+        omega[i][2] = b->omega[2];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        quatatom = ebonus[ellipsoid[i]].quat;
+        MathExtra::quatquat(b->quat,orient[i],quatatom);
+        MathExtra::qnormalize(quatatom);
+        ione[0] = EINERTIA*rmass[i] * (shape[1]*shape[1] + shape[2]*shape[2]);
+        ione[1] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[2]*shape[2]);
+        ione[2] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[1]*shape[1]);
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(b->omega,exone,eyone,ezone,ione,angmom[i]);
+      } else if (eflags[i] & LINE) {
+        if (b->quat[3] >= 0.0) theta_body = 2.0*acos(b->quat[0]);
+        else theta_body = -2.0*acos(b->quat[0]);
+        theta = orient[i][0] + theta_body;
+        while (theta <= MINUSPI) theta += TWOPI;
+        while (theta > MY_PI) theta -= TWOPI;
+        lbonus[line[i]].theta = theta;
+        omega[i][0] = b->omega[0];
+        omega[i][1] = b->omega[1];
+        omega[i][2] = b->omega[2];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::quatquat(b->quat,orient[i],quatatom);
+        MathExtra::qnormalize(quatatom);
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(b->omega,exone,eyone,ezone,
+                                   inertiaatom,angmom[i]);
+      }
+      if (eflags[i] & DIPOLE) {
+        MathExtra::quat_to_mat(b->quat,p);
+        MathExtra::matvec(p,dorient[i],mu[i]);
+        MathExtra::snormalize3(mu[i][3],mu[i],mu[i]);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   set space-frame velocity of each atom in a rigid body
+   set omega and angmom of extended particles
+   v = Vcm + (W cross (x - Xcm))
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::set_v()
+{
+  int xbox,ybox,zbox;
+  double x0,x1,x2,v0,v1,v2,fc0,fc1,fc2,massone;
+  double ione[3],exone[3],eyone[3],ezone[3],delta[3],vr[6];
+
+  double xprd = domain->xprd;
+  double yprd = domain->yprd;
+  double zprd = domain->zprd;
+  double xy = domain->xy;
+  double xz = domain->xz;
+  double yz = domain->yz;
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double **f = atom->f;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  // set v of each atom
+
+  for (int i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    MathExtra::matvec(b->ex_space,b->ey_space,b->ez_space,displace[i],delta);
+
+    // save old velocities for virial
+
+    if (evflag) {
+      v0 = v[i][0];
+      v1 = v[i][1];
+      v2 = v[i][2];
+    }
+
+    v[i][0] = b->omega[1]*delta[2] - b->omega[2]*delta[1] + b->vcm[0];
+    v[i][1] = b->omega[2]*delta[0] - b->omega[0]*delta[2] + b->vcm[1];
+    v[i][2] = b->omega[0]*delta[1] - b->omega[1]*delta[0] + b->vcm[2];
+
+    // virial = unwrapped coords dotted into body constraint force
+    // body constraint force = implied force due to v change minus f external
+    // assume f does not include forces internal to body
+    // 1/2 factor b/c initial_integrate contributes other half
+    // assume per-atom contribution is due to constraint force on that atom
+
+    if (evflag) {
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+      fc0 = massone*(v[i][0] - v0)/dtf - f[i][0];
+      fc1 = massone*(v[i][1] - v1)/dtf - f[i][1];
+      fc2 = massone*(v[i][2] - v2)/dtf - f[i][2];
+
+      xbox = (xcmimage[i] & IMGMASK) - IMGMAX;
+      ybox = (xcmimage[i] >> IMGBITS & IMGMASK) - IMGMAX;
+      zbox = (xcmimage[i] >> IMG2BITS) - IMGMAX;
+
+      if (triclinic == 0) {
+        x0 = x[i][0] + xbox*xprd;
+        x1 = x[i][1] + ybox*yprd;
+        x2 = x[i][2] + zbox*zprd;
+      } else {
+        x0 = x[i][0] + xbox*xprd + ybox*xy + zbox*xz;
+        x1 = x[i][1] + ybox*yprd + zbox*yz;
+        x2 = x[i][2] + zbox*zprd;
+      }
+
+      vr[0] = 0.5*x0*fc0;
+      vr[1] = 0.5*x1*fc1;
+      vr[2] = 0.5*x2*fc2;
+      vr[3] = 0.5*x0*fc1;
+      vr[4] = 0.5*x0*fc2;
+      vr[5] = 0.5*x1*fc2;
+
+      v_tally(1,&i,1.0,vr);
+    }
+  }
+
+  // set omega, angmom of each extended particle
+
+  if (extended) {
+    double *shape,*quatatom,*inertiaatom;
+
+    AtomVecEllipsoid::Bonus *ebonus;
+    if (avec_ellipsoid) ebonus = avec_ellipsoid->bonus;
+    AtomVecTri::Bonus *tbonus;
+    if (avec_tri) tbonus = avec_tri->bonus;
+    double **omega = atom->omega;
+    double **angmom = atom->angmom;
+    int *ellipsoid = atom->ellipsoid;
+    int *tri = atom->tri;
+
+    for (int i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+      Body *b = &body[atom2body[i]];
+
+      if (eflags[i] & SPHERE) {
+        omega[i][0] = b->omega[0];
+        omega[i][1] = b->omega[1];
+        omega[i][2] = b->omega[2];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        quatatom = ebonus[ellipsoid[i]].quat;
+        ione[0] = EINERTIA*rmass[i] * (shape[1]*shape[1] + shape[2]*shape[2]);
+        ione[1] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[2]*shape[2]);
+        ione[2] = EINERTIA*rmass[i] * (shape[0]*shape[0] + shape[1]*shape[1]);
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(b->omega,exone,eyone,ezone,ione,
+                                   angmom[i]);
+      } else if (eflags[i] & LINE) {
+        omega[i][0] = b->omega[0];
+        omega[i][1] = b->omega[1];
+        omega[i][2] = b->omega[2];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::q_to_exyz(quatatom,exone,eyone,ezone);
+        MathExtra::omega_to_angmom(b->omega,exone,eyone,ezone,
+                                   inertiaatom,angmom[i]);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   one-time identification of which atoms are in which rigid bodies
+   set bodytag for all owned atoms
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::create_bodies()
+{
+  int i,m,n;
+  double unwrap[3];
+
+  // error check on image flags of atoms in rigid bodies
+
+  imageint *image = atom->image;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  int *periodicity = domain->periodicity;
+  int xbox,ybox,zbox;
+
+  int flag = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (!(mask[i] & groupbit)) continue;
+    xbox = (image[i] & IMGMASK) - IMGMAX;
+    ybox = (image[i] >> IMGBITS & IMGMASK) - IMGMAX;
+    zbox = (image[i] >> IMG2BITS) - IMGMAX;
+    if ((xbox && !periodicity[0]) || (ybox && !periodicity[1]) ||
+        (zbox && !periodicity[2])) flag = 1;
+  }
+
+  int flagall;
+  MPI_Allreduce(&flag,&flagall,1,MPI_INT,MPI_SUM,world);
+  if (flagall) error->all(FLERR,"Fix rigid/small atom has non-zero image flag "
+                          "in a non-periodic dimension");
+
+  // allocate buffer for passing messages around ring of procs
+  // percount = max number of values to put in buffer for each of ncount
+
+  int ncount = 0;
+  for (i = 0; i < nlocal; i++)
+    if (mask[i] & groupbit) ncount++;
+
+  int percount = 5;
+  double *buf;
+  memory->create(buf,ncount*percount,"rigid/small:buf");
+
+  // create map hash for storing unique molecule IDs of my atoms
+  // key = molecule ID
+  // value = index into per-body data structure
+  // n = # of entries in hash
+
+  hash = new std::map<tagint,int>();
+  hash->clear();
+
+  // setup hash
+  // key = body ID
+  // value = index into N-length data structure
+  // n = count of unique bodies my atoms are part of
+
+  tagint *molecule = atom->molecule;
+
+  n = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (!(mask[i] & groupbit)) continue;
+    if (hash->find(molecule[i]) == hash->end()) (*hash)[molecule[i]] = n++;
+  }
+
+  // bbox = bounding box of each rigid body my atoms are part of
+
+  memory->create(bbox,n,6,"rigid/small:bbox");
+
+  for (i = 0; i < n; i++) {
+    bbox[i][0] = bbox[i][2] = bbox[i][4] = BIG;
+    bbox[i][1] = bbox[i][3] = bbox[i][5] = -BIG;
+  }
+
+  // pack my atoms into buffer as molecule ID, unwrapped coords
+
+  double **x = atom->x;
+
+  m = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (!(mask[i] & groupbit)) continue;
+    domain->unmap(x[i],image[i],unwrap);
+    buf[m++] = molecule[i];
+    buf[m++] = unwrap[0];
+    buf[m++] = unwrap[1];
+    buf[m++] = unwrap[2];
+  }
+
+  // pass buffer around ring of procs
+  // func = update bbox with atom coords from every proc
+  // when done, have full bbox for every rigid body my atoms are part of
+
+  comm->ring(m,sizeof(double),buf,1,ring_bbox,NULL,(void *)this);
+
+  // check if any bbox is size 0.0, meaning rigid body is a single particle
+
+  flag = 0;
+  for (i = 0; i < n; i++)
+    if (bbox[i][0] == bbox[i][1] && bbox[i][2] == bbox[i][3] &&
+        bbox[i][4] == bbox[i][5]) flag = 1;
+  MPI_Allreduce(&flag,&flagall,1,MPI_INT,MPI_SUM,world);
+  if (flagall)
+    error->all(FLERR,"One or more rigid bodies are a single particle");
+
+  // ctr = center pt of each rigid body my atoms are part of
+
+  memory->create(ctr,n,6,"rigid/small:bbox");
+
+  for (i = 0; i < n; i++) {
+    ctr[i][0] = 0.5 * (bbox[i][0] + bbox[i][1]);
+    ctr[i][1] = 0.5 * (bbox[i][2] + bbox[i][3]);
+    ctr[i][2] = 0.5 * (bbox[i][4] + bbox[i][5]);
+  }
+
+  // idclose = ID of atom in body closest to center pt (smaller ID if tied)
+  // rsqclose = distance squared from idclose to center pt
+
+  memory->create(idclose,n,"rigid/small:idclose");
+  memory->create(rsqclose,n,"rigid/small:rsqclose");
+
+  for (i = 0; i < n; i++) rsqclose[i] = BIG;
+
+  // pack my atoms into buffer as molecule ID, atom ID, unwrapped coords
+
+  tagint *tag = atom->tag;
+
+  m = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (!(mask[i] & groupbit)) continue;
+    domain->unmap(x[i],image[i],unwrap);
+    buf[m++] = molecule[i];
+    buf[m++] = ubuf(tag[i]).d;
+    buf[m++] = unwrap[0];
+    buf[m++] = unwrap[1];
+    buf[m++] = unwrap[2];
+  }
+
+  // pass buffer around ring of procs
+  // func = update idclose,rsqclose with atom IDs from every proc
+  // when done, have idclose for every rigid body my atoms are part of
+
+  comm->ring(m,sizeof(double),buf,2,ring_nearest,NULL,(void *)this);
+
+  // set bodytag of all owned atoms, based on idclose
+  // find max value of rsqclose across all procs
+
+  double rsqmax = 0.0;
+  for (i = 0; i < nlocal; i++) {
+    bodytag[i] = 0;
+    if (!(mask[i] & groupbit)) continue;
+    m = hash->find(molecule[i])->second;
+    bodytag[i] = idclose[m];
+    rsqmax = MAX(rsqmax,rsqclose[m]);
+  }
+
+  // pack my atoms into buffer as bodytag of owning atom, unwrapped coords
+
+  m = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (!(mask[i] & groupbit)) continue;
+    domain->unmap(x[i],image[i],unwrap);
+    buf[m++] = ubuf(bodytag[i]).d;
+    buf[m++] = unwrap[0];
+    buf[m++] = unwrap[1];
+    buf[m++] = unwrap[2];
+  }
+
+  // pass buffer around ring of procs
+  // func = update rsqfar for atoms belonging to bodies I own
+  // when done, have rsqfar for all atoms in bodies I own
+
+  rsqfar = 0.0;
+  comm->ring(m,sizeof(double),buf,3,ring_farthest,NULL,(void *)this);
+
+  // find maxextent of rsqfar across all procs
+  // if defined, include molecule->maxextent
+
+  MPI_Allreduce(&rsqfar,&maxextent,1,MPI_DOUBLE,MPI_MAX,world);
+  maxextent = sqrt(maxextent);
+  if (onemols) {
+    for (int i = 0; i < nmol; i++)
+      maxextent = MAX(maxextent,onemols[i]->maxextent);
+  }
+
+  // clean up
+
+  delete hash;
+  memory->destroy(buf);
+  memory->destroy(bbox);
+  memory->destroy(ctr);
+  memory->destroy(idclose);
+  memory->destroy(rsqclose);
+}
+
+/* ----------------------------------------------------------------------
+   process rigid body atoms from another proc
+   update bounding box for rigid bodies my atoms are part of
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::ring_bbox(int n, char *cbuf, void *ptr)
+{
+  FixRigidSmall *frsptr = (FixRigidSmall *) ptr;
+  std::map<tagint,int> *hash = frsptr->hash;
+  double **bbox = frsptr->bbox;
+
+  double *buf = (double *) cbuf;
+  int ndatums = n/4;
+
+  int j,imol;
+  double *x;
+
+  int m = 0;
+  for (int i = 0; i < ndatums; i++, m += 4) {
+    imol = static_cast<int> (buf[m]);
+    if (hash->find(imol) != hash->end()) {
+      j = hash->find(imol)->second;
+      x = &buf[m+1];
+      bbox[j][0] = MIN(bbox[j][0],x[0]);
+      bbox[j][1] = MAX(bbox[j][1],x[0]);
+      bbox[j][2] = MIN(bbox[j][2],x[1]);
+      bbox[j][3] = MAX(bbox[j][3],x[1]);
+      bbox[j][4] = MIN(bbox[j][4],x[2]);
+      bbox[j][5] = MAX(bbox[j][5],x[2]);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   process rigid body atoms from another proc
+   update nearest atom to body center for rigid bodies my atoms are part of
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::ring_nearest(int n, char *cbuf, void *ptr)
+{
+  FixRigidSmall *frsptr = (FixRigidSmall *) ptr;
+  std::map<tagint,int> *hash = frsptr->hash;
+  double **ctr = frsptr->ctr;
+  tagint *idclose = frsptr->idclose;
+  double *rsqclose = frsptr->rsqclose;
+
+  double *buf = (double *) cbuf;
+  int ndatums = n/5;
+
+  int j,imol;
+  tagint tag;
+  double delx,dely,delz,rsq;
+  double *x;
+
+  int m = 0;
+  for (int i = 0; i < ndatums; i++, m += 5) {
+    imol = static_cast<int> (buf[m]);
+    if (hash->find(imol) != hash->end()) {
+      j = hash->find(imol)->second;
+      tag = (tagint) ubuf(buf[m+1]).i;
+      x = &buf[m+2];
+      delx = x[0] - ctr[j][0];
+      dely = x[1] - ctr[j][1];
+      delz = x[2] - ctr[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      if (rsq <= rsqclose[j]) {
+        if (rsq == rsqclose[j] && tag > idclose[j]) continue;
+        idclose[j] = tag;
+        rsqclose[j] = rsq;
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   process rigid body atoms from another proc
+   update rsqfar = distance from owning atom to other atom
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::ring_farthest(int n, char *cbuf, void *ptr)
+{
+  FixRigidSmall *frsptr = (FixRigidSmall *) ptr;
+  double **x = frsptr->atom->x;
+  imageint *image = frsptr->atom->image;
+  int nlocal = frsptr->atom->nlocal;
+
+  double *buf = (double *) cbuf;
+  int ndatums = n/4;
+
+  int iowner;
+  tagint tag;
+  double delx,dely,delz,rsq;
+  double *xx;
+  double unwrap[3];
+
+  int m = 0;
+  for (int i = 0; i < ndatums; i++, m += 4) {
+    tag = (tagint) ubuf(buf[m]).i;
+    iowner = frsptr->atom->map(tag);
+    if (iowner < 0 || iowner >= nlocal) continue;
+    frsptr->domain->unmap(x[iowner],image[iowner],unwrap);
+    xx = &buf[m+1];
+    delx = xx[0] - unwrap[0];
+    dely = xx[1] - unwrap[1];
+    delz = xx[2] - unwrap[2];
+    rsq = delx*delx + dely*dely + delz*delz;
+    frsptr->rsqfar = MAX(frsptr->rsqfar,rsq);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   one-time initialization of rigid body attributes
+   sets extended flags, masstotal, center-of-mass
+   sets Cartesian and diagonalized inertia tensor
+   sets body image flags
+   may read some properties from infile
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::setup_bodies_static()
+{
+  int i,ibody;
+
+  // extended = 1 if any particle in a rigid body is finite size
+  //              or has a dipole moment
+
+  extended = orientflag = dorientflag = 0;
+
+  AtomVecEllipsoid::Bonus *ebonus;
+  if (avec_ellipsoid) ebonus = avec_ellipsoid->bonus;
+  AtomVecLine::Bonus *lbonus;
+  if (avec_line) lbonus = avec_line->bonus;
+  AtomVecTri::Bonus *tbonus;
+  if (avec_tri) tbonus = avec_tri->bonus;
+  double **mu = atom->mu;
+  double *radius = atom->radius;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *ellipsoid = atom->ellipsoid;
+  int *line = atom->line;
+  int *tri = atom->tri;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  if (atom->radius_flag || atom->ellipsoid_flag || atom->line_flag ||
+      atom->tri_flag || atom->mu_flag) {
+    int flag = 0;
+    for (i = 0; i < nlocal; i++) {
+      if (bodytag[i] == 0) continue;
+      if (radius && radius[i] > 0.0) flag = 1;
+      if (ellipsoid && ellipsoid[i] >= 0) flag = 1;
+      if (line && line[i] >= 0) flag = 1;
+      if (tri && tri[i] >= 0) flag = 1;
+      if (mu && mu[i][3] > 0.0) flag = 1;
+    }
+
+    MPI_Allreduce(&flag,&extended,1,MPI_INT,MPI_MAX,world);
+  }
+
+  // extended = 1 if using molecule template with finite-size particles
+  // require all molecules in template to have consistent radiusflag
+
+  if (onemols) {
+    int radiusflag = onemols[0]->radiusflag;
+    for (i = 1; i < nmol; i++) {
+      if (onemols[i]->radiusflag != radiusflag)
+        error->all(FLERR,"Inconsistent use of finite-size particles "
+                   "by molecule template molecules");
+    }
+    if (radiusflag) extended = 1;
+  }
+
+  // grow extended arrays and set extended flags for each particle
+  // orientflag = 4 if any particle stores ellipsoid or tri orientation
+  // orientflag = 1 if any particle stores line orientation
+  // dorientflag = 1 if any particle stores dipole orientation
+
+  if (extended) {
+    if (atom->ellipsoid_flag) orientflag = 4;
+    if (atom->line_flag) orientflag = 1;
+    if (atom->tri_flag) orientflag = 4;
+    if (atom->mu_flag) dorientflag = 1;
+    grow_arrays(atom->nmax);
+
+    for (i = 0; i < nlocal; i++) {
+      eflags[i] = 0;
+      if (bodytag[i] == 0) continue;
+
+      // set to POINT or SPHERE or ELLIPSOID or LINE
+
+      if (radius && radius[i] > 0.0) {
+        eflags[i] |= SPHERE;
+        eflags[i] |= OMEGA;
+        eflags[i] |= TORQUE;
+      } else if (ellipsoid && ellipsoid[i] >= 0) {
+        eflags[i] |= ELLIPSOID;
+        eflags[i] |= ANGMOM;
+        eflags[i] |= TORQUE;
+      } else if (line && line[i] >= 0) {
+        eflags[i] |= LINE;
+        eflags[i] |= OMEGA;
+        eflags[i] |= TORQUE;
+      } else if (tri && tri[i] >= 0) {
+        eflags[i] |= TRIANGLE;
+        eflags[i] |= ANGMOM;
+        eflags[i] |= TORQUE;
+      } else eflags[i] |= POINT;
+
+      // set DIPOLE if atom->mu and mu[3] > 0.0
+
+      if (atom->mu_flag && mu[i][3] > 0.0)
+        eflags[i] |= DIPOLE;
+    }
+  }
+
+  // set body xcmimage flags = true image flags
+
+  imageint *image = atom->image;
+  for (i = 0; i < nlocal; i++)
+    if (bodytag[i] >= 0) xcmimage[i] = image[i];
+    else xcmimage[i] = 0;
+
+  // acquire ghost bodies via forward comm
+  // set atom2body for ghost atoms via forward comm
+  // set atom2body for other owned atoms via reset_atom2body()
+
+  nghost_body = 0;
+  commflag = FULL_BODY;
+  comm->forward_comm_fix(this);
+  reset_atom2body();
+
+  // compute mass & center-of-mass of each rigid body
+
+  double **x = atom->x;
+
+  double *xcm;
+
+  for (ibody = 0; ibody < nlocal_body+nghost_body; ibody++) {
+    xcm = body[ibody].xcm;
+    xcm[0] = xcm[1] = xcm[2] = 0.0;
+    body[ibody].mass = 0.0;
+  }
+
+  double unwrap[3];
+  double massone;
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    xcm = b->xcm;
+    xcm[0] += unwrap[0] * massone;
+    xcm[1] += unwrap[1] * massone;
+    xcm[2] += unwrap[2] * massone;
+    b->mass += massone;
+  }
+
+  // reverse communicate xcm, mass of all bodies
+
+  commflag = XCM_MASS;
+  comm->reverse_comm_fix(this,4);
+
+  for (ibody = 0; ibody < nlocal_body; ibody++) {
+    xcm = body[ibody].xcm;
+    xcm[0] /= body[ibody].mass;
+    xcm[1] /= body[ibody].mass;
+    xcm[2] /= body[ibody].mass;
+  }
+
+  // set vcm, angmom = 0.0 in case infile is used
+  // and doesn't overwrite all body's values
+  // since setup_bodies_dynamic() will not be called
+
+  double *vcm,*angmom;
+
+  for (ibody = 0; ibody < nlocal_body; ibody++) {
+    vcm = body[ibody].vcm;
+    vcm[0] = vcm[1] = vcm[2] = 0.0;
+    angmom = body[ibody].angmom;
+    angmom[0] = angmom[1] = angmom[2] = 0.0;
+  }
+
+  // set rigid body image flags to default values
+
+  for (ibody = 0; ibody < nlocal_body; ibody++)
+    body[ibody].image = ((imageint) IMGMAX << IMG2BITS) |
+      ((imageint) IMGMAX << IMGBITS) | IMGMAX;
+
+  // overwrite masstotal, center-of-mass, image flags with file values
+  // inbody[i] = 0/1 if Ith rigid body is initialized by file
+
+  int *inbody;
+  if (infile) {
+    memory->create(inbody,nlocal_body,"rigid/small:inbody");
+    for (ibody = 0; ibody < nlocal_body; ibody++) inbody[ibody] = 0;
+    readfile(0,NULL,inbody);
+  }
+
+  // remap the xcm of each body back into simulation box
+  //   and reset body and atom xcmimage flags via pre_neighbor()
+
+  pre_neighbor();
+
+  // compute 6 moments of inertia of each body in Cartesian reference frame
+  // dx,dy,dz = coords relative to center-of-mass
+  // symmetric 3x3 inertia tensor stored in Voigt notation as 6-vector
+
+  memory->create(itensor,nlocal_body+nghost_body,6,"rigid/small:itensor");
+  for (ibody = 0; ibody < nlocal_body+nghost_body; ibody++)
+    for (i = 0; i < 6; i++) itensor[ibody][i] = 0.0;
+
+  double dx,dy,dz;
+  double *inertia;
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    xcm = b->xcm;
+    dx = unwrap[0] - xcm[0];
+    dy = unwrap[1] - xcm[1];
+    dz = unwrap[2] - xcm[2];
+
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    inertia = itensor[atom2body[i]];
+    inertia[0] += massone * (dy*dy + dz*dz);
+    inertia[1] += massone * (dx*dx + dz*dz);
+    inertia[2] += massone * (dx*dx + dy*dy);
+    inertia[3] -= massone * dy*dz;
+    inertia[4] -= massone * dx*dz;
+    inertia[5] -= massone * dx*dy;
+  }
+
+  // extended particles may contribute extra terms to moments of inertia
+
+  if (extended) {
+    double ivec[6];
+    double *shape,*quatatom,*inertiaatom;
+    double length,theta;
+
+    for (i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+      inertia = itensor[atom2body[i]];
+
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+
+      if (eflags[i] & SPHERE) {
+        inertia[0] += SINERTIA*massone * radius[i]*radius[i];
+        inertia[1] += SINERTIA*massone * radius[i]*radius[i];
+        inertia[2] += SINERTIA*massone * radius[i]*radius[i];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        quatatom = ebonus[ellipsoid[i]].quat;
+        MathExtra::inertia_ellipsoid(shape,quatatom,massone,ivec);
+        inertia[0] += ivec[0];
+        inertia[1] += ivec[1];
+        inertia[2] += ivec[2];
+        inertia[3] += ivec[3];
+        inertia[4] += ivec[4];
+        inertia[5] += ivec[5];
+      } else if (eflags[i] & LINE) {
+        length = lbonus[line[i]].length;
+        theta = lbonus[line[i]].theta;
+        MathExtra::inertia_line(length,theta,massone,ivec);
+        inertia[0] += ivec[0];
+        inertia[1] += ivec[1];
+        inertia[2] += ivec[2];
+        inertia[3] += ivec[3];
+        inertia[4] += ivec[4];
+        inertia[5] += ivec[5];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::inertia_triangle(inertiaatom,quatatom,massone,ivec);
+        inertia[0] += ivec[0];
+        inertia[1] += ivec[1];
+        inertia[2] += ivec[2];
+        inertia[3] += ivec[3];
+        inertia[4] += ivec[4];
+        inertia[5] += ivec[5];
+      }
+    }
+  }
+
+  // reverse communicate inertia tensor of all bodies
+
+  commflag = ITENSOR;
+  comm->reverse_comm_fix(this,6);
+
+  // overwrite Cartesian inertia tensor with file values
+
+  if (infile) readfile(1,itensor,inbody);
+
+  // diagonalize inertia tensor for each body via Jacobi rotations
+  // inertia = 3 eigenvalues = principal moments of inertia
+  // evectors and exzy_space = 3 evectors = principal axes of rigid body
+
+  int ierror;
+  double cross[3];
+  double tensor[3][3],evectors[3][3];
+  double *ex,*ey,*ez;
+
+  for (ibody = 0; ibody < nlocal_body; ibody++) {
+    tensor[0][0] = itensor[ibody][0];
+    tensor[1][1] = itensor[ibody][1];
+    tensor[2][2] = itensor[ibody][2];
+    tensor[1][2] = tensor[2][1] = itensor[ibody][3];
+    tensor[0][2] = tensor[2][0] = itensor[ibody][4];
+    tensor[0][1] = tensor[1][0] = itensor[ibody][5];
+
+    inertia = body[ibody].inertia;
+    ierror = MathExtra::jacobi(tensor,inertia,evectors);
+    if (ierror) error->all(FLERR,
+                           "Insufficient Jacobi rotations for rigid body");
+
+    ex = body[ibody].ex_space;
+    ex[0] = evectors[0][0];
+    ex[1] = evectors[1][0];
+    ex[2] = evectors[2][0];
+    ey = body[ibody].ey_space;
+    ey[0] = evectors[0][1];
+    ey[1] = evectors[1][1];
+    ey[2] = evectors[2][1];
+    ez = body[ibody].ez_space;
+    ez[0] = evectors[0][2];
+    ez[1] = evectors[1][2];
+    ez[2] = evectors[2][2];
+
+    // if any principal moment < scaled EPSILON, set to 0.0
+
+    double max;
+    max = MAX(inertia[0],inertia[1]);
+    max = MAX(max,inertia[2]);
+
+    if (inertia[0] < EPSILON*max) inertia[0] = 0.0;
+    if (inertia[1] < EPSILON*max) inertia[1] = 0.0;
+    if (inertia[2] < EPSILON*max) inertia[2] = 0.0;
+
+    // enforce 3 evectors as a right-handed coordinate system
+    // flip 3rd vector if needed
+
+    MathExtra::cross3(ex,ey,cross);
+    if (MathExtra::dot3(cross,ez) < 0.0) MathExtra::negate3(ez);
+
+    // create initial quaternion
+
+    MathExtra::exyz_to_q(ex,ey,ez,body[ibody].quat);
+  }
+
+  // forward communicate updated info of all bodies
+
+  commflag = INITIAL;
+  comm->forward_comm_fix(this,26);
+
+  // displace = initial atom coords in basis of principal axes
+  // set displace = 0.0 for atoms not in any rigid body
+  // for extended particles, set their orientation wrt to rigid body
+
+  double qc[4],delta[3];
+  double *quatatom;
+  double theta_body;
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) {
+      displace[i][0] = displace[i][1] = displace[i][2] = 0.0;
+      continue;
+    }
+
+    Body *b = &body[atom2body[i]];
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    xcm = b->xcm;
+    delta[0] = unwrap[0] - xcm[0];
+    delta[1] = unwrap[1] - xcm[1];
+    delta[2] = unwrap[2] - xcm[2];
+    MathExtra::transpose_matvec(b->ex_space,b->ey_space,b->ez_space,
+                                delta,displace[i]);
+
+    if (extended) {
+      if (eflags[i] & ELLIPSOID) {
+        quatatom = ebonus[ellipsoid[i]].quat;
+        MathExtra::qconjugate(b->quat,qc);
+        MathExtra::quatquat(qc,quatatom,orient[i]);
+        MathExtra::qnormalize(orient[i]);
+      } else if (eflags[i] & LINE) {
+        if (b->quat[3] >= 0.0) theta_body = 2.0*acos(b->quat[0]);
+        else theta_body = -2.0*acos(b->quat[0]);
+        orient[i][0] = lbonus[line[i]].theta - theta_body;
+        while (orient[i][0] <= MINUSPI) orient[i][0] += TWOPI;
+        while (orient[i][0] > MY_PI) orient[i][0] -= TWOPI;
+        if (orientflag == 4) orient[i][1] = orient[i][2] = orient[i][3] = 0.0;
+      } else if (eflags[i] & TRIANGLE) {
+        quatatom = tbonus[tri[i]].quat;
+        MathExtra::qconjugate(b->quat,qc);
+        MathExtra::quatquat(qc,quatatom,orient[i]);
+        MathExtra::qnormalize(orient[i]);
+      } else if (orientflag == 4) {
+        orient[i][0] = orient[i][1] = orient[i][2] = orient[i][3] = 0.0;
+      } else if (orientflag == 1)
+        orient[i][0] = 0.0;
+
+      if (eflags[i] & DIPOLE) {
+        MathExtra::transpose_matvec(b->ex_space,b->ey_space,b->ez_space,
+                                    mu[i],dorient[i]);
+        MathExtra::snormalize3(mu[i][3],dorient[i],dorient[i]);
+      } else if (dorientflag)
+        dorient[i][0] = dorient[i][1] = dorient[i][2] = 0.0;
+    }
+  }
+
+  // test for valid principal moments & axes
+  // recompute moments of inertia around new axes
+  // 3 diagonal moments should equal principal moments
+  // 3 off-diagonal moments should be 0.0
+  // extended particles may contribute extra terms to moments of inertia
+
+  for (ibody = 0; ibody < nlocal_body+nghost_body; ibody++)
+    for (i = 0; i < 6; i++) itensor[ibody][i] = 0.0;
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    inertia = itensor[atom2body[i]];
+
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    inertia[0] += massone *
+      (displace[i][1]*displace[i][1] + displace[i][2]*displace[i][2]);
+    inertia[1] += massone *
+      (displace[i][0]*displace[i][0] + displace[i][2]*displace[i][2]);
+    inertia[2] += massone *
+      (displace[i][0]*displace[i][0] + displace[i][1]*displace[i][1]);
+    inertia[3] -= massone * displace[i][1]*displace[i][2];
+    inertia[4] -= massone * displace[i][0]*displace[i][2];
+    inertia[5] -= massone * displace[i][0]*displace[i][1];
+  }
+
+  if (extended) {
+    double ivec[6];
+    double *shape,*inertiaatom;
+    double length;
+
+    for (i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+      inertia = itensor[atom2body[i]];
+
+      if (rmass) massone = rmass[i];
+      else massone = mass[type[i]];
+
+      if (eflags[i] & SPHERE) {
+        inertia[0] += SINERTIA*massone * radius[i]*radius[i];
+        inertia[1] += SINERTIA*massone * radius[i]*radius[i];
+        inertia[2] += SINERTIA*massone * radius[i]*radius[i];
+      } else if (eflags[i] & ELLIPSOID) {
+        shape = ebonus[ellipsoid[i]].shape;
+        MathExtra::inertia_ellipsoid(shape,orient[i],massone,ivec);
+        inertia[0] += ivec[0];
+        inertia[1] += ivec[1];
+        inertia[2] += ivec[2];
+        inertia[3] += ivec[3];
+        inertia[4] += ivec[4];
+        inertia[5] += ivec[5];
+      } else if (eflags[i] & LINE) {
+        length = lbonus[line[i]].length;
+        MathExtra::inertia_line(length,orient[i][0],massone,ivec);
+        inertia[0] += ivec[0];
+        inertia[1] += ivec[1];
+        inertia[2] += ivec[2];
+        inertia[3] += ivec[3];
+        inertia[4] += ivec[4];
+        inertia[5] += ivec[5];
+      } else if (eflags[i] & TRIANGLE) {
+        inertiaatom = tbonus[tri[i]].inertia;
+        MathExtra::inertia_triangle(inertiaatom,orient[i],massone,ivec);
+        inertia[0] += ivec[0];
+        inertia[1] += ivec[1];
+        inertia[2] += ivec[2];
+        inertia[3] += ivec[3];
+        inertia[4] += ivec[4];
+        inertia[5] += ivec[5];
+      }
+    }
+  }
+
+  // reverse communicate inertia tensor of all bodies
+
+  commflag = ITENSOR;
+  comm->reverse_comm_fix(this,6);
+
+  // error check that re-computed moments of inertia match diagonalized ones
+  // do not do test for bodies with params read from infile
+
+  double norm;
+  for (ibody = 0; ibody < nlocal_body; ibody++) {
+    if (infile && inbody[ibody]) continue;
+    inertia = body[ibody].inertia;
+
+    if (inertia[0] == 0.0) {
+      if (fabs(itensor[ibody][0]) > TOLERANCE)
+        error->all(FLERR,"Fix rigid: Bad principal moments");
+    } else {
+      if (fabs((itensor[ibody][0]-inertia[0])/inertia[0]) >
+          TOLERANCE) error->all(FLERR,"Fix rigid: Bad principal moments");
+    }
+    if (inertia[1] == 0.0) {
+      if (fabs(itensor[ibody][1]) > TOLERANCE)
+        error->all(FLERR,"Fix rigid: Bad principal moments");
+    } else {
+      if (fabs((itensor[ibody][1]-inertia[1])/inertia[1]) >
+          TOLERANCE) error->all(FLERR,"Fix rigid: Bad principal moments");
+    }
+    if (inertia[2] == 0.0) {
+      if (fabs(itensor[ibody][2]) > TOLERANCE)
+        error->all(FLERR,"Fix rigid: Bad principal moments");
+    } else {
+      if (fabs((itensor[ibody][2]-inertia[2])/inertia[2]) >
+          TOLERANCE) error->all(FLERR,"Fix rigid: Bad principal moments");
+    }
+    norm = (inertia[0] + inertia[1] + inertia[2]) / 3.0;
+    if (fabs(itensor[ibody][3]/norm) > TOLERANCE ||
+        fabs(itensor[ibody][4]/norm) > TOLERANCE ||
+        fabs(itensor[ibody][5]/norm) > TOLERANCE)
+      error->all(FLERR,"Fix rigid: Bad principal moments");
+  }
+
+  // clean up
+
+  memory->destroy(itensor);
+  if (infile) memory->destroy(inbody);
+}
+
+/* ----------------------------------------------------------------------
+   one-time initialization of dynamic rigid body attributes
+   vcm and angmom, computed explicitly from constituent particles
+   not done if body properites read from file, e.g. for overlapping particles
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::setup_bodies_dynamic()
+{
+  int i,ibody;
+  double massone,radone;
+
+  // sum vcm, angmom across all rigid bodies
+  // vcm = velocity of COM
+  // angmom = angular momentum around COM
+
+  double **x = atom->x;
+  double **v = atom->v;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  double *xcm,*vcm,*acm;
+  double dx,dy,dz;
+  double unwrap[3];
+
+  for (ibody = 0; ibody < nlocal_body+nghost_body; ibody++) {
+    vcm = body[ibody].vcm;
+    vcm[0] = vcm[1] = vcm[2] = 0.0;
+    acm = body[ibody].angmom;
+    acm[0] = acm[1] = acm[2] = 0.0;
+  }
+
+  for (i = 0; i < nlocal; i++) {
+    if (atom2body[i] < 0) continue;
+    Body *b = &body[atom2body[i]];
+
+    if (rmass) massone = rmass[i];
+    else massone = mass[type[i]];
+
+    vcm = b->vcm;
+    vcm[0] += v[i][0] * massone;
+    vcm[1] += v[i][1] * massone;
+    vcm[2] += v[i][2] * massone;
+
+    domain->unmap(x[i],xcmimage[i],unwrap);
+    xcm = b->xcm;
+    dx = unwrap[0] - xcm[0];
+    dy = unwrap[1] - xcm[1];
+    dz = unwrap[2] - xcm[2];
+
+    acm = b->angmom;
+    acm[0] += dy * massone*v[i][2] - dz * massone*v[i][1];
+    acm[1] += dz * massone*v[i][0] - dx * massone*v[i][2];
+    acm[2] += dx * massone*v[i][1] - dy * massone*v[i][0];
+  }
+
+  // extended particles add their rotation to angmom of body
+
+  if (extended) {
+    AtomVecLine::Bonus *lbonus;
+    if (avec_line) lbonus = avec_line->bonus;
+    double **omega = atom->omega;
+    double **angmom = atom->angmom;
+    double *radius = atom->radius;
+    int *line = atom->line;
+
+    for (i = 0; i < nlocal; i++) {
+      if (atom2body[i] < 0) continue;
+      Body *b = &body[atom2body[i]];
+
+      if (eflags[i] & OMEGA) {
+        if (eflags[i] & SPHERE) {
+          radone = radius[i];
+          acm = b->angmom;
+          acm[0] += SINERTIA*rmass[i] * radone*radone * omega[i][0];
+          acm[1] += SINERTIA*rmass[i] * radone*radone * omega[i][1];
+          acm[2] += SINERTIA*rmass[i] * radone*radone * omega[i][2];
+        } else if (eflags[i] & LINE) {
+          radone = lbonus[line[i]].length;
+          b->angmom[2] += LINERTIA*rmass[i] * radone*radone * omega[i][2];
+        }
+      }
+      if (eflags[i] & ANGMOM) {
+        acm = b->angmom;
+        acm[0] += angmom[i][0];
+        acm[1] += angmom[i][1];
+        acm[2] += angmom[i][2];
+      }
+    }
+  }
+
+  // reverse communicate vcm, angmom of all bodies
+
+  commflag = VCM_ANGMOM;
+  comm->reverse_comm_fix(this,6);
+
+  // normalize velocity of COM
+
+  for (ibody = 0; ibody < nlocal_body; ibody++) {
+    vcm = body[ibody].vcm;
+    vcm[0] /= body[ibody].mass;
+    vcm[1] /= body[ibody].mass;
+    vcm[2] /= body[ibody].mass;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   read per rigid body info from user-provided file
+   which = 0 to read everthing except 6 moments of inertia
+   which = 1 to read just 6 moments of inertia
+   flag inbody = 0 for local bodies this proc initializes from file
+   nlines = # of lines of rigid body info, 0 is OK
+   one line = rigid-ID mass xcm ycm zcm ixx iyy izz ixy ixz iyz
+              vxcm vycm vzcm lx ly lz
+   where rigid-ID = mol-ID for fix rigid/small
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::readfile(int which, double **array, int *inbody)
+{
+  int i,j,m,nchunk,eofflag,nlines,xbox,ybox,zbox;
+  tagint id;
+  FILE *fp;
+  char *eof,*start,*next,*buf;
+  char line[MAXLINE];
+
+  // create local hash with key/value pairs
+  // key = mol ID of bodies my atoms own
+  // value = index into local body array
+
+  int nlocal = atom->nlocal;
+
+  hash = new std::map<tagint,int>();
+  for (i = 0; i < nlocal; i++)
+    if (bodyown[i] >= 0) (*hash)[atom->molecule[i]] = bodyown[i];
+
+  // open file and read header
+
+  if (me == 0) {
+    fp = fopen(infile,"r");
+    if (fp == NULL) {
+      char str[128];
+      sprintf(str,"Cannot open fix rigid/small infile %s",infile);
+      error->one(FLERR,str);
+    }
+
+    while (1) {
+      eof = fgets(line,MAXLINE,fp);
+      if (eof == NULL)
+        error->one(FLERR,"Unexpected end of fix rigid/small file");
+      start = &line[strspn(line," \t\n\v\f\r")];
+      if (*start != '\0' && *start != '#') break;
+    }
+
+    sscanf(line,"%d",&nlines);
+  }
+
+  MPI_Bcast(&nlines,1,MPI_INT,0,world);
+
+  char *buffer = new char[CHUNK*MAXLINE];
+  char **values = new char*[ATTRIBUTE_PERBODY];
+
+  int nread = 0;
+  while (nread < nlines) {
+    nchunk = MIN(nlines-nread,CHUNK);
+    eofflag = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
+    if (eofflag) error->all(FLERR,"Unexpected end of fix rigid/small file");
+
+    buf = buffer;
+    next = strchr(buf,'\n');
+    *next = '\0';
+    int nwords = atom->count_words(buf);
+    *next = '\n';
+
+    if (nwords != ATTRIBUTE_PERBODY)
+      error->all(FLERR,"Incorrect rigid body format in fix rigid/small file");
+
+    // loop over lines of rigid body attributes
+    // tokenize the line into values
+    // id = rigid body ID = mol-ID
+    // for which = 0, store all but inertia directly in body struct
+    // for which = 1, store inertia tensor array, invert 3,4,5 values to Voigt
+
+    for (int i = 0; i < nchunk; i++) {
+      next = strchr(buf,'\n');
+
+      values[0] = strtok(buf," \t\n\r\f");
+      for (j = 1; j < nwords; j++)
+        values[j] = strtok(NULL," \t\n\r\f");
+
+      id = ATOTAGINT(values[0]);
+      if (id <= 0 || id > maxmol)
+        error->all(FLERR,"Invalid rigid body ID in fix rigid/small file");
+      if (hash->find(id) == hash->end()) {
+        buf = next + 1;
+        continue;
+      }
+      m = (*hash)[id];
+      inbody[m] = 1;
+
+      if (which == 0) {
+        body[m].mass = atof(values[1]);
+        body[m].xcm[0] = atof(values[2]);
+        body[m].xcm[1] = atof(values[3]);
+        body[m].xcm[2] = atof(values[4]);
+        body[m].vcm[0] = atof(values[11]);
+        body[m].vcm[1] = atof(values[12]);
+        body[m].vcm[2] = atof(values[13]);
+        body[m].angmom[0] = atof(values[14]);
+        body[m].angmom[1] = atof(values[15]);
+        body[m].angmom[2] = atof(values[16]);
+        xbox = atoi(values[17]);
+        ybox = atoi(values[18]);
+        zbox = atoi(values[19]);
+        body[m].image = ((imageint) (xbox + IMGMAX) & IMGMASK) |
+          (((imageint) (ybox + IMGMAX) & IMGMASK) << IMGBITS) |
+          (((imageint) (zbox + IMGMAX) & IMGMASK) << IMG2BITS);
+      } else {
+        array[m][0] = atof(values[5]);
+        array[m][1] = atof(values[6]);
+        array[m][2] = atof(values[7]);
+        array[m][3] = atof(values[10]);
+        array[m][4] = atof(values[9]);
+        array[m][5] = atof(values[8]);
+      }
+
+      buf = next + 1;
+    }
+
+    nread += nchunk;
+  }
+
+  if (me == 0) fclose(fp);
+
+  delete [] buffer;
+  delete [] values;
+  delete hash;
+}
+
+/* ----------------------------------------------------------------------
+   write out restart info for mass, COM, inertia tensor to file
+   identical format to infile option, so info can be read in when restarting
+   each proc contributes info for rigid bodies it owns
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::write_restart_file(char *file)
+{
+  FILE *fp;
+
+  // do not write file if bodies have not yet been initialized
+
+  if (!setupflag) return;
+
+  // proc 0 opens file and writes header
+
+  if (me == 0) {
+    char outfile[128];
+    sprintf(outfile,"%s.rigid",file);
+    fp = fopen(outfile,"w");
+    if (fp == NULL) {
+      char str[128];
+      sprintf(str,"Cannot open fix rigid restart file %s",outfile);
+      error->one(FLERR,str);
+    }
+
+    fprintf(fp,"# fix rigid mass, COM, inertia tensor info for "
+            "%d bodies on timestep " BIGINT_FORMAT "\n\n",
+            nbody,update->ntimestep);
+    fprintf(fp,"%d\n",nbody);
+  }
+
+  // communication buffer for all my rigid body info
+  // max_size = largest buffer needed by any proc
+  // ncol = # of values per line in output file
+
+  int ncol = ATTRIBUTE_PERBODY;
+  int sendrow = nlocal_body;
+  int maxrow;
+  MPI_Allreduce(&sendrow,&maxrow,1,MPI_INT,MPI_MAX,world);
+
+  double **buf;
+  if (me == 0) memory->create(buf,MAX(1,maxrow),ncol,"rigid/small:buf");
+  else memory->create(buf,MAX(1,sendrow),ncol,"rigid/small:buf");
+
+  // pack my rigid body info into buf
+  // compute I tensor against xyz axes from diagonalized I and current quat
+  // Ispace = P Idiag P_transpose
+  // P is stored column-wise in exyz_space
+
+  double p[3][3],pdiag[3][3],ispace[3][3];
+
+  for (int i = 0; i < nlocal_body; i++) {
+    MathExtra::col2mat(body[i].ex_space,body[i].ey_space,body[i].ez_space,p);
+    MathExtra::times3_diag(p,body[i].inertia,pdiag);
+    MathExtra::times3_transpose(pdiag,p,ispace);
+
+    buf[i][0] = atom->molecule[body[i].ilocal];
+    buf[i][1] = body[i].mass;
+    buf[i][2] = body[i].xcm[0];
+    buf[i][3] = body[i].xcm[1];
+    buf[i][4] = body[i].xcm[2];
+    buf[i][5] = ispace[0][0];
+    buf[i][6] = ispace[1][1];
+    buf[i][7] = ispace[2][2];
+    buf[i][8] = ispace[0][1];
+    buf[i][9] = ispace[0][2];
+    buf[i][10] = ispace[1][2];
+    buf[i][11] = body[i].vcm[0];
+    buf[i][12] = body[i].vcm[1];
+    buf[i][13] = body[i].vcm[2];
+    buf[i][14] = body[i].angmom[0];
+    buf[i][15] = body[i].angmom[1];
+    buf[i][16] = body[i].angmom[2];
+    buf[i][17] = (body[i].image & IMGMASK) - IMGMAX;
+    buf[i][18] = (body[i].image >> IMGBITS & IMGMASK) - IMGMAX;
+    buf[i][19] = (body[i].image >> IMG2BITS) - IMGMAX;
+  }
+
+  // write one chunk of rigid body info per proc to file
+  // proc 0 pings each proc, receives its chunk, writes to file
+  // all other procs wait for ping, send their chunk to proc 0
+
+  int tmp,recvrow;
+
+  if (me == 0) {
+    MPI_Status status;
+    MPI_Request request;
+    for (int iproc = 0; iproc < nprocs; iproc++) {
+      if (iproc) {
+        MPI_Irecv(&buf[0][0],maxrow*ncol,MPI_DOUBLE,iproc,0,world,&request);
+        MPI_Send(&tmp,0,MPI_INT,iproc,0,world);
+        MPI_Wait(&request,&status);
+        MPI_Get_count(&status,MPI_DOUBLE,&recvrow);
+        recvrow /= ncol;
+      } else recvrow = sendrow;
+
+      for (int i = 0; i < recvrow; i++)
+        fprintf(fp,"%d %-1.16e %-1.16e %-1.16e %-1.16e "
+                "%-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e "
+                "%-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %-1.16e %d %d %d\n",
+                static_cast<int> (buf[i][0]),buf[i][1],
+                buf[i][2],buf[i][3],buf[i][4],
+                buf[i][5],buf[i][6],buf[i][7],
+                buf[i][8],buf[i][9],buf[i][10],
+                buf[i][11],buf[i][12],buf[i][13],
+                buf[i][14],buf[i][15],buf[i][16],
+                static_cast<int> (buf[i][17]),
+                static_cast<int> (buf[i][18]),
+                static_cast<int> (buf[i][19]));
+    }
+
+  } else {
+    MPI_Recv(&tmp,0,MPI_INT,0,0,world,MPI_STATUS_IGNORE);
+    MPI_Rsend(&buf[0][0],sendrow*ncol,MPI_DOUBLE,0,0,world);
+  }
+
+  // clean up and close file
+
+  memory->destroy(buf);
+  if (me == 0) fclose(fp);
+}
+
+/* ----------------------------------------------------------------------
+   allocate local atom-based arrays
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::grow_arrays(int nmax)
+{
+  memory->grow(bodyown,nmax,"rigid/small:bodyown");
+  memory->grow(bodytag,nmax,"rigid/small:bodytag");
+  memory->grow(atom2body,nmax,"rigid/small:atom2body");
+  memory->grow(xcmimage,nmax,"rigid/small:xcmimage");
+  memory->grow(displace,nmax,3,"rigid/small:displace");
+  if (extended) {
+    memory->grow(eflags,nmax,"rigid/small:eflags");
+    if (orientflag) memory->grow(orient,nmax,orientflag,"rigid/small:orient");
+    if (dorientflag) memory->grow(dorient,nmax,3,"rigid/small:dorient");
+  }
+
+  // check for regrow of vatom
+  // must be done whether per-atom virial is accumulated on this step or not
+  //   b/c this is only time grow_array() may be called
+  // need to regrow b/c vatom is calculated before and after atom migration
+
+  if (nmax > maxvatom) {
+    maxvatom = atom->nmax;
+    memory->grow(vatom,maxvatom,6,"fix:vatom");
+  }
+}
+
+/* ----------------------------------------------------------------------
+   copy values within local atom-based arrays
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::copy_arrays(int i, int j, int delflag)
+{
+  bodytag[j] = bodytag[i];
+  xcmimage[j] = xcmimage[i];
+  displace[j][0] = displace[i][0];
+  displace[j][1] = displace[i][1];
+  displace[j][2] = displace[i][2];
+
+  if (extended) {
+    eflags[j] = eflags[i];
+    for (int k = 0; k < orientflag; k++)
+      orient[j][k] = orient[i][k];
+    if (dorientflag) {
+      dorient[j][0] = dorient[i][0];
+      dorient[j][1] = dorient[i][1];
+      dorient[j][2] = dorient[i][2];
+    }
+  }
+
+  // must also copy vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      vatom[j][k] = vatom[i][k];
+
+  // if deleting atom J via delflag and J owns a body, then delete it
+
+  if (delflag && bodyown[j] >= 0) {
+    bodyown[body[nlocal_body-1].ilocal] = bodyown[j];
+    memcpy(&body[bodyown[j]],&body[nlocal_body-1],sizeof(Body));
+    nlocal_body--;
+  }
+
+  // if atom I owns a body, reset I's body.ilocal to loc J
+  // do NOT do this if self-copy (I=J) since I's body is already deleted
+
+  if (bodyown[i] >= 0 && i != j) body[bodyown[i]].ilocal = j;
+  bodyown[j] = bodyown[i];
+}
+
+/* ----------------------------------------------------------------------
+   initialize one atom's array values, called when atom is created
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::set_arrays(int i)
+{
+  bodyown[i] = -1;
+  bodytag[i] = 0;
+  atom2body[i] = -1;
+  xcmimage[i] = 0;
+  displace[i][0] = 0.0;
+  displace[i][1] = 0.0;
+  displace[i][2] = 0.0;
+
+  // must also zero vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      vatom[i][k] = 0.0;
+}
+
+/* ----------------------------------------------------------------------
+   initialize a molecule inserted by another fix, e.g. deposit or pour
+   called when molecule is created
+   nlocalprev = # of atoms on this proc before molecule inserted
+   tagprev = atom ID previous to new atoms in the molecule
+   xgeom = geometric center of new molecule
+   vcm = COM velocity of new molecule
+   quat = rotation of new molecule (around geometric center)
+          relative to template in Molecule class
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::set_molecule(int nlocalprev, tagint tagprev, int imol,
+                                 double *xgeom, double *vcm, double *quat)
+{
+  int m;
+  double ctr2com[3],ctr2com_rotate[3];
+  double rotmat[3][3];
+
+  // increment total # of rigid bodies
+
+  nbody++;
+
+  // loop over atoms I added for the new body
+
+  int nlocal = atom->nlocal;
+  if (nlocalprev == nlocal) return;
+
+  tagint *tag = atom->tag;
+
+  for (int i = nlocalprev; i < nlocal; i++) {
+    bodytag[i] = tagprev + onemols[imol]->comatom;
+    if (tag[i]-tagprev == onemols[imol]->comatom) bodyown[i] = nlocal_body;
+
+    m = tag[i] - tagprev-1;
+    displace[i][0] = onemols[imol]->dxbody[m][0];
+    displace[i][1] = onemols[imol]->dxbody[m][1];
+    displace[i][2] = onemols[imol]->dxbody[m][2];
+
+    if (extended) {
+      eflags[i] = 0;
+      if (onemols[imol]->radiusflag) {
+        eflags[i] |= SPHERE;
+        eflags[i] |= OMEGA;
+        eflags[i] |= TORQUE;
+      }
+    }
+
+    if (bodyown[i] >= 0) {
+      if (nlocal_body == nmax_body) grow_body();
+      Body *b = &body[nlocal_body];
+      b->mass = onemols[imol]->masstotal;
+
+      // new COM = Q (onemols[imol]->xcm - onemols[imol]->center) + xgeom
+      // Q = rotation matrix associated with quat
+
+      MathExtra::quat_to_mat(quat,rotmat);
+      MathExtra::sub3(onemols[imol]->com,onemols[imol]->center,ctr2com);
+      MathExtra::matvec(rotmat,ctr2com,ctr2com_rotate);
+      MathExtra::add3(ctr2com_rotate,xgeom,b->xcm);
+
+      b->vcm[0] = vcm[0];
+      b->vcm[1] = vcm[1];
+      b->vcm[2] = vcm[2];
+      b->inertia[0] = onemols[imol]->inertia[0];
+      b->inertia[1] = onemols[imol]->inertia[1];
+      b->inertia[2] = onemols[imol]->inertia[2];
+
+      // final quat is product of insertion quat and original quat
+      // true even if insertion rotation was not around COM
+
+      MathExtra::quatquat(quat,onemols[imol]->quat,b->quat);
+      MathExtra::q_to_exyz(b->quat,b->ex_space,b->ey_space,b->ez_space);
+
+      b->angmom[0] = b->angmom[1] = b->angmom[2] = 0.0;
+      b->omega[0] = b->omega[1] = b->omega[2] = 0.0;
+      b->conjqm[0] = b->conjqm[1] = b->conjqm[2] = b->conjqm[3] = 0.0;
+
+      b->image = ((imageint) IMGMAX << IMG2BITS) |
+        ((imageint) IMGMAX << IMGBITS) | IMGMAX;
+      b->ilocal = i;
+      nlocal_body++;
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   pack values in local atom-based arrays for exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixRigidSmall::pack_exchange(int i, double *buf)
+{
+  buf[0] = ubuf(bodytag[i]).d;
+  buf[1] = ubuf(xcmimage[i]).d;
+  buf[2] = displace[i][0];
+  buf[3] = displace[i][1];
+  buf[4] = displace[i][2];
+
+  // extended attribute info
+
+  int m = 5;
+  if (extended) {
+    buf[m++] = eflags[i];
+    for (int j = 0; j < orientflag; j++)
+      buf[m++] = orient[i][j];
+    if (dorientflag) {
+      buf[m++] = dorient[i][0];
+      buf[m++] = dorient[i][1];
+      buf[m++] = dorient[i][2];
+    }
+  }
+
+  // atom not in a rigid body
+
+  if (!bodytag[i]) return m;
+
+  // must also pack vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      buf[m++] = vatom[i][k];
+
+  // atom does not own its rigid body
+
+  if (bodyown[i] < 0) {
+    buf[m++] = 0;
+    return m;
+  }
+
+  // body info for atom that owns a rigid body
+
+  buf[m++] = 1;
+  memcpy(&buf[m],&body[bodyown[i]],sizeof(Body));
+  m += bodysize;
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   unpack values in local atom-based arrays from exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixRigidSmall::unpack_exchange(int nlocal, double *buf)
+{
+  bodytag[nlocal] = (tagint) ubuf(buf[0]).i;
+  xcmimage[nlocal] = (imageint) ubuf(buf[1]).i;
+  displace[nlocal][0] = buf[2];
+  displace[nlocal][1] = buf[3];
+  displace[nlocal][2] = buf[4];
+
+  // extended attribute info
+
+  int m = 5;
+  if (extended) {
+    eflags[nlocal] = static_cast<int> (buf[m++]);
+    for (int j = 0; j < orientflag; j++)
+      orient[nlocal][j] = buf[m++];
+    if (dorientflag) {
+      dorient[nlocal][0] = buf[m++];
+      dorient[nlocal][1] = buf[m++];
+      dorient[nlocal][2] = buf[m++];
+    }
+  }
+
+  // atom not in a rigid body
+
+  if (!bodytag[nlocal]) {
+    bodyown[nlocal] = -1;
+    return m;
+  }
+
+  // must also unpack vatom if per-atom virial calculated on this timestep
+  // since vatom is calculated before and after atom migration
+
+  if (vflag_atom)
+    for (int k = 0; k < 6; k++)
+      vatom[nlocal][k] = buf[m++];
+
+  // atom does not own its rigid body
+
+  bodyown[nlocal] = static_cast<int> (buf[m++]);
+  if (bodyown[nlocal] == 0) {
+    bodyown[nlocal] = -1;
+    return m;
+  }
+
+  // body info for atom that owns a rigid body
+
+  if (nlocal_body == nmax_body) grow_body();
+  memcpy(&body[nlocal_body],&buf[m],sizeof(Body));
+  m += bodysize;
+  body[nlocal_body].ilocal = nlocal;
+  bodyown[nlocal] = nlocal_body++;
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   only pack body info if own or ghost atom owns the body
+   for FULL_BODY, send 0/1 flag with every atom
+------------------------------------------------------------------------- */
+
+int FixRigidSmall::pack_forward_comm(int n, int *list, double *buf,
+                                     int pbc_flag, int *pbc)
+{
+  int i,j;
+  double *xcm,*vcm,*quat,*omega,*ex_space,*ey_space,*ez_space,*conjqm;
+
+  int m = 0;
+
+  if (commflag == INITIAL) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) continue;
+      xcm = body[bodyown[j]].xcm;
+      buf[m++] = xcm[0];
+      buf[m++] = xcm[1];
+      buf[m++] = xcm[2];
+      vcm = body[bodyown[j]].vcm;
+      buf[m++] = vcm[0];
+      buf[m++] = vcm[1];
+      buf[m++] = vcm[2];
+      quat = body[bodyown[j]].quat;
+      buf[m++] = quat[0];
+      buf[m++] = quat[1];
+      buf[m++] = quat[2];
+      buf[m++] = quat[3];
+      omega = body[bodyown[j]].omega;
+      buf[m++] = omega[0];
+      buf[m++] = omega[1];
+      buf[m++] = omega[2];
+      ex_space = body[bodyown[j]].ex_space;
+      buf[m++] = ex_space[0];
+      buf[m++] = ex_space[1];
+      buf[m++] = ex_space[2];
+      ey_space = body[bodyown[j]].ey_space;
+      buf[m++] = ey_space[0];
+      buf[m++] = ey_space[1];
+      buf[m++] = ey_space[2];
+      ez_space = body[bodyown[j]].ez_space;
+      buf[m++] = ez_space[0];
+      buf[m++] = ez_space[1];
+      buf[m++] = ez_space[2];
+      conjqm = body[bodyown[j]].conjqm;
+      buf[m++] = conjqm[0];
+      buf[m++] = conjqm[1];
+      buf[m++] = conjqm[2];
+      buf[m++] = conjqm[3];
+    }
+
+  } else if (commflag == FINAL) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) continue;
+      vcm = body[bodyown[j]].vcm;
+      buf[m++] = vcm[0];
+      buf[m++] = vcm[1];
+      buf[m++] = vcm[2];
+      omega = body[bodyown[j]].omega;
+      buf[m++] = omega[0];
+      buf[m++] = omega[1];
+      buf[m++] = omega[2];
+      conjqm = body[bodyown[j]].conjqm;
+      buf[m++] = conjqm[0];
+      buf[m++] = conjqm[1];
+      buf[m++] = conjqm[2];
+      buf[m++] = conjqm[3];
+    }
+
+  } else if (commflag == FULL_BODY) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) buf[m++] = 0;
+      else {
+        buf[m++] = 1;
+        memcpy(&buf[m],&body[bodyown[j]],sizeof(Body));
+        m += bodysize;
+      }
+    }
+  }
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   only ghost atoms are looped over
+   for FULL_BODY, store a new ghost body if this atom owns it
+   for other commflag values, only unpack body info if atom owns it
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::unpack_forward_comm(int n, int first, double *buf)
+{
+  int i,j,last;
+  double *xcm,*vcm,*quat,*omega,*ex_space,*ey_space,*ez_space,*conjqm;
+
+  int m = 0;
+  last = first + n;
+
+  if (commflag == INITIAL) {
+    for (i = first; i < last; i++) {
+      if (bodyown[i] < 0) continue;
+      xcm = body[bodyown[i]].xcm;
+      xcm[0] = buf[m++];
+      xcm[1] = buf[m++];
+      xcm[2] = buf[m++];
+      vcm = body[bodyown[i]].vcm;
+      vcm[0] = buf[m++];
+      vcm[1] = buf[m++];
+      vcm[2] = buf[m++];
+      quat = body[bodyown[i]].quat;
+      quat[0] = buf[m++];
+      quat[1] = buf[m++];
+      quat[2] = buf[m++];
+      quat[3] = buf[m++];
+      omega = body[bodyown[i]].omega;
+      omega[0] = buf[m++];
+      omega[1] = buf[m++];
+      omega[2] = buf[m++];
+      ex_space = body[bodyown[i]].ex_space;
+      ex_space[0] = buf[m++];
+      ex_space[1] = buf[m++];
+      ex_space[2] = buf[m++];
+      ey_space = body[bodyown[i]].ey_space;
+      ey_space[0] = buf[m++];
+      ey_space[1] = buf[m++];
+      ey_space[2] = buf[m++];
+      ez_space = body[bodyown[i]].ez_space;
+      ez_space[0] = buf[m++];
+      ez_space[1] = buf[m++];
+      ez_space[2] = buf[m++];
+      conjqm = body[bodyown[i]].conjqm;
+      conjqm[0] = buf[m++];
+      conjqm[1] = buf[m++];
+      conjqm[2] = buf[m++];
+      conjqm[3] = buf[m++];
+    }
+
+  } else if (commflag == FINAL) {
+    for (i = first; i < last; i++) {
+      if (bodyown[i] < 0) continue;
+      vcm = body[bodyown[i]].vcm;
+      vcm[0] = buf[m++];
+      vcm[1] = buf[m++];
+      vcm[2] = buf[m++];
+      omega = body[bodyown[i]].omega;
+      omega[0] = buf[m++];
+      omega[1] = buf[m++];
+      omega[2] = buf[m++];
+      conjqm = body[bodyown[i]].conjqm;
+      conjqm[0] = buf[m++];
+      conjqm[1] = buf[m++];
+      conjqm[2] = buf[m++];
+      conjqm[3] = buf[m++];
+    }
+
+  } else if (commflag == FULL_BODY) {
+    for (i = first; i < last; i++) {
+      bodyown[i] = static_cast<int> (buf[m++]);
+      if (bodyown[i] == 0) bodyown[i] = -1;
+      else {
+        j = nlocal_body + nghost_body;
+        if (j == nmax_body) grow_body();
+        memcpy(&body[j],&buf[m],sizeof(Body));
+        m += bodysize;
+        body[j].ilocal = i;
+        bodyown[i] = j;
+        nghost_body++;
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   only ghost atoms are looped over
+   only pack body info if atom owns it
+------------------------------------------------------------------------- */
+
+int FixRigidSmall::pack_reverse_comm(int n, int first, double *buf)
+{
+  int i,j,m,last;
+  double *fcm,*torque,*vcm,*angmom,*xcm;
+
+  m = 0;
+  last = first + n;
+
+  if (commflag == FORCE_TORQUE) {
+    for (i = first; i < last; i++) {
+      if (bodyown[i] < 0) continue;
+      fcm = body[bodyown[i]].fcm;
+      buf[m++] = fcm[0];
+      buf[m++] = fcm[1];
+      buf[m++] = fcm[2];
+      torque = body[bodyown[i]].torque;
+      buf[m++] = torque[0];
+      buf[m++] = torque[1];
+      buf[m++] = torque[2];
+    }
+
+  } else if (commflag == VCM_ANGMOM) {
+    for (i = first; i < last; i++) {
+      if (bodyown[i] < 0) continue;
+      vcm = body[bodyown[i]].vcm;
+      buf[m++] = vcm[0];
+      buf[m++] = vcm[1];
+      buf[m++] = vcm[2];
+      angmom = body[bodyown[i]].angmom;
+      buf[m++] = angmom[0];
+      buf[m++] = angmom[1];
+      buf[m++] = angmom[2];
+    }
+
+  } else if (commflag == XCM_MASS) {
+    for (i = first; i < last; i++) {
+      if (bodyown[i] < 0) continue;
+      xcm = body[bodyown[i]].xcm;
+      buf[m++] = xcm[0];
+      buf[m++] = xcm[1];
+      buf[m++] = xcm[2];
+      buf[m++] = body[bodyown[i]].mass;
+    }
+
+  } else if (commflag == ITENSOR) {
+    for (i = first; i < last; i++) {
+      if (bodyown[i] < 0) continue;
+      j = bodyown[i];
+      buf[m++] = itensor[j][0];
+      buf[m++] = itensor[j][1];
+      buf[m++] = itensor[j][2];
+      buf[m++] = itensor[j][3];
+      buf[m++] = itensor[j][4];
+      buf[m++] = itensor[j][5];
+    }
+
+  } else if (commflag == DOF) {
+    for (i = first; i < last; i++) {
+      if (bodyown[i] < 0) continue;
+      j = bodyown[i];
+      buf[m++] = counts[j][0];
+      buf[m++] = counts[j][1];
+      buf[m++] = counts[j][2];
+    }
+  }
+
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   only unpack body info if own or ghost atom owns the body
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::unpack_reverse_comm(int n, int *list, double *buf)
+{
+  int i,j,k;
+  double *fcm,*torque,*vcm,*angmom,*xcm;
+
+  int m = 0;
+
+  if (commflag == FORCE_TORQUE) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) continue;
+      fcm = body[bodyown[j]].fcm;
+      fcm[0] += buf[m++];
+      fcm[1] += buf[m++];
+      fcm[2] += buf[m++];
+      torque = body[bodyown[j]].torque;
+      torque[0] += buf[m++];
+      torque[1] += buf[m++];
+      torque[2] += buf[m++];
+    }
+
+  } else if (commflag == VCM_ANGMOM) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) continue;
+      vcm = body[bodyown[j]].vcm;
+      vcm[0] += buf[m++];
+      vcm[1] += buf[m++];
+      vcm[2] += buf[m++];
+      angmom = body[bodyown[j]].angmom;
+      angmom[0] += buf[m++];
+      angmom[1] += buf[m++];
+      angmom[2] += buf[m++];
+    }
+
+  } else if (commflag == XCM_MASS) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) continue;
+      xcm = body[bodyown[j]].xcm;
+      xcm[0] += buf[m++];
+      xcm[1] += buf[m++];
+      xcm[2] += buf[m++];
+      body[bodyown[j]].mass += buf[m++];
+    }
+
+  } else if (commflag == ITENSOR) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) continue;
+      k = bodyown[j];
+      itensor[k][0] += buf[m++];
+      itensor[k][1] += buf[m++];
+      itensor[k][2] += buf[m++];
+      itensor[k][3] += buf[m++];
+      itensor[k][4] += buf[m++];
+      itensor[k][5] += buf[m++];
+    }
+
+  } else if (commflag == DOF) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      if (bodyown[j] < 0) continue;
+      k = bodyown[j];
+      counts[k][0] += static_cast<int> (buf[m++]);
+      counts[k][1] += static_cast<int> (buf[m++]);
+      counts[k][2] += static_cast<int> (buf[m++]);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   grow body data structure
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::grow_body()
+{
+  nmax_body += DELTA_BODY;
+  body = (Body *) memory->srealloc(body,nmax_body*sizeof(Body),
+                                   "rigid/small:body");
+}
+
+/* ----------------------------------------------------------------------
+   reset atom2body for all owned atoms
+   do this via bodyown of atom that owns the body the owned atom is in
+   atom2body values can point to original body or any image of the body
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::reset_atom2body()
+{
+  int iowner;
+
+  // iowner = index of atom that owns the body that atom I is in
+
+  int nlocal = atom->nlocal;
+
+  for (int i = 0; i < nlocal; i++) {
+    atom2body[i] = -1;
+    if (bodytag[i]) {
+      iowner = atom->map(bodytag[i]);
+      if (iowner == -1) {
+        char str[128];
+        sprintf(str,
+                "Rigid body atoms " TAGINT_FORMAT " " TAGINT_FORMAT
+                " missing on proc %d at step " BIGINT_FORMAT,
+                atom->tag[i],bodytag[i],comm->me,update->ntimestep);
+        error->one(FLERR,str);
+
+      }
+      atom2body[i] = bodyown[iowner];
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixRigidSmall::reset_dt()
+{
+  dtv = update->dt;
+  dtf = 0.5 * update->dt * force->ftm2v;
+  dtq = 0.5 * update->dt;
+}
+
+/* ----------------------------------------------------------------------
+   zero linear momentum of each rigid body
+   set Vcm to 0.0, then reset velocities of particles via set_v()
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::zero_momentum()
+{
+  double *vcm;
+  for (int ibody = 0; ibody < nlocal_body+nghost_body; ibody++) {
+    vcm = body[ibody].vcm;
+    vcm[0] = vcm[1] = vcm[2] = 0.0;
+  }
+
+  // forward communicate of vcm to all ghost copies
+
+  commflag = FINAL;
+  comm->forward_comm_fix(this,10);
+
+  // set velocity of atoms in rigid bodues
+
+  evflag = 0;
+  set_v();
+}
+
+/* ----------------------------------------------------------------------
+   zero angular momentum of each rigid body
+   set angmom/omega to 0.0, then reset velocities of particles via set_v()
+------------------------------------------------------------------------- */
+
+void FixRigidSmall::zero_rotation()
+{
+  double *angmom,*omega;
+  for (int ibody = 0; ibody < nlocal_body+nghost_body; ibody++) {
+    angmom = body[ibody].angmom;
+    angmom[0] = angmom[1] = angmom[2] = 0.0;
+    omega = body[ibody].omega;
+    omega[0] = omega[1] = omega[2] = 0.0;
+  }
+
+  // forward communicate of omega to all ghost copies
+
+  commflag = FINAL;
+  comm->forward_comm_fix(this,10);
+
+  // set velocity of atoms in rigid bodues
+
+  evflag = 0;
+  set_v();
+}
+
+/* ---------------------------------------------------------------------- */
+
+void *FixRigidSmall::extract(const char *str, int &dim)
+{
+  if (strcmp(str,"body") == 0) {
+    dim = 1;
+    return atom2body;
+  }
+
+  if (strcmp(str,"onemol") == 0) {
+    dim = 0;
+    return onemols;
+  }
+
+  // return vector of rigid body masses, for owned+ghost bodies
+  // used by granular pair styles, indexed by atom2body
+
+  if (strcmp(str,"masstotal") == 0) {
+    dim = 1;
+
+    if (nmax_mass < nmax_body) {
+      memory->destroy(mass_body);
+      nmax_mass = nmax_body;
+      memory->create(mass_body,nmax_mass,"rigid:mass_body");
+    }
+
+    int n = nlocal_body + nghost_body;
+    for (int i = 0; i < n; i++)
+      mass_body[i] = body[i].mass;
+
+    return mass_body;
+  }
+
+  return NULL;
+}
+
+/* ----------------------------------------------------------------------
+   return translational KE for all rigid bodies
+   KE = 1/2 M Vcm^2
+   sum local body results across procs
+------------------------------------------------------------------------- */
+
+double FixRigidSmall::extract_ke()
+{
+  double *vcm;
+
+  double ke = 0.0;
+  for (int i = 0; i < nlocal_body; i++) {
+    vcm = body[i].vcm;
+    ke += body[i].mass * (vcm[0]*vcm[0] + vcm[1]*vcm[1] + vcm[2]*vcm[2]);
+  }
+
+  double keall;
+  MPI_Allreduce(&ke,&keall,1,MPI_DOUBLE,MPI_SUM,world);
+
+  return 0.5*keall;
+}
+
+/* ----------------------------------------------------------------------
+   return rotational KE for all rigid bodies
+   Erotational = 1/2 I wbody^2
+------------------------------------------------------------------------- */
+
+double FixRigidSmall::extract_erotational()
+{
+  double wbody[3],rot[3][3];
+  double *inertia;
+
+  double erotate = 0.0;
+  for (int i = 0; i < nlocal_body; i++) {
+
+    // for Iw^2 rotational term, need wbody = angular velocity in body frame
+    // not omega = angular velocity in space frame
+
+    inertia = body[i].inertia;
+    MathExtra::quat_to_mat(body[i].quat,rot);
+    MathExtra::transpose_matvec(rot,body[i].angmom,wbody);
+    if (inertia[0] == 0.0) wbody[0] = 0.0;
+    else wbody[0] /= inertia[0];
+    if (inertia[1] == 0.0) wbody[1] = 0.0;
+    else wbody[1] /= inertia[1];
+    if (inertia[2] == 0.0) wbody[2] = 0.0;
+    else wbody[2] /= inertia[2];
+
+    erotate += inertia[0]*wbody[0]*wbody[0] + inertia[1]*wbody[1]*wbody[1] +
+      inertia[2]*wbody[2]*wbody[2];
+  }
+
+  double erotateall;
+  MPI_Allreduce(&erotate,&erotateall,1,MPI_DOUBLE,MPI_SUM,world);
+
+  return 0.5*erotateall;
+}
+
+/* ----------------------------------------------------------------------
+   return temperature of collection of rigid bodies
+   non-active DOF are removed by fflag/tflag and in tfactor
+------------------------------------------------------------------------- */
+
+double FixRigidSmall::compute_scalar()
+{
+  double wbody[3],rot[3][3];
+
+  double *vcm,*inertia;
+
+  double t = 0.0;
+
+  for (int i = 0; i < nlocal_body; i++) {
+    vcm = body[i].vcm;
+    t += body[i].mass * (vcm[0]*vcm[0] + vcm[1]*vcm[1] + vcm[2]*vcm[2]);
+
+    // for Iw^2 rotational term, need wbody = angular velocity in body frame
+    // not omega = angular velocity in space frame
+
+    inertia = body[i].inertia;
+    MathExtra::quat_to_mat(body[i].quat,rot);
+    MathExtra::transpose_matvec(rot,body[i].angmom,wbody);
+    if (inertia[0] == 0.0) wbody[0] = 0.0;
+    else wbody[0] /= inertia[0];
+    if (inertia[1] == 0.0) wbody[1] = 0.0;
+    else wbody[1] /= inertia[1];
+    if (inertia[2] == 0.0) wbody[2] = 0.0;
+    else wbody[2] /= inertia[2];
+
+    t += inertia[0]*wbody[0]*wbody[0] + inertia[1]*wbody[1]*wbody[1] +
+      inertia[2]*wbody[2]*wbody[2];
+  }
+
+  double tall;
+  MPI_Allreduce(&t,&tall,1,MPI_DOUBLE,MPI_SUM,world);
+
+  double tfactor = force->mvv2e / ((6.0*nbody - nlinear) * force->boltz);
+  tall *= tfactor;
+  return tall;
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based arrays
+------------------------------------------------------------------------- */
+
+double FixRigidSmall::memory_usage()
+{
+  int nmax = atom->nmax;
+  double bytes = nmax*2 * sizeof(int);
+  bytes += nmax * sizeof(imageint);
+  bytes += nmax*3 * sizeof(double);
+  bytes += maxvatom*6 * sizeof(double);     // vatom
+  if (extended) {
+    bytes += nmax * sizeof(int);
+    if (orientflag) bytes = nmax*orientflag * sizeof(double);
+    if (dorientflag) bytes = nmax*3 * sizeof(double);
+  }
+  bytes += nmax_body * sizeof(Body);
+  return bytes;
+}
+
+/* ----------------------------------------------------------------------
+   debug method for sanity checking of atom/body data pointers
+------------------------------------------------------------------------- */
+
+/*
+void FixRigidSmall::check(int flag)
+{
+  for (int i = 0; i < atom->nlocal; i++) {
+    if (bodyown[i] >= 0) {
+      if (bodytag[i] != atom->tag[i]) {
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD AAA");
+      }
+      if (bodyown[i] < 0 || bodyown[i] >= nlocal_body) {
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD BBB");
+      }
+      if (atom2body[i] != bodyown[i]) {
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD CCC");
+      }
+      if (body[bodyown[i]].ilocal != i) {
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD DDD");
+      }
+    }
+  }
+
+  for (int i = 0; i < atom->nlocal; i++) {
+    if (bodyown[i] < 0 && bodytag[i] > 0) {
+      if (atom2body[i] < 0 || atom2body[i] >= nlocal_body+nghost_body) {
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD EEE");
+      }
+      if (bodytag[i] != atom->tag[body[atom2body[i]].ilocal]) {
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD FFF");
+      }
+    }
+  }
+
+  for (int i = atom->nlocal; i < atom->nlocal + atom->nghost; i++) {
+    if (bodyown[i] >= 0) {
+      if (bodyown[i] < nlocal_body ||
+          bodyown[i] >= nlocal_body+nghost_body) {
+        printf("Values %d %d: %d %d %d\n",
+               i,atom->tag[i],bodyown[i],nlocal_body,nghost_body);
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD GGG");
+      }
+      if (body[bodyown[i]].ilocal != i) {
+        printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+        errorx->one(FLERR,"BAD HHH");
+      }
+    }
+  }
+
+  for (int i = 0; i < nlocal_body; i++) {
+    if (body[i].ilocal < 0 || body[i].ilocal >= atom->nlocal) {
+      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+      errorx->one(FLERR,"BAD III");
+    }
+    if (bodytag[body[i].ilocal] != atom->tag[body[i].ilocal] ||
+        bodyown[body[i].ilocal] != i) {
+      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+      errorx->one(FLERR,"BAD JJJ");
+    }
+  }
+
+  for (int i = nlocal_body; i < nlocal_body + nghost_body; i++) {
+    if (body[i].ilocal < atom->nlocal ||
+        body[i].ilocal >= atom->nlocal + atom->nghost) {
+      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+      errorx->one(FLERR,"BAD KKK");
+    }
+    if (bodyown[body[i].ilocal] != i) {
+      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
+      errorx->one(FLERR,"BAD LLL");
+    }
+  }
+}
+*/
diff -uN src/fix_rigid_small.h src_DFT-CES2/fix_rigid_small.h
--- src/fix_rigid_small.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_rigid_small.h	2025-02-11 06:42:37.177608906 +0900
@@ -0,0 +1,324 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(rigid/small,FixRigidSmall)
+
+#else
+
+#ifndef LMP_FIX_RIGID_SMALL_H
+#define LMP_FIX_RIGID_SMALL_H
+
+#include "fix.h"
+
+// replace this later
+#include <map>
+
+namespace LAMMPS_NS {
+
+class FixRigidSmall : public Fix {
+  friend class ComputeRigidLocal;
+
+ public:
+  FixRigidSmall(class LAMMPS *, int, char **);
+  virtual ~FixRigidSmall();
+  virtual int setmask();
+  virtual void init();
+  virtual void setup(int);
+  virtual void initial_integrate(int);
+  void post_force(int);
+  virtual void final_integrate();
+  void initial_integrate_respa(int, int, int);
+  void final_integrate_respa(int, int);
+  void write_restart_file(char *);
+
+  void grow_arrays(int);
+  void copy_arrays(int, int, int);
+  void set_arrays(int);
+  void set_molecule(int, tagint, int, double *, double *, double *);
+
+  int pack_exchange(int, double *);
+  int unpack_exchange(int, double *);
+  int pack_forward_comm(int, int *, double *, int, int *);
+  void unpack_forward_comm(int, int, double *);
+  int pack_reverse_comm(int, int, double *);
+  void unpack_reverse_comm(int, int *, double *);
+
+  void setup_pre_neighbor();
+  void pre_neighbor();
+  int dof(int);
+  void deform(int);
+  void enforce2d();
+  void reset_dt();
+  void zero_momentum();
+  void zero_rotation();
+  void *extract(const char*, int &);
+  double extract_ke();
+  double extract_erotational();
+  double compute_scalar();
+  double memory_usage();
+
+ protected:
+  int me,nprocs;
+  double dtv,dtf,dtq;
+  double *step_respa;
+  int triclinic;
+  double MINUSPI,TWOPI;
+
+  char *infile;             // file to read rigid body attributes from
+  int setupflag;            // 1 if body properties are setup, else 0
+  int commflag;             // various modes of forward/reverse comm
+  int nbody;                // total # of rigid bodies
+  int nlinear;              // total # of linear rigid bodies
+  tagint maxmol;            // max mol-ID
+  double maxextent;         // furthest distance from body owner to body atom
+
+  struct Body {
+    double mass;              // total mass of body
+    double xcm[3];            // COM position
+    double vcm[3];            // COM velocity
+    double fcm[3];            // force on COM
+    double torque[3];         // torque around COM
+    double quat[4];           // quaternion for orientation of body
+    double inertia[3];        // 3 principal components of inertia
+    double ex_space[3];       // principal axes in space coords
+    double ey_space[3];
+    double ez_space[3];
+    double angmom[3];         // space-frame angular momentum of body
+    double omega[3];          // space-frame omega of body
+    double conjqm[4];         // conjugate quaternion momentum
+    imageint image;           // image flags of xcm
+    int remapflag[4];         // PBC remap flags
+    int ilocal;               // index of owning atom
+  };
+
+  Body *body;               // list of rigid bodies, owned and ghost
+  int nlocal_body;          // # of owned rigid bodies
+  int nghost_body;          // # of ghost rigid bodies
+  int nmax_body;            // max # of bodies that body can hold
+  int bodysize;             // sizeof(Body) in doubles
+
+  // per-atom quantities
+  // only defined for owned atoms, except bodyown for own+ghost
+
+  int *bodyown;         // index of body if atom owns a body, -1 if not
+  tagint *bodytag;      // ID of body this atom is in, 0 if none
+                        // ID = tag of atom that owns body
+  int *atom2body;       // index of owned/ghost body this atom is in, -1 if not
+                        // can point to original or any image of the body
+  imageint *xcmimage;   // internal image flags for atoms in rigid bodies
+                        // set relative to in-box xcm of each body
+  double **displace;    // displacement of each atom in body coords
+  int *eflags;          // flags for extended particles
+  double **orient;      // orientation vector of particle wrt rigid body
+  double **dorient;     // orientation of dipole mu wrt rigid body
+
+  int extended;         // 1 if any particles have extended attributes
+  int orientflag;       // 1 if particles store spatial orientation
+  int dorientflag;      // 1 if particles store dipole orientation
+  int reinitflag;       // 1 if re-initialize rigid bodies between runs
+
+  int POINT,SPHERE,ELLIPSOID,LINE,TRIANGLE,DIPOLE;   // bitmasks for eflags
+  int OMEGA,ANGMOM,TORQUE;
+
+  class AtomVecEllipsoid *avec_ellipsoid;
+  class AtomVecLine *avec_line;
+  class AtomVecTri *avec_tri;
+
+  // temporary per-body storage
+
+  int **counts;            // counts of atom types in bodies
+  double **itensor;        // 6 space-frame components of inertia tensor
+
+  // mass per body, accessed by granular pair styles
+
+  double *mass_body;
+  int nmax_mass;
+
+  // Langevin thermostatting
+
+  int langflag;                     // 0/1 = no/yes Langevin thermostat
+  double t_start,t_stop,t_period;   // thermostat params
+  double **langextra;               // Langevin thermostat forces and torques
+  int maxlang;                      // max size of langextra
+  class RanMars *random;            // RNG
+
+  int tstat_flag,pstat_flag;        // 0/1 = no/yes thermostat/barostat
+
+  int t_chain,t_iter,t_order;
+
+  double p_start[3],p_stop[3];
+  double p_period[3],p_freq[3];
+  int p_flag[3];
+  int pcouple,pstyle;
+  int p_chain;
+
+  int allremap;              // remap all atoms
+  int dilate_group_bit;      // mask for dilation group
+  char *id_dilate;           // group name to dilate
+
+  double p_current[3],p_target[3];
+
+  // molecules added on-the-fly as rigid bodies
+
+  class Molecule **onemols;
+  int nmol;
+
+  // class data used by ring communication callbacks
+
+  std::map<tagint,int> *hash;
+  double **bbox;
+  double **ctr;
+  tagint *idclose;
+  double *rsqclose;
+  double rsqfar;
+
+  void image_shift();
+  void set_xv();
+  void set_v();
+  void create_bodies();
+  void setup_bodies_static();
+  void setup_bodies_dynamic();
+  void readfile(int, double **, int *);
+  void grow_body();
+  void reset_atom2body();
+
+  // callback functions for ring communication
+
+  static void ring_bbox(int, char *, void *);
+  static void ring_nearest(int, char *, void *);
+  static void ring_farthest(int, char *, void *);
+
+  // debug
+
+  //void check(int);
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Fix rigid/small requires atom attribute molecule
+
+Self-explanatory.
+
+E: Fix rigid/small requires an atom map, see atom_modify
+
+Self-explanatory.
+
+E: Fix rigid/small langevin period must be > 0.0
+
+Self-explanatory.
+
+E: Molecule template ID for fix rigid/small does not exist
+
+Self-explanatory.
+
+E: Fix rigid/small nvt/npt/nph dilate group ID does not exist
+
+Self-explanatory.
+
+E: Fix rigid/small molecule must have coordinates
+
+The defined molecule does not specify coordinates.
+
+E: Fix rigid/small molecule must have atom types
+
+The defined molecule does not specify atom types.
+
+W: More than one fix rigid
+
+It is not efficient to use fix rigid more than once.
+
+E: Rigid fix must come before NPT/NPH fix
+
+NPT/NPH fix must be defined in input script after all rigid fixes,
+else the rigid fix contribution to the pressure virial is
+incorrect.
+
+W: Cannot count rigid body degrees-of-freedom before bodies are fully initialized
+
+This means the temperature associated with the rigid bodies may be
+incorrect on this timestep.
+
+W: Computing temperature of portions of rigid bodies
+
+The group defined by the temperature compute does not encompass all
+the atoms in one or more rigid bodies, so the change in
+degrees-of-freedom for the atoms in those partial rigid bodies will
+not be accounted for.
+
+E: Fix rigid/small atom has non-zero image flag in a non-periodic dimension
+
+Image flags for non-periodic dimensions should not be set.
+
+E: One or more rigid bodies are a single particle
+
+Self-explanatory.
+
+E: Inconsistent use of finite-size particles by molecule template molecules
+
+Not all of the molecules define a radius for their constituent
+particles.
+
+E: Insufficient Jacobi rotations for rigid body
+
+Eigensolve for rigid body was not sufficiently accurate.
+
+E: Fix rigid: Bad principal moments
+
+The principal moments of inertia computed for a rigid body
+are not within the required tolerances.
+
+E: Cannot open fix rigid/small infile %s
+
+The specified file cannot be opened.  Check that the path and name are
+correct.
+
+E: Unexpected end of fix rigid/small file
+
+A read operation from the file failed.
+
+E: Incorrect rigid body format in fix rigid/small file
+
+The number of fields per line is not what expected.
+
+E: Invalid rigid body ID in fix rigid/small file
+
+The ID does not match the number of an existing ID of rigid bodies
+that are defined by the fix rigid/small command.
+
+E: Cannot open fix rigid restart file %s
+
+The specified file cannot be opened.  Check that the path and name are
+correct.
+
+E: Rigid body atoms %d %d missing on proc %d at step %ld
+
+This means that an atom cannot find the atom that owns the rigid body
+it is part of, or vice versa.  The solution is to use the communicate
+cutoff command to insure ghost atoms are acquired from far enough away
+to encompass the max distance printed when the fix rigid/small command
+was invoked.
+
+*/
diff -uN src/fix_shake.cpp src_DFT-CES2/fix_shake.cpp
--- src/fix_shake.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_shake.cpp	2025-02-11 06:42:37.184608974 +0900
@@ -0,0 +1,2836 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <mpi.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include "fix_shake.h"
+#include "fix_rattle.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "update.h"
+#include "respa.h"
+#include "modify.h"
+#include "domain.h"
+#include "force.h"
+#include "bond.h"
+#include "angle.h"
+#include "comm.h"
+#include "group.h"
+#include "fix_respa.h"
+#include "math_const.h"
+#include "memory.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathConst;
+
+#define BIG 1.0e20
+#define MASSDELTA 0.1
+
+/* ---------------------------------------------------------------------- */
+
+FixShake::FixShake(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg), bond_flag(NULL), angle_flag(NULL), 
+  type_flag(NULL), mass_list(NULL), bond_distance(NULL), angle_distance(NULL), 
+  loop_respa(NULL), step_respa(NULL), x(NULL), v(NULL), f(NULL), ftmp(NULL), 
+  vtmp(NULL), mass(NULL), rmass(NULL), type(NULL), shake_flag(NULL), 
+  shake_atom(NULL), shake_type(NULL), xshake(NULL), nshake(NULL), 
+  list(NULL), b_count(NULL), b_count_all(NULL), b_ave(NULL), b_max(NULL), 
+  b_min(NULL), b_ave_all(NULL), b_max_all(NULL), b_min_all(NULL), 
+  a_count(NULL), a_count_all(NULL), a_ave(NULL), a_max(NULL), a_min(NULL), 
+  a_ave_all(NULL), a_max_all(NULL), a_min_all(NULL), atommols(NULL), 
+  onemols(NULL)
+{
+  MPI_Comm_rank(world,&me);
+  MPI_Comm_size(world,&nprocs);
+
+  virial_flag = 1;
+  create_attribute = 1;
+  dof_flag = 1;
+
+  // error check
+
+  molecular = atom->molecular;
+  if (molecular == 0)
+    error->all(FLERR,"Cannot use fix shake with non-molecular system");
+
+  // perform initial allocation of atom-based arrays
+  // register with Atom class
+
+  shake_flag = NULL;
+  shake_atom = NULL;
+  shake_type = NULL;
+  xshake = NULL;
+
+  ftmp = NULL; 
+  vtmp = NULL;
+
+  grow_arrays(atom->nmax);
+  atom->add_callback(0);
+
+  // set comm size needed by this fix
+
+  comm_forward = 3;
+
+  // parse SHAKE args
+
+  if (narg < 8) error->all(FLERR,"Illegal fix shake command");
+
+  tolerance = force->numeric(FLERR,arg[3]);
+  max_iter = force->inumeric(FLERR,arg[4]);
+  output_every = force->inumeric(FLERR,arg[5]);
+
+  // parse SHAKE args for bond and angle types
+  // will be used by find_clusters
+  // store args for "b" "a" "t" as flags in (1:n) list for fast access
+  // store args for "m" in list of length nmass for looping over
+  // for "m" verify that atom masses have been set
+
+  bond_flag = new int[atom->nbondtypes+1];
+  for (int i = 1; i <= atom->nbondtypes; i++) bond_flag[i] = 0;
+  angle_flag = new int[atom->nangletypes+1];
+  for (int i = 1; i <= atom->nangletypes; i++) angle_flag[i] = 0;
+  type_flag = new int[atom->ntypes+1];
+  for (int i = 1; i <= atom->ntypes; i++) type_flag[i] = 0;
+  mass_list = new double[atom->ntypes];
+  nmass = 0;
+
+  char mode = '\0';
+  int next = 6;
+  while (next < narg) {
+    if (strcmp(arg[next],"b") == 0) mode = 'b';
+    else if (strcmp(arg[next],"a") == 0) mode = 'a';
+    else if (strcmp(arg[next],"t") == 0) mode = 't';
+    else if (strcmp(arg[next],"m") == 0) {
+      mode = 'm';
+      atom->check_mass(FLERR);
+
+    // break if keyword that is not b,a,t,m
+
+    } else if (isalpha(arg[next][0])) break;
+
+    // read numeric args of b,a,t,m
+
+    else if (mode == 'b') {
+      int i = force->inumeric(FLERR,arg[next]);
+      if (i < 1 || i > atom->nbondtypes)
+        error->all(FLERR,"Invalid bond type index for fix shake");
+      bond_flag[i] = 1;
+
+    } else if (mode == 'a') {
+      int i = force->inumeric(FLERR,arg[next]);
+      if (i < 1 || i > atom->nangletypes)
+        error->all(FLERR,"Invalid angle type index for fix shake");
+      angle_flag[i] = 1;
+
+    } else if (mode == 't') {
+      int i = force->inumeric(FLERR,arg[next]);
+      if (i < 1 || i > atom->ntypes)
+        error->all(FLERR,"Invalid atom type index for fix shake");
+      type_flag[i] = 1;
+
+    } else if (mode == 'm') {
+      double massone = force->numeric(FLERR,arg[next]);
+      if (massone == 0.0) error->all(FLERR,"Invalid atom mass for fix shake");
+      if (nmass == atom->ntypes)
+        error->all(FLERR,"Too many masses for fix shake");
+      mass_list[nmass++] = massone;
+
+    } else error->all(FLERR,"Illegal fix shake command");
+    next++;
+  }
+
+  // parse optional args
+
+  onemols = NULL;
+
+  int iarg = next;
+  while (iarg < narg) {
+    if (strcmp(arg[next],"mol") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal fix shake command");
+      int imol = atom->find_molecule(arg[iarg+1]);
+      if (imol == -1)
+        error->all(FLERR,"Molecule template ID for fix shake does not exist");
+      if (atom->molecules[imol]->nset > 1 && comm->me == 0)
+        error->warning(FLERR,"Molecule template for "
+                       "fix shake has multiple molecules");
+      onemols = &atom->molecules[imol];
+      nmol = onemols[0]->nset;
+      iarg += 2;
+    } else error->all(FLERR,"Illegal fix shake command");
+  }
+
+  // error check for Molecule template
+
+  if (onemols) {
+    for (int i = 0; i < nmol; i++)
+      if (onemols[i]->shakeflag == 0)
+        error->all(FLERR,"Fix shake molecule template must have shake info");
+  }
+
+  // allocate bond and angle distance arrays, indexed from 1 to n
+
+  bond_distance = new double[atom->nbondtypes+1];
+  angle_distance = new double[atom->nangletypes+1];
+
+  // allocate statistics arrays
+
+  if (output_every) {
+    int nb = atom->nbondtypes + 1;
+    b_count = new int[nb];
+    b_count_all = new int[nb];
+    b_ave = new double[nb];
+    b_ave_all = new double[nb];
+    b_max = new double[nb];
+    b_max_all = new double[nb];
+    b_min = new double[nb];
+    b_min_all = new double[nb];
+
+    int na = atom->nangletypes + 1;
+    a_count = new int[na];
+    a_count_all = new int[na];
+    a_ave = new double[na];
+    a_ave_all = new double[na];
+    a_max = new double[na];
+    a_max_all = new double[na];
+    a_min = new double[na];
+    a_min_all = new double[na];
+  }
+
+  // SHAKE vs RATTLE
+
+  rattle = 0;
+
+  // identify all SHAKE clusters
+
+  find_clusters();
+
+  // initialize list of SHAKE clusters to constrain
+
+  maxlist = 0;
+  list = NULL;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixShake::~FixShake()
+{
+  // unregister callbacks to this fix from Atom class
+
+  atom->delete_callback(id,0);
+
+  // set bond_type and angle_type back to positive for SHAKE clusters
+  // must set for all SHAKE bonds and angles stored by each atom
+
+  int nlocal = atom->nlocal;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (shake_flag[i] == 0) continue;
+    else if (shake_flag[i] == 1) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][2],1);
+      angletype_findset(i,shake_atom[i][1],shake_atom[i][2],1);
+    } else if (shake_flag[i] == 2) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],1);
+    } else if (shake_flag[i] == 3) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][2],1);
+    } else if (shake_flag[i] == 4) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][2],1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][3],1);
+    }
+  }
+
+  // delete locally stored arrays
+
+  memory->destroy(shake_flag);
+  memory->destroy(shake_atom);
+  memory->destroy(shake_type);
+  memory->destroy(xshake);
+  memory->destroy(ftmp);
+  memory->destroy(vtmp);
+
+
+  delete [] bond_flag;
+  delete [] angle_flag;
+  delete [] type_flag;
+  delete [] mass_list;
+
+  delete [] bond_distance;
+  delete [] angle_distance;
+
+  if (output_every) {
+    delete [] b_count;
+    delete [] b_count_all;
+    delete [] b_ave;
+    delete [] b_ave_all;
+    delete [] b_max;
+    delete [] b_max_all;
+    delete [] b_min;
+    delete [] b_min_all;
+
+    delete [] a_count;
+    delete [] a_count_all;
+    delete [] a_ave;
+    delete [] a_ave_all;
+    delete [] a_max;
+    delete [] a_max_all;
+    delete [] a_min;
+    delete [] a_min_all;
+  }
+
+  memory->destroy(list);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixShake::setmask()
+{
+  int mask = 0;
+  mask |= PRE_NEIGHBOR;
+  mask |= POST_FORCE;
+  mask |= POST_FORCE_RESPA;
+  return mask;
+}
+
+/* ----------------------------------------------------------------------
+   set bond and angle distances
+   this init must happen after force->bond and force->angle inits
+------------------------------------------------------------------------- */
+
+void FixShake::init()
+{
+  int i,m,flag,flag_all,type1,type2,bond1_type,bond2_type;
+  double rsq,angle;
+
+  // error if more than one shake fix
+
+  int count = 0;
+  for (i = 0; i < modify->nfix; i++)
+    if (strcmp(modify->fix[i]->style,"shake") == 0) count++;
+  if (count > 1) error->all(FLERR,"More than one fix shake");
+
+  // cannot use with minimization since SHAKE turns off bonds
+  // that should contribute to potential energy
+
+  if (update->whichflag == 2)
+    error->all(FLERR,"Fix shake cannot be used with minimization");
+
+  // error if npt,nph fix comes before shake fix
+
+  for (i = 0; i < modify->nfix; i++) {
+    if (strcmp(modify->fix[i]->style,"npt") == 0) break;
+    if (strcmp(modify->fix[i]->style,"nph") == 0) break;
+  }
+  if (i < modify->nfix) {
+    for (int j = i; j < modify->nfix; j++)
+      if (strcmp(modify->fix[j]->style,"shake") == 0)
+        error->all(FLERR,"Shake fix must come before NPT/NPH fix");
+  }
+
+  // if rRESPA, find associated fix that must exist
+  // could have changed locations in fix list since created
+  // set ptrs to rRESPA variables
+
+  if (strstr(update->integrate_style,"respa")) {
+    for (i = 0; i < modify->nfix; i++)
+      if (strcmp(modify->fix[i]->style,"RESPA") == 0) ifix_respa = i;
+    nlevels_respa = ((Respa *) update->integrate)->nlevels;
+    loop_respa = ((Respa *) update->integrate)->loop;
+    step_respa = ((Respa *) update->integrate)->step;
+  }
+
+  // set equilibrium bond distances
+
+  if (force->bond == NULL)
+    error->all(FLERR,"Bond potential must be defined for SHAKE");
+  for (i = 1; i <= atom->nbondtypes; i++)
+    bond_distance[i] = force->bond->equilibrium_distance(i);
+
+  // set equilibrium angle distances
+
+  int nlocal = atom->nlocal;
+
+  for (i = 1; i <= atom->nangletypes; i++) {
+    if (angle_flag[i] == 0) continue;
+    if (force->angle == NULL)
+      error->all(FLERR,"Angle potential must be defined for SHAKE");
+
+    // scan all atoms for a SHAKE angle cluster
+    // extract bond types for the 2 bonds in the cluster
+    // bond types must be same in all clusters of this angle type,
+    //   else set error flag
+
+    flag = 0;
+    bond1_type = bond2_type = 0;
+    for (m = 0; m < nlocal; m++) {
+      if (shake_flag[m] != 1) continue;
+      if (shake_type[m][2] != i) continue;
+      type1 = MIN(shake_type[m][0],shake_type[m][1]);
+      type2 = MAX(shake_type[m][0],shake_type[m][1]);
+      if (bond1_type > 0) {
+        if (type1 != bond1_type || type2 != bond2_type) {
+          flag = 1;
+          break;
+        }
+      }
+      bond1_type = type1;
+      bond2_type = type2;
+    }
+
+    // error check for any bond types that are not the same
+
+    MPI_Allreduce(&flag,&flag_all,1,MPI_INT,MPI_MAX,world);
+    if (flag_all) error->all(FLERR,"Shake angles have different bond types");
+
+    // insure all procs have bond types
+
+    MPI_Allreduce(&bond1_type,&flag_all,1,MPI_INT,MPI_MAX,world);
+    bond1_type = flag_all;
+    MPI_Allreduce(&bond2_type,&flag_all,1,MPI_INT,MPI_MAX,world);
+    bond2_type = flag_all;
+
+    // if bond types are 0, no SHAKE angles of this type exist
+    // just skip this angle
+
+    if (bond1_type == 0) {
+      angle_distance[i] = 0.0;
+      continue;
+    }
+
+    // compute the angle distance as a function of 2 bond distances
+    // formula is now correct for bonds of same or different lengths (Oct15)
+
+    angle = force->angle->equilibrium_angle(i);
+    const double b1 = bond_distance[bond1_type];
+    const double b2 = bond_distance[bond2_type];
+    rsq = b1*b1 + b2*b2 - 2.0*b1*b2*cos(angle);
+    angle_distance[i] = sqrt(rsq);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   SHAKE as pre-integrator constraint
+------------------------------------------------------------------------- */
+
+void FixShake::setup(int vflag)
+{
+  pre_neighbor();
+
+  if (output_every) stats();
+
+  // setup SHAKE output
+
+  bigint ntimestep = update->ntimestep;
+  if (output_every) {
+    next_output = ntimestep + output_every;
+    if (ntimestep % output_every != 0)
+      next_output = (ntimestep/output_every)*output_every + output_every;
+  } else next_output = -1;
+
+  // set respa to 0 if verlet is used and to 1 otherwise
+
+  if (strstr(update->integrate_style,"verlet")) 
+    respa = 0;
+  else
+    respa = 1;
+
+  if (!respa) {
+    dtv     = update->dt;
+    dtfsq   = 0.5 * update->dt * update->dt * force->ftm2v;
+    if (!rattle) dtfsq = update->dt * update->dt * force->ftm2v;
+  } else {
+    dtv = step_respa[0];
+    dtf_innerhalf = 0.5 * step_respa[0] * force->ftm2v;
+    dtf_inner = dtf_innerhalf;
+  }
+
+  // correct geometry of cluster if necessary
+
+  correct_coordinates(vflag);
+
+  // remove velocities along any bonds
+
+  correct_velocities();
+
+  // precalculate constraining forces for first integration step
+
+  shake_end_of_step(vflag);
+}
+
+/* ----------------------------------------------------------------------
+   build list of SHAKE clusters to constrain
+   if one or more atoms in cluster are on this proc,
+     this proc lists the cluster exactly once
+------------------------------------------------------------------------- */
+
+void FixShake::pre_neighbor()
+{
+  int atom1,atom2,atom3,atom4;
+
+  // local copies of atom quantities
+  // used by SHAKE until next re-neighboring
+
+  x = atom->x;
+  v = atom->v;
+  f = atom->f;
+  mass = atom->mass;
+  rmass = atom->rmass;
+  type = atom->type;
+  nlocal = atom->nlocal;
+
+  // extend size of SHAKE list if necessary
+
+  if (nlocal > maxlist) {
+    maxlist = nlocal;
+    memory->destroy(list);
+    memory->create(list,maxlist,"shake:list");
+  }
+
+  // build list of SHAKE clusters I compute
+
+  nlist = 0;
+
+  for (int i = 0; i < nlocal; i++)
+    if (shake_flag[i]) {
+      if (shake_flag[i] == 2) {
+        atom1 = atom->map(shake_atom[i][0]);
+        atom2 = atom->map(shake_atom[i][1]);
+        if (atom1 == -1 || atom2 == -1) {
+          char str[128];
+          sprintf(str,"Shake atoms " TAGINT_FORMAT " " TAGINT_FORMAT 
+                  " missing on proc %d at step " BIGINT_FORMAT,
+                  shake_atom[i][0],shake_atom[i][1],me,update->ntimestep);
+          error->one(FLERR,str);
+        }
+        if (i <= atom1 && i <= atom2) list[nlist++] = i;
+      } else if (shake_flag[i] % 2 == 1) {
+        atom1 = atom->map(shake_atom[i][0]);
+        atom2 = atom->map(shake_atom[i][1]);
+        atom3 = atom->map(shake_atom[i][2]);
+        if (atom1 == -1 || atom2 == -1 || atom3 == -1) {
+          char str[128];
+          sprintf(str,"Shake atoms " 
+                  TAGINT_FORMAT " " TAGINT_FORMAT " " TAGINT_FORMAT
+                  " missing on proc %d at step " BIGINT_FORMAT,
+                  shake_atom[i][0],shake_atom[i][1],shake_atom[i][2],
+                  me,update->ntimestep);
+          error->one(FLERR,str);
+        }
+        if (i <= atom1 && i <= atom2 && i <= atom3) list[nlist++] = i;
+      } else {
+        atom1 = atom->map(shake_atom[i][0]);
+        atom2 = atom->map(shake_atom[i][1]);
+        atom3 = atom->map(shake_atom[i][2]);
+        atom4 = atom->map(shake_atom[i][3]);
+        if (atom1 == -1 || atom2 == -1 || atom3 == -1 || atom4 == -1) {
+          char str[128];
+          sprintf(str,"Shake atoms " 
+                  TAGINT_FORMAT " " TAGINT_FORMAT " " 
+                  TAGINT_FORMAT " " TAGINT_FORMAT
+                  " missing on proc %d at step " BIGINT_FORMAT,
+                  shake_atom[i][0],shake_atom[i][1],
+                  shake_atom[i][2],shake_atom[i][3],
+                  me,update->ntimestep);
+          error->one(FLERR,str);
+        }
+        if (i <= atom1 && i <= atom2 && i <= atom3 && i <= atom4)
+          list[nlist++] = i;
+      }
+    }
+}
+
+/* ----------------------------------------------------------------------
+   compute the force adjustment for SHAKE constraint
+------------------------------------------------------------------------- */
+
+void FixShake::post_force(int vflag)
+{
+  if (update->ntimestep == next_output) stats();
+
+  // xshake = unconstrained move with current v,f
+  // communicate results if necessary
+
+  unconstrained_update();
+  if (nprocs > 1) comm->forward_comm_fix(this);
+
+  // virial setup
+
+  if (vflag) v_setup(vflag);
+  else evflag = 0;
+
+  // loop over clusters to add constraint forces
+
+  int m;
+  for (int i = 0; i < nlist; i++) {
+    m = list[i];
+    if (shake_flag[m] == 2) shake(m);
+    else if (shake_flag[m] == 3) shake3(m);
+    else if (shake_flag[m] == 4) shake4(m);
+    else shake3angle(m);
+  }
+  
+  // store vflag for coordinate_constraints_end_of_step()
+
+  vflag_post_force = vflag;
+}
+
+/* ----------------------------------------------------------------------
+   enforce SHAKE constraints from rRESPA
+   xshake prediction portion is different than Verlet
+------------------------------------------------------------------------- */
+
+void FixShake::post_force_respa(int vflag, int ilevel, int iloop)
+{
+  // call stats only on outermost level
+
+  if (ilevel == nlevels_respa-1 && update->ntimestep == next_output) stats();
+
+  // might be OK to skip enforcing SHAKE constraings
+  // on last iteration of inner levels if pressure not requested
+  // however, leads to slightly different trajectories
+
+  //if (ilevel < nlevels_respa-1 && iloop == loop_respa[ilevel]-1 && !vflag)
+  //  return;
+
+  // xshake = unconstrained move with current v,f as function of level
+  // communicate results if necessary
+
+  unconstrained_update_respa(ilevel);
+  if (nprocs > 1) comm->forward_comm_fix(this);
+
+  // virial setup only needed on last iteration of innermost level
+  //   and if pressure is requested
+  // virial accumulation happens via evflag at last iteration of each level
+
+  if (ilevel == 0 && iloop == loop_respa[ilevel]-1 && vflag) v_setup(vflag);
+  if (iloop == loop_respa[ilevel]-1) evflag = 1;
+  else evflag = 0;
+
+  // loop over clusters to add constraint forces
+
+  int m;
+  for (int i = 0; i < nlist; i++) {
+    m = list[i];
+    if (shake_flag[m] == 2) shake(m);
+    else if (shake_flag[m] == 3) shake3(m);
+    else if (shake_flag[m] == 4) shake4(m);
+    else shake3angle(m);
+  }
+
+  // store vflag for coordinate_constraints_end_of_step()
+  vflag_post_force = vflag;
+}
+
+/* ----------------------------------------------------------------------
+   count # of degrees-of-freedom removed by SHAKE for atoms in igroup
+------------------------------------------------------------------------- */
+
+int FixShake::dof(int igroup)
+{
+  int groupbit = group->bitmask[igroup];
+
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  int nlocal = atom->nlocal;
+
+  // count dof in a cluster if and only if
+  // the central atom is in group and atom i is the central atom
+
+  int n = 0;
+  for (int i = 0; i < nlocal; i++) {
+    if (!(mask[i] & groupbit)) continue;
+    if (shake_flag[i] == 0) continue;
+    if (shake_atom[i][0] != tag[i]) continue;
+    if (shake_flag[i] == 1) n += 3;
+    else if (shake_flag[i] == 2) n += 1;
+    else if (shake_flag[i] == 3) n += 2;
+    else if (shake_flag[i] == 4) n += 3;
+  }
+
+  int nall;
+  MPI_Allreduce(&n,&nall,1,MPI_INT,MPI_SUM,world);
+  return nall;
+}
+
+/* ----------------------------------------------------------------------
+   identify whether each atom is in a SHAKE cluster
+   only include atoms in fix group and those bonds/angles specified in input
+   test whether all clusters are valid
+   set shake_flag, shake_atom, shake_type values
+   set bond,angle types negative so will be ignored in neighbor lists
+------------------------------------------------------------------------- */
+
+void FixShake::find_clusters()
+{
+  int i,j,m,n,imol,iatom;
+  int flag,flag_all,nbuf,size;
+  tagint tagprev;
+  double massone;
+  tagint *buf;
+  
+  if (me == 0 && screen) {
+    if (!rattle) fprintf(screen,"Finding SHAKE clusters ...\n");
+    else fprintf(screen,"Finding RATTLE clusters ...\n");
+  }
+
+  atommols = atom->avec->onemols;
+
+  tagint *tag = atom->tag;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  double *mass = atom->mass;
+  double *rmass = atom->rmass;
+  int **nspecial = atom->nspecial;
+  tagint **special = atom->special;
+  
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+
+  int nlocal = atom->nlocal;
+  int angles_allow = atom->avec->angles_allow;
+
+  // setup ring of procs
+
+  int next = me + 1;
+  int prev = me -1;
+  if (next == nprocs) next = 0;
+  if (prev < 0) prev = nprocs - 1;
+
+  // -----------------------------------------------------
+  // allocate arrays for self (1d) and bond partners (2d)
+  // max = max # of bond partners for owned atoms = 2nd dim of partner arrays
+  // npartner[i] = # of bonds attached to atom i
+  // nshake[i] = # of SHAKE bonds attached to atom i
+  // partner_tag[i][] = global IDs of each partner
+  // partner_mask[i][] = mask of each partner
+  // partner_type[i][] = type of each partner
+  // partner_massflag[i][] = 1 if partner meets mass criterion, 0 if not
+  // partner_bondtype[i][] = type of bond attached to each partner
+  // partner_shake[i][] = 1 if SHAKE bonded to partner, 0 if not
+  // partner_nshake[i][] = nshake value for each partner
+  // -----------------------------------------------------
+
+  int max = 0;
+  if (molecular == 1) {
+    for (i = 0; i < nlocal; i++) max = MAX(max,nspecial[i][0]);
+  } else {
+    for (i = 0; i < nlocal; i++) {
+      imol = molindex[i];
+      if (imol < 0) continue;
+      iatom = molatom[i];
+      max = MAX(max,atommols[imol]->nspecial[iatom][0]);
+    }
+  }
+
+  int *npartner;
+  memory->create(npartner,nlocal,"shake:npartner");
+  memory->create(nshake,nlocal,"shake:nshake");
+
+  tagint **partner_tag;
+  int **partner_mask,**partner_type,**partner_massflag;
+  int **partner_bondtype,**partner_shake,**partner_nshake;
+  memory->create(partner_tag,nlocal,max,"shake:partner_tag");
+  memory->create(partner_mask,nlocal,max,"shake:partner_mask");
+  memory->create(partner_type,nlocal,max,"shake:partner_type");
+  memory->create(partner_massflag,nlocal,max,"shake:partner_massflag");
+  memory->create(partner_bondtype,nlocal,max,"shake:partner_bondtype");
+  memory->create(partner_shake,nlocal,max,"shake:partner_shake");
+  memory->create(partner_nshake,nlocal,max,"shake:partner_nshake");
+
+  // -----------------------------------------------------
+  // set npartner and partner_tag from special arrays
+  // -----------------------------------------------------
+
+  if (molecular == 1) {
+    for (i = 0; i < nlocal; i++) {
+      npartner[i] = nspecial[i][0];
+      for (j = 0; j < npartner[i]; j++)
+        partner_tag[i][j] = special[i][j];
+    }
+  } else {
+    for (i = 0; i < nlocal; i++) {
+      imol = molindex[i];
+      if (imol < 0) continue;
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+      npartner[i] = atommols[imol]->nspecial[iatom][0];
+      for (j = 0; j < npartner[i]; j++)
+        partner_tag[i][j] = atommols[imol]->special[iatom][j] + tagprev;;
+    }
+  }
+
+  // -----------------------------------------------------
+  // set partner_mask, partner_type, partner_massflag, partner_bondtype
+  //   for bonded partners
+  // requires communication for off-proc partners
+  // -----------------------------------------------------
+
+  // fill in mask, type, massflag, bondtype if own bond partner
+  // info to store in buf for each off-proc bond = nper = 6
+  //   2 atoms IDs in bond, space for mask, type, massflag, bondtype
+  // nbufmax = largest buffer needed to hold info from any proc
+
+  int nper = 6;
+
+  nbuf = 0;
+  for (i = 0; i < nlocal; i++) {
+    for (j = 0; j < npartner[i]; j++) {
+      partner_mask[i][j] = 0;
+      partner_type[i][j] = 0;
+      partner_massflag[i][j] = 0;
+      partner_bondtype[i][j] = 0;
+
+      m = atom->map(partner_tag[i][j]);
+      if (m >= 0 && m < nlocal) {
+        partner_mask[i][j] = mask[m];
+        partner_type[i][j] = type[m];
+        if (nmass) {
+          if (rmass) massone = rmass[m];
+          else massone = mass[type[m]];
+          partner_massflag[i][j] = masscheck(massone);
+        }
+        n = bondtype_findset(i,tag[i],partner_tag[i][j],0);
+        if (n) partner_bondtype[i][j] = n;
+        else {
+          n = bondtype_findset(m,tag[i],partner_tag[i][j],0);
+          if (n) partner_bondtype[i][j] = n;
+        }
+      } else nbuf += nper;
+    }
+  }
+
+  memory->create(buf,nbuf,"shake:buf");
+
+  // fill buffer with info
+
+  size = 0;
+  for (i = 0; i < nlocal; i++) {
+    for (j = 0; j < npartner[i]; j++) {
+      m = atom->map(partner_tag[i][j]);
+      if (m < 0 || m >= nlocal) {
+        buf[size] = tag[i];
+        buf[size+1] = partner_tag[i][j];
+        buf[size+2] = 0;
+        buf[size+3] = 0;
+        buf[size+4] = 0;
+        n = bondtype_findset(i,tag[i],partner_tag[i][j],0);
+        if (n) buf[size+5] = n;
+        else buf[size+5] = 0;
+        size += nper;
+      }
+    }
+  }
+
+  // cycle buffer around ring of procs back to self
+
+  comm->ring(size,sizeof(tagint),buf,1,ring_bonds,buf,(void *)this);
+
+  // store partner info returned to me
+
+  m = 0;
+  while (m < size) {
+    i = atom->map(buf[m]);
+    for (j = 0; j < npartner[i]; j++)
+      if (buf[m+1] == partner_tag[i][j]) break;
+    partner_mask[i][j] = buf[m+2];
+    partner_type[i][j] = buf[m+3];
+    partner_massflag[i][j] = buf[m+4];
+    partner_bondtype[i][j] = buf[m+5];
+    m += nper;
+  }
+
+  memory->destroy(buf);
+
+  // error check for unfilled partner info
+  // if partner_type not set, is an error
+  // partner_bondtype may not be set if special list is not consistent
+  //   with bondatom (e.g. due to delete_bonds command)
+  // this is OK if one or both atoms are not in fix group, since
+  //   bond won't be SHAKEn anyway
+  // else it's an error
+
+  flag = 0;
+  for (i = 0; i < nlocal; i++)
+    for (j = 0; j < npartner[i]; j++) {
+      if (partner_type[i][j] == 0) flag = 1;
+      if (!(mask[i] & groupbit)) continue;
+      if (!(partner_mask[i][j] & groupbit)) continue;
+      if (partner_bondtype[i][j] == 0) flag = 1;
+    }
+
+  MPI_Allreduce(&flag,&flag_all,1,MPI_INT,MPI_SUM,world);
+  if (flag_all) error->all(FLERR,"Did not find fix shake partner info");
+
+  // -----------------------------------------------------
+  // identify SHAKEable bonds
+  // set nshake[i] = # of SHAKE bonds attached to atom i
+  // set partner_shake[i][] = 1 if SHAKE bonded to partner, 0 if not
+  // both atoms must be in group, bondtype must be > 0
+  // check if bondtype is in input bond_flag
+  // check if type of either atom is in input type_flag
+  // check if mass of either atom is in input mass_list
+  // -----------------------------------------------------
+
+  int np;
+
+  for (i = 0; i < nlocal; i++) {
+    nshake[i] = 0;
+    np = npartner[i];
+    for (j = 0; j < np; j++) {
+      partner_shake[i][j] = 0;
+
+      if (!(mask[i] & groupbit)) continue;
+      if (!(partner_mask[i][j] & groupbit)) continue;
+      if (partner_bondtype[i][j] <= 0) continue;
+
+      if (bond_flag[partner_bondtype[i][j]]) {
+        partner_shake[i][j] = 1;
+        nshake[i]++;
+        continue;
+      }
+      if (type_flag[type[i]] || type_flag[partner_type[i][j]]) {
+        partner_shake[i][j] = 1;
+        nshake[i]++;
+        continue;
+      }
+      if (nmass) {
+        if (partner_massflag[i][j]) {
+          partner_shake[i][j] = 1;
+          nshake[i]++;
+          continue;
+        } else {
+          if (rmass) massone = rmass[i];
+          else massone = mass[type[i]];
+          if (masscheck(massone)) {
+            partner_shake[i][j] = 1;
+            nshake[i]++;
+            continue;
+          }
+        }
+      }
+    }
+  }
+
+  // -----------------------------------------------------
+  // set partner_nshake for bonded partners
+  // requires communication for off-proc partners
+  // -----------------------------------------------------
+
+  // fill in partner_nshake if own bond partner
+  // info to store in buf for each off-proc bond =
+  //   2 atoms IDs in bond, space for nshake value
+  // nbufmax = largest buffer needed to hold info from any proc
+
+  nbuf = 0;
+  for (i = 0; i < nlocal; i++) {
+    for (j = 0; j < npartner[i]; j++) {
+      m = atom->map(partner_tag[i][j]);
+      if (m >= 0 && m < nlocal) partner_nshake[i][j] = nshake[m];
+      else nbuf += 3;
+    }
+  }
+
+  memory->create(buf,nbuf,"shake:buf");
+
+  // fill buffer with info
+
+  size = 0;
+  for (i = 0; i < nlocal; i++) {
+    for (j = 0; j < npartner[i]; j++) {
+      m = atom->map(partner_tag[i][j]);
+      if (m < 0 || m >= nlocal) {
+        buf[size] = tag[i];
+        buf[size+1] = partner_tag[i][j];
+        size += 3;
+      }
+    }
+  }
+
+  // cycle buffer around ring of procs back to self
+
+  comm->ring(size,sizeof(tagint),buf,2,ring_nshake,buf,(void *)this);
+
+  // store partner info returned to me
+  
+  m = 0;
+  while (m < size) {
+    i = atom->map(buf[m]);
+    for (j = 0; j < npartner[i]; j++)
+      if (buf[m+1] == partner_tag[i][j]) break;
+    partner_nshake[i][j] = buf[m+2];
+    m += 3;
+  }
+
+  memory->destroy(buf);
+
+  // -----------------------------------------------------
+  // error checks
+  // no atom with nshake > 3
+  // no connected atoms which both have nshake > 1
+  // -----------------------------------------------------
+
+  flag = 0;
+  for (i = 0; i < nlocal; i++) if (nshake[i] > 3) flag = 1;
+  MPI_Allreduce(&flag,&flag_all,1,MPI_INT,MPI_SUM,world);
+  if (flag_all) error->all(FLERR,"Shake cluster of more than 4 atoms");
+
+  flag = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (nshake[i] <= 1) continue;
+    for (j = 0; j < npartner[i]; j++)
+      if (partner_shake[i][j] && partner_nshake[i][j] > 1) flag = 1;
+  }
+  MPI_Allreduce(&flag,&flag_all,1,MPI_INT,MPI_SUM,world);
+  if (flag_all) error->all(FLERR,"Shake clusters are connected");
+
+  // -----------------------------------------------------
+  // set SHAKE arrays that are stored with atoms & add angle constraints
+  // zero shake arrays for all owned atoms
+  // if I am central atom set shake_flag & shake_atom & shake_type
+  // for 2-atom clusters, I am central atom if my atom ID < partner ID
+  // for 3-atom clusters, test for angle constraint
+  //   angle will be stored by this atom if it exists
+  //   if angle type matches angle_flag, then it is angle-constrained
+  // shake_flag[] = 0 if atom not in SHAKE cluster
+  //                2,3,4 = size of bond-only cluster
+  //                1 = 3-atom angle cluster
+  // shake_atom[][] = global IDs of 2,3,4 atoms in cluster
+  //                  central atom is 1st
+  //                  for 2-atom cluster, lowest ID is 1st
+  // shake_type[][] = bondtype of each bond in cluster
+  //                  for 3-atom angle cluster, 3rd value is angletype
+  // -----------------------------------------------------
+
+  for (i = 0; i < nlocal; i++) {
+    shake_flag[i] = 0;
+    shake_atom[i][0] = 0;
+    shake_atom[i][1] = 0;
+    shake_atom[i][2] = 0;
+    shake_atom[i][3] = 0;
+    shake_type[i][0] = 0;
+    shake_type[i][1] = 0;
+    shake_type[i][2] = 0;
+
+    if (nshake[i] == 1) {
+      for (j = 0; j < npartner[i]; j++)
+        if (partner_shake[i][j]) break;
+      if (partner_nshake[i][j] == 1 && tag[i] < partner_tag[i][j]) {
+        shake_flag[i] = 2;
+        shake_atom[i][0] = tag[i];
+        shake_atom[i][1] = partner_tag[i][j];
+        shake_type[i][0] = partner_bondtype[i][j];
+      }
+    }
+
+    if (nshake[i] > 1) {
+      shake_flag[i] = 1;
+      shake_atom[i][0] = tag[i];
+      for (j = 0; j < npartner[i]; j++)
+        if (partner_shake[i][j]) {
+          m = shake_flag[i];
+          shake_atom[i][m] = partner_tag[i][j];
+          shake_type[i][m-1] = partner_bondtype[i][j];
+          shake_flag[i]++;
+        }
+    }
+
+    if (nshake[i] == 2 && angles_allow) {
+      n = angletype_findset(i,shake_atom[i][1],shake_atom[i][2],0);
+      if (n <= 0) continue;
+      if (angle_flag[n]) {
+        shake_flag[i] = 1;
+        shake_type[i][2] = n;
+      }
+    }
+  }
+
+  // -----------------------------------------------------
+  // set shake_flag,shake_atom,shake_type for non-central atoms
+  // requires communication for off-proc atoms
+  // -----------------------------------------------------
+
+  // fill in shake arrays for each bond partner I own
+  // info to store in buf for each off-proc bond =
+  //   all values from shake_flag, shake_atom, shake_type
+  // nbufmax = largest buffer needed to hold info from any proc
+
+  nbuf = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (shake_flag[i] == 0) continue;
+    for (j = 0; j < npartner[i]; j++) {
+      if (partner_shake[i][j] == 0) continue;
+      m = atom->map(partner_tag[i][j]);
+      if (m >= 0 && m < nlocal) {
+        shake_flag[m] = shake_flag[i];
+        shake_atom[m][0] = shake_atom[i][0];
+        shake_atom[m][1] = shake_atom[i][1];
+        shake_atom[m][2] = shake_atom[i][2];
+        shake_atom[m][3] = shake_atom[i][3];
+        shake_type[m][0] = shake_type[i][0];
+        shake_type[m][1] = shake_type[i][1];
+        shake_type[m][2] = shake_type[i][2];
+      } else nbuf += 9;
+    }
+  }
+
+  memory->create(buf,nbuf,"shake:buf");
+
+  // fill buffer with info
+
+  size = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (shake_flag[i] == 0) continue;
+    for (j = 0; j < npartner[i]; j++) {
+      if (partner_shake[i][j] == 0) continue;
+      m = atom->map(partner_tag[i][j]);
+      if (m < 0 || m >= nlocal) {
+        buf[size] = partner_tag[i][j];
+        buf[size+1] = shake_flag[i];
+        buf[size+2] = shake_atom[i][0];
+        buf[size+3] = shake_atom[i][1];
+        buf[size+4] = shake_atom[i][2];
+        buf[size+5] = shake_atom[i][3];
+        buf[size+6] = shake_type[i][0];
+        buf[size+7] = shake_type[i][1];
+        buf[size+8] = shake_type[i][2];
+        size += 9;
+      }
+    }
+  }
+
+  // cycle buffer around ring of procs back to self
+
+  comm->ring(size,sizeof(tagint),buf,3,ring_shake,NULL,(void *)this);
+
+  memory->destroy(buf);
+
+  // -----------------------------------------------------
+  // free local memory
+  // -----------------------------------------------------
+
+  memory->destroy(npartner);
+  memory->destroy(nshake);
+  memory->destroy(partner_tag);
+  memory->destroy(partner_mask);
+  memory->destroy(partner_type);
+  memory->destroy(partner_massflag);
+  memory->destroy(partner_bondtype);
+  memory->destroy(partner_shake);
+  memory->destroy(partner_nshake);
+
+  // -----------------------------------------------------
+  // set bond_type and angle_type negative for SHAKE clusters
+  // must set for all SHAKE bonds and angles stored by each atom
+  // -----------------------------------------------------
+
+  for (i = 0; i < nlocal; i++) {
+    if (shake_flag[i] == 0) continue;
+    else if (shake_flag[i] == 1) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],-1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][2],-1);
+      angletype_findset(i,shake_atom[i][1],shake_atom[i][2],-1);
+    } else if (shake_flag[i] == 2) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],-1);
+    } else if (shake_flag[i] == 3) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],-1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][2],-1);
+    } else if (shake_flag[i] == 4) {
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][1],-1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][2],-1);
+      bondtype_findset(i,shake_atom[i][0],shake_atom[i][3],-1);
+    }
+  }
+
+  // -----------------------------------------------------
+  // print info on SHAKE clusters
+  // -----------------------------------------------------
+
+  int count1,count2,count3,count4;
+  count1 = count2 = count3 = count4 = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (shake_flag[i] == 1) count1++;
+    else if (shake_flag[i] == 2) count2++;
+    else if (shake_flag[i] == 3) count3++;
+    else if (shake_flag[i] == 4) count4++;
+  }
+
+  int tmp;
+  tmp = count1;
+  MPI_Allreduce(&tmp,&count1,1,MPI_INT,MPI_SUM,world);
+  tmp = count2;
+  MPI_Allreduce(&tmp,&count2,1,MPI_INT,MPI_SUM,world);
+  tmp = count3;
+  MPI_Allreduce(&tmp,&count3,1,MPI_INT,MPI_SUM,world);
+  tmp = count4;
+  MPI_Allreduce(&tmp,&count4,1,MPI_INT,MPI_SUM,world);
+
+  if (me == 0) {
+    if (screen) {
+      fprintf(screen,"  %d = # of size 2 clusters\n",count2/2);
+      fprintf(screen,"  %d = # of size 3 clusters\n",count3/3);
+      fprintf(screen,"  %d = # of size 4 clusters\n",count4/4);
+      fprintf(screen,"  %d = # of frozen angles\n",count1/3);
+    }
+    if (logfile) {
+      fprintf(logfile,"  %d = # of size 2 clusters\n",count2/2);
+      fprintf(logfile,"  %d = # of size 3 clusters\n",count3/3);
+      fprintf(logfile,"  %d = # of size 4 clusters\n",count4/4);
+      fprintf(logfile,"  %d = # of frozen angles\n",count1/3);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   when receive buffer, scan bond partner IDs for atoms I own
+   if I own partner:
+     fill in mask and type and massflag
+     search for bond with 1st atom and fill in bondtype
+------------------------------------------------------------------------- */
+
+void FixShake::ring_bonds(int ndatum, char *cbuf, void *ptr)
+{
+  FixShake *fsptr = (FixShake *)ptr;
+  Atom *atom = fsptr->atom;
+  double *rmass = atom->rmass;
+  double *mass = atom->mass;
+  int *mask = atom->mask;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  int nmass = fsptr->nmass;
+
+  tagint *buf = (tagint *) cbuf;
+  int m,n;
+  double massone;
+
+  for (int i = 0; i < ndatum; i += 6) {
+    m = atom->map(buf[i+1]);
+    if (m >= 0 && m < nlocal) {
+      buf[i+2] = mask[m];
+      buf[i+3] = type[m];
+      if (nmass) {
+        if (rmass) massone = rmass[m];
+        else massone = mass[type[m]];
+        buf[i+4] = fsptr->masscheck(massone);
+      }
+      if (buf[i+5] == 0) {
+        n = fsptr->bondtype_findset(m,buf[i],buf[i+1],0);
+        if (n) buf[i+5] = n;
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   when receive buffer, scan bond partner IDs for atoms I own
+   if I own partner, fill in nshake value
+------------------------------------------------------------------------- */
+
+void FixShake::ring_nshake(int ndatum, char *cbuf, void *ptr)
+{
+  FixShake *fsptr = (FixShake *)ptr;
+  Atom *atom = fsptr->atom;
+  int nlocal = atom->nlocal;
+
+  int *nshake = fsptr->nshake;
+
+  tagint *buf = (tagint *) cbuf;
+  int m;
+
+  for (int i = 0; i < ndatum; i += 3) {
+    m = atom->map(buf[i+1]);
+    if (m >= 0 && m < nlocal) buf[i+2] = nshake[m];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   when receive buffer, scan bond partner IDs for atoms I own
+   if I own partner, fill in nshake value
+------------------------------------------------------------------------- */
+
+void FixShake::ring_shake(int ndatum, char *cbuf, void *ptr)
+{
+  FixShake *fsptr = (FixShake *)ptr;
+  Atom *atom = fsptr->atom;
+  int nlocal = atom->nlocal;
+
+  int *shake_flag = fsptr->shake_flag;
+  tagint **shake_atom = fsptr->shake_atom;
+  int **shake_type = fsptr->shake_type;
+
+  tagint *buf = (tagint *) cbuf;
+  int m;
+
+  for (int i = 0; i < ndatum; i += 9) {
+    m = atom->map(buf[i]);
+    if (m >= 0 && m < nlocal) {
+      shake_flag[m] = buf[i+1];
+      shake_atom[m][0] = buf[i+2];
+      shake_atom[m][1] = buf[i+3];
+      shake_atom[m][2] = buf[i+4];
+      shake_atom[m][3] = buf[i+5];
+      shake_type[m][0] = buf[i+6];
+      shake_type[m][1] = buf[i+7];
+      shake_type[m][2] = buf[i+8];
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   check if massone is within MASSDELTA of any mass in mass_list
+   return 1 if yes, 0 if not
+------------------------------------------------------------------------- */
+
+int FixShake::masscheck(double massone)
+{
+  for (int i = 0; i < nmass; i++)
+    if (fabs(mass_list[i]-massone) <= MASSDELTA) return 1;
+  return 0;
+}
+
+/* ----------------------------------------------------------------------
+   update the unconstrained position of each atom
+   only for SHAKE clusters, else set to 0.0
+   assumes NVE update, seems to be accurate enough for NVT,NPT,NPH as well
+------------------------------------------------------------------------- */
+
+void FixShake::unconstrained_update()
+{
+  double dtfmsq;
+
+  if (rmass) {
+    for (int i = 0; i < nlocal; i++) {
+      if (shake_flag[i]) {
+        dtfmsq = dtfsq / rmass[i];
+        xshake[i][0] = x[i][0] + dtv*v[i][0] + dtfmsq*f[i][0];
+        xshake[i][1] = x[i][1] + dtv*v[i][1] + dtfmsq*f[i][1];
+        xshake[i][2] = x[i][2] + dtv*v[i][2] + dtfmsq*f[i][2];
+      } else xshake[i][2] = xshake[i][1] = xshake[i][0] = 0.0;
+    }
+  } else {
+    for (int i = 0; i < nlocal; i++) {
+      if (shake_flag[i]) {
+        dtfmsq = dtfsq / mass[type[i]];
+        xshake[i][0] = x[i][0] + dtv*v[i][0] + dtfmsq*f[i][0];
+        xshake[i][1] = x[i][1] + dtv*v[i][1] + dtfmsq*f[i][1];
+        xshake[i][2] = x[i][2] + dtv*v[i][2] + dtfmsq*f[i][2];
+      } else xshake[i][2] = xshake[i][1] = xshake[i][0] = 0.0;
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   update the unconstrained position of each atom in a rRESPA step
+   only for SHAKE clusters, else set to 0.0
+   assumes NVE update, seems to be accurate enough for NVT,NPT,NPH as well
+------------------------------------------------------------------------- */
+
+void FixShake::unconstrained_update_respa(int ilevel)
+{
+  // xshake = atom coords after next x update in innermost loop
+  // depends on rRESPA level
+  // for levels > 0 this includes more than one velocity update
+  // xshake = predicted position from call to this routine at level N =
+  // x + dt0 (v + dtN/m fN + 1/2 dt(N-1)/m f(N-1) + ... + 1/2 dt0/m f0)
+  // also set dtfsq = dt0*dtN so that shake,shake3,etc can use it
+
+  double ***f_level = ((FixRespa *) modify->fix[ifix_respa])->f_level;
+  dtfsq = dtf_inner * step_respa[ilevel];
+
+  double invmass,dtfmsq;
+  int jlevel;
+
+  if (rmass) {
+    for (int i = 0; i < nlocal; i++) {
+      if (shake_flag[i]) {
+        invmass = 1.0 / rmass[i];
+        dtfmsq = dtfsq * invmass;
+        xshake[i][0] = x[i][0] + dtv*v[i][0] + dtfmsq*f[i][0];
+        xshake[i][1] = x[i][1] + dtv*v[i][1] + dtfmsq*f[i][1];
+        xshake[i][2] = x[i][2] + dtv*v[i][2] + dtfmsq*f[i][2];
+        for (jlevel = 0; jlevel < ilevel; jlevel++) {
+          dtfmsq = dtf_innerhalf * step_respa[jlevel] * invmass;
+          xshake[i][0] += dtfmsq*f_level[i][jlevel][0];
+          xshake[i][1] += dtfmsq*f_level[i][jlevel][1];
+          xshake[i][2] += dtfmsq*f_level[i][jlevel][2];
+        }
+      } else xshake[i][2] = xshake[i][1] = xshake[i][0] = 0.0;
+    }
+
+  } else {
+    for (int i = 0; i < nlocal; i++) {
+      if (shake_flag[i]) {
+        invmass = 1.0 / mass[type[i]];
+        dtfmsq = dtfsq * invmass;
+        xshake[i][0] = x[i][0] + dtv*v[i][0] + dtfmsq*f[i][0];
+        xshake[i][1] = x[i][1] + dtv*v[i][1] + dtfmsq*f[i][1];
+        xshake[i][2] = x[i][2] + dtv*v[i][2] + dtfmsq*f[i][2];
+        for (jlevel = 0; jlevel < ilevel; jlevel++) {
+          dtfmsq = dtf_innerhalf * step_respa[jlevel] * invmass;
+          xshake[i][0] += dtfmsq*f_level[i][jlevel][0];
+          xshake[i][1] += dtfmsq*f_level[i][jlevel][1];
+          xshake[i][2] += dtfmsq*f_level[i][jlevel][2];
+        }
+      } else xshake[i][2] = xshake[i][1] = xshake[i][0] = 0.0;
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixShake::shake(int m)
+{
+  int nlist,list[2];
+  double v[6];
+  double invmass0,invmass1;
+
+  // local atom IDs and constraint distances
+
+  int i0 = atom->map(shake_atom[m][0]);
+  int i1 = atom->map(shake_atom[m][1]);
+  double bond1 = bond_distance[shake_type[m][0]];
+
+  // r01 = distance vec between atoms, with PBC
+
+  double r01[3];
+  r01[0] = x[i0][0] - x[i1][0];
+  r01[1] = x[i0][1] - x[i1][1];
+  r01[2] = x[i0][2] - x[i1][2];
+  domain->minimum_image(r01);
+
+  // s01 = distance vec after unconstrained update, with PBC
+  // use Domain::minimum_image_once(), not minimum_image()
+  // b/c xshake values might be huge, due to e.g. fix gcmc
+
+  double s01[3];
+  s01[0] = xshake[i0][0] - xshake[i1][0];
+  s01[1] = xshake[i0][1] - xshake[i1][1];
+  s01[2] = xshake[i0][2] - xshake[i1][2];
+  domain->minimum_image_once(s01);
+
+  // scalar distances between atoms
+
+  double r01sq = r01[0]*r01[0] + r01[1]*r01[1] + r01[2]*r01[2];
+  double s01sq = s01[0]*s01[0] + s01[1]*s01[1] + s01[2]*s01[2];
+
+  // a,b,c = coeffs in quadratic equation for lamda
+
+  if (rmass) {
+    invmass0 = 1.0/rmass[i0];
+    invmass1 = 1.0/rmass[i1];
+  } else {
+    invmass0 = 1.0/mass[type[i0]];
+    invmass1 = 1.0/mass[type[i1]];
+  }
+
+  double a = (invmass0+invmass1)*(invmass0+invmass1) * r01sq;
+  double b = 2.0 * (invmass0+invmass1) *
+    (s01[0]*r01[0] + s01[1]*r01[1] + s01[2]*r01[2]);
+  double c = s01sq - bond1*bond1;
+
+  // error check
+
+  double determ = b*b - 4.0*a*c;
+  if (determ < 0.0) {
+    error->warning(FLERR,"Shake determinant < 0.0",0);
+    determ = 0.0;
+  }
+
+  // exact quadratic solution for lamda
+
+  double lamda,lamda1,lamda2;
+  lamda1 = (-b+sqrt(determ)) / (2.0*a);
+  lamda2 = (-b-sqrt(determ)) / (2.0*a);
+
+  if (fabs(lamda1) <= fabs(lamda2)) lamda = lamda1;
+  else lamda = lamda2;
+
+  // update forces if atom is owned by this processor
+
+  lamda /= dtfsq;
+
+  if (i0 < nlocal) {
+    f[i0][0] += lamda*r01[0];
+    f[i0][1] += lamda*r01[1];
+    f[i0][2] += lamda*r01[2];
+  }
+
+  if (i1 < nlocal) {
+    f[i1][0] -= lamda*r01[0];
+    f[i1][1] -= lamda*r01[1];
+    f[i1][2] -= lamda*r01[2];
+  }
+
+  if (evflag) {
+    nlist = 0;
+    if (i0 < nlocal) list[nlist++] = i0;
+    if (i1 < nlocal) list[nlist++] = i1;
+
+    v[0] = lamda*r01[0]*r01[0];
+    v[1] = lamda*r01[1]*r01[1];
+    v[2] = lamda*r01[2]*r01[2];
+    v[3] = lamda*r01[0]*r01[1];
+    v[4] = lamda*r01[0]*r01[2];
+    v[5] = lamda*r01[1]*r01[2];
+
+    v_tally(nlist,list,2.0,v);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixShake::shake3(int m)
+{
+  int nlist,list[3];
+  double v[6];
+  double invmass0,invmass1,invmass2;
+
+  // local atom IDs and constraint distances
+
+  int i0 = atom->map(shake_atom[m][0]);
+  int i1 = atom->map(shake_atom[m][1]);
+  int i2 = atom->map(shake_atom[m][2]);
+  double bond1 = bond_distance[shake_type[m][0]];
+  double bond2 = bond_distance[shake_type[m][1]];
+
+  // r01,r02 = distance vec between atoms, with PBC
+
+  double r01[3];
+  r01[0] = x[i0][0] - x[i1][0];
+  r01[1] = x[i0][1] - x[i1][1];
+  r01[2] = x[i0][2] - x[i1][2];
+  domain->minimum_image(r01);
+
+  double r02[3];
+  r02[0] = x[i0][0] - x[i2][0];
+  r02[1] = x[i0][1] - x[i2][1];
+  r02[2] = x[i0][2] - x[i2][2];
+  domain->minimum_image(r02);
+
+  // s01,s02 = distance vec after unconstrained update, with PBC
+  // use Domain::minimum_image_once(), not minimum_image()
+  // b/c xshake values might be huge, due to e.g. fix gcmc
+
+  double s01[3];
+  s01[0] = xshake[i0][0] - xshake[i1][0];
+  s01[1] = xshake[i0][1] - xshake[i1][1];
+  s01[2] = xshake[i0][2] - xshake[i1][2];
+  domain->minimum_image_once(s01);
+
+  double s02[3];
+  s02[0] = xshake[i0][0] - xshake[i2][0];
+  s02[1] = xshake[i0][1] - xshake[i2][1];
+  s02[2] = xshake[i0][2] - xshake[i2][2];
+  domain->minimum_image_once(s02);
+
+  // scalar distances between atoms
+
+  double r01sq = r01[0]*r01[0] + r01[1]*r01[1] + r01[2]*r01[2];
+  double r02sq = r02[0]*r02[0] + r02[1]*r02[1] + r02[2]*r02[2];
+  double s01sq = s01[0]*s01[0] + s01[1]*s01[1] + s01[2]*s01[2];
+  double s02sq = s02[0]*s02[0] + s02[1]*s02[1] + s02[2]*s02[2];
+
+  // matrix coeffs and rhs for lamda equations
+
+  if (rmass) {
+    invmass0 = 1.0/rmass[i0];
+    invmass1 = 1.0/rmass[i1];
+    invmass2 = 1.0/rmass[i2];
+  } else {
+    invmass0 = 1.0/mass[type[i0]];
+    invmass1 = 1.0/mass[type[i1]];
+    invmass2 = 1.0/mass[type[i2]];
+  }
+
+  double a11 = 2.0 * (invmass0+invmass1) *
+    (s01[0]*r01[0] + s01[1]*r01[1] + s01[2]*r01[2]);
+  double a12 = 2.0 * invmass0 *
+    (s01[0]*r02[0] + s01[1]*r02[1] + s01[2]*r02[2]);
+  double a21 = 2.0 * invmass0 *
+    (s02[0]*r01[0] + s02[1]*r01[1] + s02[2]*r01[2]);
+  double a22 = 2.0 * (invmass0+invmass2) *
+    (s02[0]*r02[0] + s02[1]*r02[1] + s02[2]*r02[2]);
+
+  // inverse of matrix
+
+  double determ = a11*a22 - a12*a21;
+  if (determ == 0.0) error->one(FLERR,"Shake determinant = 0.0");
+  double determinv = 1.0/determ;
+
+  double a11inv = a22*determinv;
+  double a12inv = -a12*determinv;
+  double a21inv = -a21*determinv;
+  double a22inv = a11*determinv;
+
+  // quadratic correction coeffs
+
+  double r0102 = (r01[0]*r02[0] + r01[1]*r02[1] + r01[2]*r02[2]);
+
+  double quad1_0101 = (invmass0+invmass1)*(invmass0+invmass1) * r01sq;
+  double quad1_0202 = invmass0*invmass0 * r02sq;
+  double quad1_0102 = 2.0 * (invmass0+invmass1)*invmass0 * r0102;
+
+  double quad2_0202 = (invmass0+invmass2)*(invmass0+invmass2) * r02sq;
+  double quad2_0101 = invmass0*invmass0 * r01sq;
+  double quad2_0102 = 2.0 * (invmass0+invmass2)*invmass0 * r0102;
+
+  // iterate until converged
+
+  double lamda01 = 0.0;
+  double lamda02 = 0.0;
+  int niter = 0;
+  int done = 0;
+
+  double quad1,quad2,b1,b2,lamda01_new,lamda02_new;
+
+  while (!done && niter < max_iter) {
+    quad1 = quad1_0101 * lamda01*lamda01 + quad1_0202 * lamda02*lamda02 +
+      quad1_0102 * lamda01*lamda02;
+    quad2 = quad2_0101 * lamda01*lamda01 + quad2_0202 * lamda02*lamda02 +
+      quad2_0102 * lamda01*lamda02;
+
+    b1 = bond1*bond1 - s01sq - quad1;
+    b2 = bond2*bond2 - s02sq - quad2;
+
+    lamda01_new = a11inv*b1 + a12inv*b2;
+    lamda02_new = a21inv*b1 + a22inv*b2;
+
+    done = 1;
+    if (fabs(lamda01_new-lamda01) > tolerance) done = 0;
+    if (fabs(lamda02_new-lamda02) > tolerance) done = 0;
+
+    lamda01 = lamda01_new;
+    lamda02 = lamda02_new;
+
+    // stop iterations before we have a floating point overflow
+    // max double is < 1.0e308, so 1e150 is a reasonable cutoff
+
+    if (fabs(lamda01) > 1e150 || fabs(lamda02) > 1e150) done = 1;
+
+    niter++;
+  }
+
+  // update forces if atom is owned by this processor
+
+  lamda01 = lamda01/dtfsq;
+  lamda02 = lamda02/dtfsq;
+
+  if (i0 < nlocal) {
+    f[i0][0] += lamda01*r01[0] + lamda02*r02[0];
+    f[i0][1] += lamda01*r01[1] + lamda02*r02[1];
+    f[i0][2] += lamda01*r01[2] + lamda02*r02[2];
+  }
+
+  if (i1 < nlocal) {
+    f[i1][0] -= lamda01*r01[0];
+    f[i1][1] -= lamda01*r01[1];
+    f[i1][2] -= lamda01*r01[2];
+  }
+
+  if (i2 < nlocal) {
+    f[i2][0] -= lamda02*r02[0];
+    f[i2][1] -= lamda02*r02[1];
+    f[i2][2] -= lamda02*r02[2];
+  }
+
+  if (evflag) {
+    nlist = 0;
+    if (i0 < nlocal) list[nlist++] = i0;
+    if (i1 < nlocal) list[nlist++] = i1;
+    if (i2 < nlocal) list[nlist++] = i2;
+
+    v[0] = lamda01*r01[0]*r01[0] + lamda02*r02[0]*r02[0];
+    v[1] = lamda01*r01[1]*r01[1] + lamda02*r02[1]*r02[1];
+    v[2] = lamda01*r01[2]*r01[2] + lamda02*r02[2]*r02[2];
+    v[3] = lamda01*r01[0]*r01[1] + lamda02*r02[0]*r02[1];
+    v[4] = lamda01*r01[0]*r01[2] + lamda02*r02[0]*r02[2];
+    v[5] = lamda01*r01[1]*r01[2] + lamda02*r02[1]*r02[2];
+
+    v_tally(nlist,list,3.0,v);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixShake::shake4(int m)
+{
+ int nlist,list[4];
+  double v[6];
+  double invmass0,invmass1,invmass2,invmass3;
+
+  // local atom IDs and constraint distances
+
+  int i0 = atom->map(shake_atom[m][0]);
+  int i1 = atom->map(shake_atom[m][1]);
+  int i2 = atom->map(shake_atom[m][2]);
+  int i3 = atom->map(shake_atom[m][3]);
+  double bond1 = bond_distance[shake_type[m][0]];
+  double bond2 = bond_distance[shake_type[m][1]];
+  double bond3 = bond_distance[shake_type[m][2]];
+
+  // r01,r02,r03 = distance vec between atoms, with PBC
+
+  double r01[3];
+  r01[0] = x[i0][0] - x[i1][0];
+  r01[1] = x[i0][1] - x[i1][1];
+  r01[2] = x[i0][2] - x[i1][2];
+  domain->minimum_image(r01);
+
+  double r02[3];
+  r02[0] = x[i0][0] - x[i2][0];
+  r02[1] = x[i0][1] - x[i2][1];
+  r02[2] = x[i0][2] - x[i2][2];
+  domain->minimum_image(r02);
+
+  double r03[3];
+  r03[0] = x[i0][0] - x[i3][0];
+  r03[1] = x[i0][1] - x[i3][1];
+  r03[2] = x[i0][2] - x[i3][2];
+  domain->minimum_image(r03);
+
+  // s01,s02,s03 = distance vec after unconstrained update, with PBC
+  // use Domain::minimum_image_once(), not minimum_image()
+  // b/c xshake values might be huge, due to e.g. fix gcmc
+
+  double s01[3];
+  s01[0] = xshake[i0][0] - xshake[i1][0];
+  s01[1] = xshake[i0][1] - xshake[i1][1];
+  s01[2] = xshake[i0][2] - xshake[i1][2];
+  domain->minimum_image_once(s01);
+
+  double s02[3];
+  s02[0] = xshake[i0][0] - xshake[i2][0];
+  s02[1] = xshake[i0][1] - xshake[i2][1];
+  s02[2] = xshake[i0][2] - xshake[i2][2];
+  domain->minimum_image_once(s02);
+
+  double s03[3];
+  s03[0] = xshake[i0][0] - xshake[i3][0];
+  s03[1] = xshake[i0][1] - xshake[i3][1];
+  s03[2] = xshake[i0][2] - xshake[i3][2];
+  domain->minimum_image_once(s03);
+
+  // scalar distances between atoms
+
+  double r01sq = r01[0]*r01[0] + r01[1]*r01[1] + r01[2]*r01[2];
+  double r02sq = r02[0]*r02[0] + r02[1]*r02[1] + r02[2]*r02[2];
+  double r03sq = r03[0]*r03[0] + r03[1]*r03[1] + r03[2]*r03[2];
+  double s01sq = s01[0]*s01[0] + s01[1]*s01[1] + s01[2]*s01[2];
+  double s02sq = s02[0]*s02[0] + s02[1]*s02[1] + s02[2]*s02[2];
+  double s03sq = s03[0]*s03[0] + s03[1]*s03[1] + s03[2]*s03[2];
+
+  // matrix coeffs and rhs for lamda equations
+
+  if (rmass) {
+    invmass0 = 1.0/rmass[i0];
+    invmass1 = 1.0/rmass[i1];
+    invmass2 = 1.0/rmass[i2];
+    invmass3 = 1.0/rmass[i3];
+  } else {
+    invmass0 = 1.0/mass[type[i0]];
+    invmass1 = 1.0/mass[type[i1]];
+    invmass2 = 1.0/mass[type[i2]];
+    invmass3 = 1.0/mass[type[i3]];
+  }
+
+  double a11 = 2.0 * (invmass0+invmass1) *
+    (s01[0]*r01[0] + s01[1]*r01[1] + s01[2]*r01[2]);
+  double a12 = 2.0 * invmass0 *
+    (s01[0]*r02[0] + s01[1]*r02[1] + s01[2]*r02[2]);
+  double a13 = 2.0 * invmass0 *
+    (s01[0]*r03[0] + s01[1]*r03[1] + s01[2]*r03[2]);
+  double a21 = 2.0 * invmass0 *
+    (s02[0]*r01[0] + s02[1]*r01[1] + s02[2]*r01[2]);
+  double a22 = 2.0 * (invmass0+invmass2) *
+    (s02[0]*r02[0] + s02[1]*r02[1] + s02[2]*r02[2]);
+  double a23 = 2.0 * invmass0 *
+    (s02[0]*r03[0] + s02[1]*r03[1] + s02[2]*r03[2]);
+  double a31 = 2.0 * invmass0 *
+    (s03[0]*r01[0] + s03[1]*r01[1] + s03[2]*r01[2]);
+  double a32 = 2.0 * invmass0 *
+    (s03[0]*r02[0] + s03[1]*r02[1] + s03[2]*r02[2]);
+  double a33 = 2.0 * (invmass0+invmass3) *
+    (s03[0]*r03[0] + s03[1]*r03[1] + s03[2]*r03[2]);
+
+  // inverse of matrix;
+
+  double determ = a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
+    a11*a23*a32 - a12*a21*a33 - a13*a22*a31;
+  if (determ == 0.0) error->one(FLERR,"Shake determinant = 0.0");
+  double determinv = 1.0/determ;
+
+  double a11inv = determinv * (a22*a33 - a23*a32);
+  double a12inv = -determinv * (a12*a33 - a13*a32);
+  double a13inv = determinv * (a12*a23 - a13*a22);
+  double a21inv = -determinv * (a21*a33 - a23*a31);
+  double a22inv = determinv * (a11*a33 - a13*a31);
+  double a23inv = -determinv * (a11*a23 - a13*a21);
+  double a31inv = determinv * (a21*a32 - a22*a31);
+  double a32inv = -determinv * (a11*a32 - a12*a31);
+  double a33inv = determinv * (a11*a22 - a12*a21);
+
+  // quadratic correction coeffs
+
+  double r0102 = (r01[0]*r02[0] + r01[1]*r02[1] + r01[2]*r02[2]);
+  double r0103 = (r01[0]*r03[0] + r01[1]*r03[1] + r01[2]*r03[2]);
+  double r0203 = (r02[0]*r03[0] + r02[1]*r03[1] + r02[2]*r03[2]);
+
+  double quad1_0101 = (invmass0+invmass1)*(invmass0+invmass1) * r01sq;
+  double quad1_0202 = invmass0*invmass0 * r02sq;
+  double quad1_0303 = invmass0*invmass0 * r03sq;
+  double quad1_0102 = 2.0 * (invmass0+invmass1)*invmass0 * r0102;
+  double quad1_0103 = 2.0 * (invmass0+invmass1)*invmass0 * r0103;
+  double quad1_0203 = 2.0 * invmass0*invmass0 * r0203;
+
+  double quad2_0101 = invmass0*invmass0 * r01sq;
+  double quad2_0202 = (invmass0+invmass2)*(invmass0+invmass2) * r02sq;
+  double quad2_0303 = invmass0*invmass0 * r03sq;
+  double quad2_0102 = 2.0 * (invmass0+invmass2)*invmass0 * r0102;
+  double quad2_0103 = 2.0 * invmass0*invmass0 * r0103;
+  double quad2_0203 = 2.0 * (invmass0+invmass2)*invmass0 * r0203;
+
+  double quad3_0101 = invmass0*invmass0 * r01sq;
+  double quad3_0202 = invmass0*invmass0 * r02sq;
+  double quad3_0303 = (invmass0+invmass3)*(invmass0+invmass3) * r03sq;
+  double quad3_0102 = 2.0 * invmass0*invmass0 * r0102;
+  double quad3_0103 = 2.0 * (invmass0+invmass3)*invmass0 * r0103;
+  double quad3_0203 = 2.0 * (invmass0+invmass3)*invmass0 * r0203;
+
+  // iterate until converged
+
+  double lamda01 = 0.0;
+  double lamda02 = 0.0;
+  double lamda03 = 0.0;
+  int niter = 0;
+  int done = 0;
+
+  double quad1,quad2,quad3,b1,b2,b3,lamda01_new,lamda02_new,lamda03_new;
+
+  while (!done && niter < max_iter) {
+    quad1 = quad1_0101 * lamda01*lamda01 +
+      quad1_0202 * lamda02*lamda02 +
+      quad1_0303 * lamda03*lamda03 +
+      quad1_0102 * lamda01*lamda02 +
+      quad1_0103 * lamda01*lamda03 +
+      quad1_0203 * lamda02*lamda03;
+
+    quad2 = quad2_0101 * lamda01*lamda01 +
+      quad2_0202 * lamda02*lamda02 +
+      quad2_0303 * lamda03*lamda03 +
+      quad2_0102 * lamda01*lamda02 +
+      quad2_0103 * lamda01*lamda03 +
+      quad2_0203 * lamda02*lamda03;
+
+    quad3 = quad3_0101 * lamda01*lamda01 +
+      quad3_0202 * lamda02*lamda02 +
+      quad3_0303 * lamda03*lamda03 +
+      quad3_0102 * lamda01*lamda02 +
+      quad3_0103 * lamda01*lamda03 +
+      quad3_0203 * lamda02*lamda03;
+
+    b1 = bond1*bond1 - s01sq - quad1;
+    b2 = bond2*bond2 - s02sq - quad2;
+    b3 = bond3*bond3 - s03sq - quad3;
+
+    lamda01_new = a11inv*b1 + a12inv*b2 + a13inv*b3;
+    lamda02_new = a21inv*b1 + a22inv*b2 + a23inv*b3;
+    lamda03_new = a31inv*b1 + a32inv*b2 + a33inv*b3;
+
+    done = 1;
+    if (fabs(lamda01_new-lamda01) > tolerance) done = 0;
+    if (fabs(lamda02_new-lamda02) > tolerance) done = 0;
+    if (fabs(lamda03_new-lamda03) > tolerance) done = 0;
+
+    lamda01 = lamda01_new;
+    lamda02 = lamda02_new;
+    lamda03 = lamda03_new;
+
+    // stop iterations before we have a floating point overflow
+    // max double is < 1.0e308, so 1e150 is a reasonable cutoff
+
+    if (fabs(lamda01) > 1e150 || fabs(lamda02) > 1e150
+        || fabs(lamda03) > 1e150) done = 1;
+
+    niter++;
+  }
+
+  // update forces if atom is owned by this processor
+
+  lamda01 = lamda01/dtfsq;
+  lamda02 = lamda02/dtfsq;
+  lamda03 = lamda03/dtfsq;
+
+  if (i0 < nlocal) {
+    f[i0][0] += lamda01*r01[0] + lamda02*r02[0] + lamda03*r03[0];
+    f[i0][1] += lamda01*r01[1] + lamda02*r02[1] + lamda03*r03[1];
+    f[i0][2] += lamda01*r01[2] + lamda02*r02[2] + lamda03*r03[2];
+  }
+
+  if (i1 < nlocal) {
+    f[i1][0] -= lamda01*r01[0];
+    f[i1][1] -= lamda01*r01[1];
+    f[i1][2] -= lamda01*r01[2];
+  }
+
+  if (i2 < nlocal) {
+    f[i2][0] -= lamda02*r02[0];
+    f[i2][1] -= lamda02*r02[1];
+    f[i2][2] -= lamda02*r02[2];
+  }
+
+  if (i3 < nlocal) {
+    f[i3][0] -= lamda03*r03[0];
+    f[i3][1] -= lamda03*r03[1];
+    f[i3][2] -= lamda03*r03[2];
+  }
+
+  if (evflag) {
+    nlist = 0;
+    if (i0 < nlocal) list[nlist++] = i0;
+    if (i1 < nlocal) list[nlist++] = i1;
+    if (i2 < nlocal) list[nlist++] = i2;
+    if (i3 < nlocal) list[nlist++] = i3;
+
+    v[0] = lamda01*r01[0]*r01[0]+lamda02*r02[0]*r02[0]+lamda03*r03[0]*r03[0];
+    v[1] = lamda01*r01[1]*r01[1]+lamda02*r02[1]*r02[1]+lamda03*r03[1]*r03[1];
+    v[2] = lamda01*r01[2]*r01[2]+lamda02*r02[2]*r02[2]+lamda03*r03[2]*r03[2];
+    v[3] = lamda01*r01[0]*r01[1]+lamda02*r02[0]*r02[1]+lamda03*r03[0]*r03[1];
+    v[4] = lamda01*r01[0]*r01[2]+lamda02*r02[0]*r02[2]+lamda03*r03[0]*r03[2];
+    v[5] = lamda01*r01[1]*r01[2]+lamda02*r02[1]*r02[2]+lamda03*r03[1]*r03[2];
+
+    v_tally(nlist,list,4.0,v);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixShake::shake3angle(int m)
+{
+  int nlist,list[3];
+  double v[6];
+  double invmass0,invmass1,invmass2;
+
+  // local atom IDs and constraint distances
+
+  int i0 = atom->map(shake_atom[m][0]);
+  int i1 = atom->map(shake_atom[m][1]);
+  int i2 = atom->map(shake_atom[m][2]);
+  double bond1 = bond_distance[shake_type[m][0]];
+  double bond2 = bond_distance[shake_type[m][1]];
+  double bond12 = angle_distance[shake_type[m][2]];
+
+  // r01,r02,r12 = distance vec between atoms, with PBC
+
+  double r01[3];
+  r01[0] = x[i0][0] - x[i1][0];
+  r01[1] = x[i0][1] - x[i1][1];
+  r01[2] = x[i0][2] - x[i1][2];
+  domain->minimum_image(r01);
+
+  double r02[3];
+  r02[0] = x[i0][0] - x[i2][0];
+  r02[1] = x[i0][1] - x[i2][1];
+  r02[2] = x[i0][2] - x[i2][2];
+  domain->minimum_image(r02);
+
+  double r12[3];
+  r12[0] = x[i1][0] - x[i2][0];
+  r12[1] = x[i1][1] - x[i2][1];
+  r12[2] = x[i1][2] - x[i2][2];
+  domain->minimum_image(r12);
+
+  // s01,s02,s12 = distance vec after unconstrained update, with PBC
+  // use Domain::minimum_image_once(), not minimum_image()
+  // b/c xshake values might be huge, due to e.g. fix gcmc
+
+  double s01[3];
+  s01[0] = xshake[i0][0] - xshake[i1][0];
+  s01[1] = xshake[i0][1] - xshake[i1][1];
+  s01[2] = xshake[i0][2] - xshake[i1][2];
+  domain->minimum_image_once(s01);
+
+  double s02[3];
+  s02[0] = xshake[i0][0] - xshake[i2][0];
+  s02[1] = xshake[i0][1] - xshake[i2][1];
+  s02[2] = xshake[i0][2] - xshake[i2][2];
+  domain->minimum_image_once(s02);
+
+  double s12[3];
+  s12[0] = xshake[i1][0] - xshake[i2][0];
+  s12[1] = xshake[i1][1] - xshake[i2][1];
+  s12[2] = xshake[i1][2] - xshake[i2][2];
+  domain->minimum_image_once(s12);
+
+  // scalar distances between atoms
+
+  double r01sq = r01[0]*r01[0] + r01[1]*r01[1] + r01[2]*r01[2];
+  double r02sq = r02[0]*r02[0] + r02[1]*r02[1] + r02[2]*r02[2];
+  double r12sq = r12[0]*r12[0] + r12[1]*r12[1] + r12[2]*r12[2];
+  double s01sq = s01[0]*s01[0] + s01[1]*s01[1] + s01[2]*s01[2];
+  double s02sq = s02[0]*s02[0] + s02[1]*s02[1] + s02[2]*s02[2];
+  double s12sq = s12[0]*s12[0] + s12[1]*s12[1] + s12[2]*s12[2];
+
+  // matrix coeffs and rhs for lamda equations
+
+  if (rmass) {
+    invmass0 = 1.0/rmass[i0];
+    invmass1 = 1.0/rmass[i1];
+    invmass2 = 1.0/rmass[i2];
+  } else {
+    invmass0 = 1.0/mass[type[i0]];
+    invmass1 = 1.0/mass[type[i1]];
+    invmass2 = 1.0/mass[type[i2]];
+  }
+
+  double a11 = 2.0 * (invmass0+invmass1) *
+    (s01[0]*r01[0] + s01[1]*r01[1] + s01[2]*r01[2]);
+  double a12 = 2.0 * invmass0 *
+    (s01[0]*r02[0] + s01[1]*r02[1] + s01[2]*r02[2]);
+  double a13 = - 2.0 * invmass1 *
+    (s01[0]*r12[0] + s01[1]*r12[1] + s01[2]*r12[2]);
+  double a21 = 2.0 * invmass0 *
+    (s02[0]*r01[0] + s02[1]*r01[1] + s02[2]*r01[2]);
+  double a22 = 2.0 * (invmass0+invmass2) *
+    (s02[0]*r02[0] + s02[1]*r02[1] + s02[2]*r02[2]);
+  double a23 = 2.0 * invmass2 *
+    (s02[0]*r12[0] + s02[1]*r12[1] + s02[2]*r12[2]);
+  double a31 = - 2.0 * invmass1 *
+    (s12[0]*r01[0] + s12[1]*r01[1] + s12[2]*r01[2]);
+  double a32 = 2.0 * invmass2 *
+    (s12[0]*r02[0] + s12[1]*r02[1] + s12[2]*r02[2]);
+  double a33 = 2.0 * (invmass1+invmass2) *
+    (s12[0]*r12[0] + s12[1]*r12[1] + s12[2]*r12[2]);
+
+  // inverse of matrix
+
+  double determ = a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
+    a11*a23*a32 - a12*a21*a33 - a13*a22*a31;
+  if (determ == 0.0) error->one(FLERR,"Shake determinant = 0.0");
+  double determinv = 1.0/determ;
+
+  double a11inv = determinv * (a22*a33 - a23*a32);
+  double a12inv = -determinv * (a12*a33 - a13*a32);
+  double a13inv = determinv * (a12*a23 - a13*a22);
+  double a21inv = -determinv * (a21*a33 - a23*a31);
+  double a22inv = determinv * (a11*a33 - a13*a31);
+  double a23inv = -determinv * (a11*a23 - a13*a21);
+  double a31inv = determinv * (a21*a32 - a22*a31);
+  double a32inv = -determinv * (a11*a32 - a12*a31);
+  double a33inv = determinv * (a11*a22 - a12*a21);
+
+  // quadratic correction coeffs
+
+  double r0102 = (r01[0]*r02[0] + r01[1]*r02[1] + r01[2]*r02[2]);
+  double r0112 = (r01[0]*r12[0] + r01[1]*r12[1] + r01[2]*r12[2]);
+  double r0212 = (r02[0]*r12[0] + r02[1]*r12[1] + r02[2]*r12[2]);
+
+  double quad1_0101 = (invmass0+invmass1)*(invmass0+invmass1) * r01sq;
+  double quad1_0202 = invmass0*invmass0 * r02sq;
+  double quad1_1212 = invmass1*invmass1 * r12sq;
+  double quad1_0102 = 2.0 * (invmass0+invmass1)*invmass0 * r0102;
+  double quad1_0112 = - 2.0 * (invmass0+invmass1)*invmass1 * r0112;
+  double quad1_0212 = - 2.0 * invmass0*invmass1 * r0212;
+
+  double quad2_0101 = invmass0*invmass0 * r01sq;
+  double quad2_0202 = (invmass0+invmass2)*(invmass0+invmass2) * r02sq;
+  double quad2_1212 = invmass2*invmass2 * r12sq;
+  double quad2_0102 = 2.0 * (invmass0+invmass2)*invmass0 * r0102;
+  double quad2_0112 = 2.0 * invmass0*invmass2 * r0112;
+  double quad2_0212 = 2.0 * (invmass0+invmass2)*invmass2 * r0212;
+
+  double quad3_0101 = invmass1*invmass1 * r01sq;
+  double quad3_0202 = invmass2*invmass2 * r02sq;
+  double quad3_1212 = (invmass1+invmass2)*(invmass1+invmass2) * r12sq;
+  double quad3_0102 = - 2.0 * invmass1*invmass2 * r0102;
+  double quad3_0112 = - 2.0 * (invmass1+invmass2)*invmass1 * r0112;
+  double quad3_0212 = 2.0 * (invmass1+invmass2)*invmass2 * r0212;
+
+  // iterate until converged
+
+  double lamda01 = 0.0;
+  double lamda02 = 0.0;
+  double lamda12 = 0.0;
+  int niter = 0;
+  int done = 0;
+
+  double quad1,quad2,quad3,b1,b2,b3,lamda01_new,lamda02_new,lamda12_new;
+
+  while (!done && niter < max_iter) {
+
+    quad1 = quad1_0101 * lamda01*lamda01 +
+      quad1_0202 * lamda02*lamda02 +
+      quad1_1212 * lamda12*lamda12 +
+      quad1_0102 * lamda01*lamda02 +
+      quad1_0112 * lamda01*lamda12 +
+      quad1_0212 * lamda02*lamda12;
+
+    quad2 = quad2_0101 * lamda01*lamda01 +
+      quad2_0202 * lamda02*lamda02 +
+      quad2_1212 * lamda12*lamda12 +
+      quad2_0102 * lamda01*lamda02 +
+      quad2_0112 * lamda01*lamda12 +
+      quad2_0212 * lamda02*lamda12;
+
+    quad3 = quad3_0101 * lamda01*lamda01 +
+      quad3_0202 * lamda02*lamda02 +
+      quad3_1212 * lamda12*lamda12 +
+      quad3_0102 * lamda01*lamda02 +
+      quad3_0112 * lamda01*lamda12 +
+      quad3_0212 * lamda02*lamda12;
+
+    b1 = bond1*bond1 - s01sq - quad1;
+    b2 = bond2*bond2 - s02sq - quad2;
+    b3 = bond12*bond12 - s12sq - quad3;
+
+    lamda01_new = a11inv*b1 + a12inv*b2 + a13inv*b3;
+    lamda02_new = a21inv*b1 + a22inv*b2 + a23inv*b3;
+    lamda12_new = a31inv*b1 + a32inv*b2 + a33inv*b3;
+
+    done = 1;
+    if (fabs(lamda01_new-lamda01) > tolerance) done = 0;
+    if (fabs(lamda02_new-lamda02) > tolerance) done = 0;
+    if (fabs(lamda12_new-lamda12) > tolerance) done = 0;
+
+    lamda01 = lamda01_new;
+    lamda02 = lamda02_new;
+    lamda12 = lamda12_new;
+
+    // stop iterations before we have a floating point overflow
+    // max double is < 1.0e308, so 1e150 is a reasonable cutoff
+
+    if (fabs(lamda01) > 1e150 || fabs(lamda02) > 1e150
+        || fabs(lamda12) > 1e150) done = 1;
+
+    niter++;
+  }
+
+  // update forces if atom is owned by this processor
+
+  lamda01 = lamda01/dtfsq;
+  lamda02 = lamda02/dtfsq;
+  lamda12 = lamda12/dtfsq;
+
+  if (i0 < nlocal) {
+    f[i0][0] += lamda01*r01[0] + lamda02*r02[0];
+    f[i0][1] += lamda01*r01[1] + lamda02*r02[1];
+    f[i0][2] += lamda01*r01[2] + lamda02*r02[2];
+  }
+
+  if (i1 < nlocal) {
+    f[i1][0] -= lamda01*r01[0] - lamda12*r12[0];
+    f[i1][1] -= lamda01*r01[1] - lamda12*r12[1];
+    f[i1][2] -= lamda01*r01[2] - lamda12*r12[2];
+  }
+
+  if (i2 < nlocal) {
+    f[i2][0] -= lamda02*r02[0] + lamda12*r12[0];
+    f[i2][1] -= lamda02*r02[1] + lamda12*r12[1];
+    f[i2][2] -= lamda02*r02[2] + lamda12*r12[2];
+  }
+
+  if (evflag) {
+    nlist = 0;
+    if (i0 < nlocal) list[nlist++] = i0;
+    if (i1 < nlocal) list[nlist++] = i1;
+    if (i2 < nlocal) list[nlist++] = i2;
+
+    v[0] = lamda01*r01[0]*r01[0]+lamda02*r02[0]*r02[0]+lamda12*r12[0]*r12[0];
+    v[1] = lamda01*r01[1]*r01[1]+lamda02*r02[1]*r02[1]+lamda12*r12[1]*r12[1];
+    v[2] = lamda01*r01[2]*r01[2]+lamda02*r02[2]*r02[2]+lamda12*r12[2]*r12[2];
+    v[3] = lamda01*r01[0]*r01[1]+lamda02*r02[0]*r02[1]+lamda12*r12[0]*r12[1];
+    v[4] = lamda01*r01[0]*r01[2]+lamda02*r02[0]*r02[2]+lamda12*r12[0]*r12[2];
+    v[5] = lamda01*r01[1]*r01[2]+lamda02*r02[1]*r02[2]+lamda12*r12[1]*r12[2];
+
+    v_tally(nlist,list,3.0,v);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   print-out bond & angle statistics
+------------------------------------------------------------------------- */
+
+void FixShake::stats()
+{
+  int i,j,m,n,iatom,jatom,katom;
+  double delx,dely,delz;
+  double r,r1,r2,r3,angle;
+
+  // zero out accumulators
+
+  int nb = atom->nbondtypes + 1;
+  int na = atom->nangletypes + 1;
+
+  for (i = 0; i < nb; i++) {
+    b_count[i] = 0;
+    b_ave[i] = b_max[i] = 0.0;
+    b_min[i] = BIG;
+  }
+  for (i = 0; i < na; i++) {
+    a_count[i] = 0;
+    a_ave[i] = a_max[i] = 0.0;
+    a_min[i] = BIG;
+  }
+
+  // log stats for each bond & angle
+  // OK to double count since are just averaging
+
+  double **x = atom->x;
+  int nlocal = atom->nlocal;
+
+  for (i = 0; i < nlocal; i++) {
+    if (shake_flag[i] == 0) continue;
+
+    // bond stats
+
+    n = shake_flag[i];
+    if (n == 1) n = 3;
+    iatom = atom->map(shake_atom[i][0]);
+    for (j = 1; j < n; j++) {
+      jatom = atom->map(shake_atom[i][j]);
+      delx = x[iatom][0] - x[jatom][0];
+      dely = x[iatom][1] - x[jatom][1];
+      delz = x[iatom][2] - x[jatom][2];
+      domain->minimum_image(delx,dely,delz);
+      r = sqrt(delx*delx + dely*dely + delz*delz);
+
+      m = shake_type[i][j-1];
+      b_count[m]++;
+      b_ave[m] += r;
+      b_max[m] = MAX(b_max[m],r);
+      b_min[m] = MIN(b_min[m],r);
+    }
+
+    // angle stats
+
+    if (shake_flag[i] == 1) {
+      iatom = atom->map(shake_atom[i][0]);
+      jatom = atom->map(shake_atom[i][1]);
+      katom = atom->map(shake_atom[i][2]);
+
+      delx = x[iatom][0] - x[jatom][0];
+      dely = x[iatom][1] - x[jatom][1];
+      delz = x[iatom][2] - x[jatom][2];
+      domain->minimum_image(delx,dely,delz);
+      r1 = sqrt(delx*delx + dely*dely + delz*delz);
+
+      delx = x[iatom][0] - x[katom][0];
+      dely = x[iatom][1] - x[katom][1];
+      delz = x[iatom][2] - x[katom][2];
+      domain->minimum_image(delx,dely,delz);
+      r2 = sqrt(delx*delx + dely*dely + delz*delz);
+
+      delx = x[jatom][0] - x[katom][0];
+      dely = x[jatom][1] - x[katom][1];
+      delz = x[jatom][2] - x[katom][2];
+      domain->minimum_image(delx,dely,delz);
+      r3 = sqrt(delx*delx + dely*dely + delz*delz);
+
+      angle = acos((r1*r1 + r2*r2 - r3*r3) / (2.0*r1*r2));
+      angle *= 180.0/MY_PI;
+      m = shake_type[i][2];
+      a_count[m]++;
+      a_ave[m] += angle;
+      a_max[m] = MAX(a_max[m],angle);
+      a_min[m] = MIN(a_min[m],angle);
+    }
+  }
+
+  // sum across all procs
+
+  MPI_Allreduce(b_count,b_count_all,nb,MPI_INT,MPI_SUM,world);
+  MPI_Allreduce(b_ave,b_ave_all,nb,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(b_max,b_max_all,nb,MPI_DOUBLE,MPI_MAX,world);
+  MPI_Allreduce(b_min,b_min_all,nb,MPI_DOUBLE,MPI_MIN,world);
+
+  MPI_Allreduce(a_count,a_count_all,na,MPI_INT,MPI_SUM,world);
+  MPI_Allreduce(a_ave,a_ave_all,na,MPI_DOUBLE,MPI_SUM,world);
+  MPI_Allreduce(a_max,a_max_all,na,MPI_DOUBLE,MPI_MAX,world);
+  MPI_Allreduce(a_min,a_min_all,na,MPI_DOUBLE,MPI_MIN,world);
+
+  // print stats only for non-zero counts
+
+  if (me == 0) {
+
+    if (screen) {
+      fprintf(screen,
+              "SHAKE stats (type/ave/delta) on step " BIGINT_FORMAT "\n",
+              update->ntimestep);
+      for (i = 1; i < nb; i++)
+        if (b_count_all[i])
+          fprintf(screen,"  %d %g %g %d\n",i,
+                  b_ave_all[i]/b_count_all[i],b_max_all[i]-b_min_all[i],
+                  b_count_all[i]);
+      for (i = 1; i < na; i++)
+        if (a_count_all[i])
+          fprintf(screen,"  %d %g %g\n",i,
+                  a_ave_all[i]/a_count_all[i],a_max_all[i]-a_min_all[i]);
+    }
+    if (logfile) {
+      fprintf(logfile,
+              "SHAKE stats (type/ave/delta) on step " BIGINT_FORMAT "\n",
+              update->ntimestep);
+      for (i = 0; i < nb; i++)
+        if (b_count_all[i])
+          fprintf(logfile,"  %d %g %g\n",i,
+                  b_ave_all[i]/b_count_all[i],b_max_all[i]-b_min_all[i]);
+      for (i = 0; i < na; i++)
+        if (a_count_all[i])
+          fprintf(logfile,"  %d %g %g\n",i,
+                  a_ave_all[i]/a_count_all[i],a_max_all[i]-a_min_all[i]);
+    }
+  }
+
+  // next timestep for stats
+
+  next_output += output_every;
+}
+
+/* ----------------------------------------------------------------------
+   find a bond between global atom IDs n1 and n2 stored with local atom i
+   if find it:
+     if setflag = 0, return bond type
+     if setflag = -1/1, set bond type to negative/positive and return 0
+   if do not find it, return 0
+------------------------------------------------------------------------- */
+
+int FixShake::bondtype_findset(int i, tagint n1, tagint n2, int setflag)
+{
+  int m,nbonds;
+  int *btype;
+
+  if (molecular == 1) {
+    tagint *tag = atom->tag;
+    tagint **bond_atom = atom->bond_atom;
+    nbonds = atom->num_bond[i];
+
+    for (m = 0; m < nbonds; m++) {
+      if (n1 == tag[i] && n2 == bond_atom[i][m]) break;
+      if (n1 == bond_atom[i][m] && n2 == tag[i]) break;
+    }
+
+  } else {
+    int imol = atom->molindex[i];
+    int iatom = atom->molatom[i];
+    tagint *tag = atom->tag;
+    tagint tagprev = tag[i] - iatom - 1;
+    tagint *batom = atommols[imol]->bond_atom[iatom];
+    btype = atommols[imol]->bond_type[iatom];
+    nbonds = atommols[imol]->num_bond[iatom];
+    
+    for (m = 0; m < nbonds; m++) {
+      if (n1 == tag[i] && n2 == batom[m]+tagprev) break;
+      if (n1 == batom[m]+tagprev && n2 == tag[i]) break;
+    }
+  }
+
+  if (m < nbonds) {
+    if (setflag == 0) {
+      if (molecular == 1) return atom->bond_type[i][m];
+      else return btype[m];
+    }
+    if (molecular == 1) {
+      if ((setflag < 0 && atom->bond_type[i][m] > 0) ||
+          (setflag > 0 && atom->bond_type[i][m] < 0))
+        atom->bond_type[i][m] = -atom->bond_type[i][m];
+    } else {
+      if ((setflag < 0 && btype[m] > 0) ||
+          (setflag > 0 && btype[m] < 0)) btype[m] = -btype[m];
+    }
+  }
+
+  return 0;
+}
+
+/* ----------------------------------------------------------------------
+   find an angle with global end atom IDs n1 and n2 stored with local atom i
+   if find it:
+     if setflag = 0, return angle type
+     if setflag = -1/1, set angle type to negative/positive and return 0
+   if do not find it, return 0
+------------------------------------------------------------------------- */
+
+int FixShake::angletype_findset(int i, tagint n1, tagint n2, int setflag)
+{
+  int m,nangles;
+  int *atype;
+
+  if (molecular == 1) {
+    tagint **angle_atom1 = atom->angle_atom1;
+    tagint **angle_atom3 = atom->angle_atom3;
+    nangles = atom->num_angle[i];
+
+    for (m = 0; m < nangles; m++) {
+      if (n1 == angle_atom1[i][m] && n2 == angle_atom3[i][m]) break;
+      if (n1 == angle_atom3[i][m] && n2 == angle_atom1[i][m]) break;
+    }
+
+  } else {
+    int imol = atom->molindex[i];
+    int iatom = atom->molatom[i];
+    tagint *tag = atom->tag;
+    tagint tagprev = tag[i] - iatom - 1;
+    tagint *aatom1 = atommols[imol]->angle_atom1[iatom];
+    tagint *aatom3 = atommols[imol]->angle_atom3[iatom];
+    atype = atommols[imol]->angle_type[iatom];
+    nangles = atommols[imol]->num_angle[iatom];
+    
+    for (m = 0; m < nangles; m++) {
+      if (n1 == aatom1[m]+tagprev && n2 == aatom3[m]+tagprev) break;
+      if (n1 == aatom3[m]+tagprev && n2 == aatom1[m]+tagprev) break;
+    }
+  }
+
+  if (m < nangles) {
+    if (setflag == 0) {
+      if (molecular == 1) return atom->angle_type[i][m];
+      else return atype[m];
+    }
+    if (molecular == 1) {
+      if ((setflag < 0 && atom->angle_type[i][m] > 0) ||
+          (setflag > 0 && atom->angle_type[i][m] < 0))
+        atom->angle_type[i][m] = -atom->angle_type[i][m];
+    } else {
+      if ((setflag < 0 && atype[m] > 0) ||
+          (setflag > 0 && atype[m] < 0)) atype[m] = -atype[m];
+    }
+  }
+
+  return 0;
+}
+
+/* ----------------------------------------------------------------------
+   memory usage of local atom-based arrays
+------------------------------------------------------------------------- */
+
+double FixShake::memory_usage()
+{
+  int nmax = atom->nmax;
+  double bytes = nmax * sizeof(int);
+  bytes += nmax*4 * sizeof(int);
+  bytes += nmax*3 * sizeof(int);
+  bytes += nmax*3 * sizeof(double);
+  bytes += maxvatom*6 * sizeof(double);
+  return bytes;
+}
+
+/* ----------------------------------------------------------------------
+   allocate local atom-based arrays
+------------------------------------------------------------------------- */
+
+void FixShake::grow_arrays(int nmax)
+{
+  memory->grow(shake_flag,nmax,"shake:shake_flag");
+  memory->grow(shake_atom,nmax,4,"shake:shake_atom");
+  memory->grow(shake_type,nmax,3,"shake:shake_type");
+  memory->destroy(xshake);
+  memory->create(xshake,nmax,3,"shake:xshake");
+  memory->destroy(ftmp);
+  memory->create(ftmp,nmax,3,"shake:ftmp");
+  memory->destroy(vtmp);
+  memory->create(vtmp,nmax,3,"shake:vtmp");
+}
+
+/* ----------------------------------------------------------------------
+   copy values within local atom-based arrays
+------------------------------------------------------------------------- */
+
+void FixShake::copy_arrays(int i, int j, int delflag)
+{
+  int flag = shake_flag[j] = shake_flag[i];
+  if (flag == 1) {
+    shake_atom[j][0] = shake_atom[i][0];
+    shake_atom[j][1] = shake_atom[i][1];
+    shake_atom[j][2] = shake_atom[i][2];
+    shake_type[j][0] = shake_type[i][0];
+    shake_type[j][1] = shake_type[i][1];
+    shake_type[j][2] = shake_type[i][2];
+  } else if (flag == 2) {
+    shake_atom[j][0] = shake_atom[i][0];
+    shake_atom[j][1] = shake_atom[i][1];
+    shake_type[j][0] = shake_type[i][0];
+  } else if (flag == 3) {
+    shake_atom[j][0] = shake_atom[i][0];
+    shake_atom[j][1] = shake_atom[i][1];
+    shake_atom[j][2] = shake_atom[i][2];
+    shake_type[j][0] = shake_type[i][0];
+    shake_type[j][1] = shake_type[i][1];
+  } else if (flag == 4) {
+    shake_atom[j][0] = shake_atom[i][0];
+    shake_atom[j][1] = shake_atom[i][1];
+    shake_atom[j][2] = shake_atom[i][2];
+    shake_atom[j][3] = shake_atom[i][3];
+    shake_type[j][0] = shake_type[i][0];
+    shake_type[j][1] = shake_type[i][1];
+    shake_type[j][2] = shake_type[i][2];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   initialize one atom's array values, called when atom is created
+------------------------------------------------------------------------- */
+
+void FixShake::set_arrays(int i)
+{
+  shake_flag[i] = 0;
+}
+
+/* ----------------------------------------------------------------------
+   update one atom's array values
+   called when molecule is created from fix gcmc
+------------------------------------------------------------------------- */
+
+void FixShake::update_arrays(int i, int atom_offset)
+{
+  int flag = shake_flag[i];
+
+  if (flag == 1) {
+    shake_atom[i][0] += atom_offset;
+    shake_atom[i][1] += atom_offset;
+    shake_atom[i][2] += atom_offset;
+  } else if (flag == 2) { 
+    shake_atom[i][0] += atom_offset;
+    shake_atom[i][1] += atom_offset;
+  } else if (flag == 3) {
+    shake_atom[i][0] += atom_offset;
+    shake_atom[i][1] += atom_offset;
+    shake_atom[i][2] += atom_offset;
+  } else if (flag == 4) {
+    shake_atom[i][0] += atom_offset;
+    shake_atom[i][1] += atom_offset;
+    shake_atom[i][2] += atom_offset;
+    shake_atom[i][3] += atom_offset;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   initialize a molecule inserted by another fix, e.g. deposit or pour
+   called when molecule is created
+   nlocalprev = # of atoms on this proc before molecule inserted
+   tagprev = atom ID previous to new atoms in the molecule
+   xgeom,vcm,quat ignored
+------------------------------------------------------------------------- */
+
+void FixShake::set_molecule(int nlocalprev, tagint tagprev, int imol,
+                            double *xgeom, double *vcm, double *quat)
+{
+  int m,flag;
+
+  int nlocal = atom->nlocal;
+  if (nlocalprev == nlocal) return;
+
+  tagint *tag = atom->tag;
+  tagint **mol_shake_atom = onemols[imol]->shake_atom;
+  int **mol_shake_type = onemols[imol]->shake_type;
+
+  for (int i = nlocalprev; i < nlocal; i++) {
+    m = tag[i] - tagprev-1;
+
+    flag = shake_flag[i] = onemols[imol]->shake_flag[m];
+
+    if (flag == 1) {
+      shake_atom[i][0] = mol_shake_atom[m][0] + tagprev;
+      shake_atom[i][1] = mol_shake_atom[m][1] + tagprev;
+      shake_atom[i][2] = mol_shake_atom[m][2] + tagprev;
+      shake_type[i][0] = mol_shake_type[m][0];
+      shake_type[i][1] = mol_shake_type[m][1];
+      shake_type[i][2] = mol_shake_type[m][2];
+    } else if (flag == 2) {
+      shake_atom[i][0] = mol_shake_atom[m][0] + tagprev;
+      shake_atom[i][1] = mol_shake_atom[m][1] + tagprev;
+      shake_type[i][0] = mol_shake_type[m][0];
+    } else if (flag == 3) {
+      shake_atom[i][0] = mol_shake_atom[m][0] + tagprev;
+      shake_atom[i][1] = mol_shake_atom[m][1] + tagprev;
+      shake_atom[i][2] = mol_shake_atom[m][2] + tagprev;
+      shake_type[i][0] = mol_shake_type[m][0];
+      shake_type[i][1] = mol_shake_type[m][1];
+    } else if (flag == 4) {
+      shake_atom[i][0] = mol_shake_atom[m][0] + tagprev;
+      shake_atom[i][1] = mol_shake_atom[m][1] + tagprev;
+      shake_atom[i][2] = mol_shake_atom[m][2] + tagprev;
+      shake_atom[i][3] = mol_shake_atom[m][3] + tagprev;
+      shake_type[i][0] = mol_shake_type[m][0];
+      shake_type[i][1] = mol_shake_type[m][1];
+      shake_type[i][2] = mol_shake_type[m][2];
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   pack values in local atom-based arrays for exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixShake::pack_exchange(int i, double *buf)
+{
+  int m = 0;
+  buf[m++] = shake_flag[i];
+  int flag = shake_flag[i];
+  if (flag == 1) {
+    buf[m++] = shake_atom[i][0];
+    buf[m++] = shake_atom[i][1];
+    buf[m++] = shake_atom[i][2];
+    buf[m++] = shake_type[i][0];
+    buf[m++] = shake_type[i][1];
+    buf[m++] = shake_type[i][2];
+  } else if (flag == 2) {
+    buf[m++] = shake_atom[i][0];
+    buf[m++] = shake_atom[i][1];
+    buf[m++] = shake_type[i][0];
+  } else if (flag == 3) {
+    buf[m++] = shake_atom[i][0];
+    buf[m++] = shake_atom[i][1];
+    buf[m++] = shake_atom[i][2];
+    buf[m++] = shake_type[i][0];
+    buf[m++] = shake_type[i][1];
+  } else if (flag == 4) {
+    buf[m++] = shake_atom[i][0];
+    buf[m++] = shake_atom[i][1];
+    buf[m++] = shake_atom[i][2];
+    buf[m++] = shake_atom[i][3];
+    buf[m++] = shake_type[i][0];
+    buf[m++] = shake_type[i][1];
+    buf[m++] = shake_type[i][2];
+  }
+  return m;
+}
+
+/* ----------------------------------------------------------------------
+   unpack values in local atom-based arrays from exchange with another proc
+------------------------------------------------------------------------- */
+
+int FixShake::unpack_exchange(int nlocal, double *buf)
+{
+  int m = 0;
+  int flag = shake_flag[nlocal] = static_cast<int> (buf[m++]);
+  if (flag == 1) {
+    shake_atom[nlocal][0] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][1] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][2] = static_cast<tagint> (buf[m++]);
+    shake_type[nlocal][0] = static_cast<int> (buf[m++]);
+    shake_type[nlocal][1] = static_cast<int> (buf[m++]);
+    shake_type[nlocal][2] = static_cast<int> (buf[m++]);
+  } else if (flag == 2) {
+    shake_atom[nlocal][0] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][1] = static_cast<tagint> (buf[m++]);
+    shake_type[nlocal][0] = static_cast<int> (buf[m++]);
+  } else if (flag == 3) {
+    shake_atom[nlocal][0] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][1] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][2] = static_cast<tagint> (buf[m++]);
+    shake_type[nlocal][0] = static_cast<int> (buf[m++]);
+    shake_type[nlocal][1] = static_cast<int> (buf[m++]);
+  } else if (flag == 4) {
+    shake_atom[nlocal][0] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][1] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][2] = static_cast<tagint> (buf[m++]);
+    shake_atom[nlocal][3] = static_cast<tagint> (buf[m++]);
+    shake_type[nlocal][0] = static_cast<int> (buf[m++]);
+    shake_type[nlocal][1] = static_cast<int> (buf[m++]);
+    shake_type[nlocal][2] = static_cast<int> (buf[m++]);
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixShake::pack_forward_comm(int n, int *list, double *buf, 
+                                int pbc_flag, int *pbc)
+{
+  int i,j,m;
+  double dx,dy,dz;
+
+  m = 0;
+  if (pbc_flag == 0) {
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = xshake[j][0];
+      buf[m++] = xshake[j][1];
+      buf[m++] = xshake[j][2];
+    }
+  } else {
+    if (domain->triclinic == 0) {
+      dx = pbc[0]*domain->xprd;
+      dy = pbc[1]*domain->yprd;
+      dz = pbc[2]*domain->zprd;
+    } else {
+      dx = pbc[0]*domain->xprd + pbc[5]*domain->xy + pbc[4]*domain->xz;
+      dy = pbc[1]*domain->yprd + pbc[3]*domain->yz;
+      dz = pbc[2]*domain->zprd;
+    }
+    for (i = 0; i < n; i++) {
+      j = list[i];
+      buf[m++] = xshake[j][0] + dx;
+      buf[m++] = xshake[j][1] + dy;
+      buf[m++] = xshake[j][2] + dz;
+    }
+  }
+  return m;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixShake::unpack_forward_comm(int n, int first, double *buf)
+{
+  int i,m,last;
+
+  m = 0;
+  last = first + n;
+  for (i = first; i < last; i++) {
+    xshake[i][0] = buf[m++];
+    xshake[i][1] = buf[m++];
+    xshake[i][2] = buf[m++];
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixShake::reset_dt()
+{
+  if (strstr(update->integrate_style,"verlet")) {
+    dtv = update->dt;
+    if (rattle) dtfsq   = 0.5 * update->dt * update->dt * force->ftm2v;
+    else dtfsq = update->dt * update->dt * force->ftm2v;
+  } else {
+    dtv = step_respa[0];
+    dtf_innerhalf = 0.5 * step_respa[0] * force->ftm2v;
+    if (rattle) dtf_inner = dtf_innerhalf;
+    else dtf_inner = step_respa[0] * force->ftm2v;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   extract Molecule ptr
+------------------------------------------------------------------------- */
+
+void *FixShake::extract(const char *str, int &dim)
+{
+  dim = 0;
+  if (strcmp(str,"onemol") == 0) return onemols;
+  return NULL;
+}
+
+/* ----------------------------------------------------------------------
+   add coordinate constraining forces
+   this method is called at the end of a timestep
+------------------------------------------------------------------------- */
+
+void FixShake::shake_end_of_step(int vflag) {
+
+  if (!respa) {
+    dtv     = update->dt;
+    dtfsq   = 0.5 * update->dt * update->dt * force->ftm2v;
+    FixShake::post_force(vflag);
+    if (!rattle) dtfsq = update->dt * update->dt * force->ftm2v;
+
+  } else {
+    dtv = step_respa[0];
+    dtf_innerhalf = 0.5 * step_respa[0] * force->ftm2v;
+    dtf_inner = dtf_innerhalf;
+
+    // apply correction to all rRESPA levels
+
+    for (int ilevel = 0; ilevel < nlevels_respa; ilevel++) {
+      ((Respa *) update->integrate)->copy_flevel_f(ilevel);
+      FixShake::post_force_respa(vflag,ilevel,loop_respa[ilevel]-1);
+      ((Respa *) update->integrate)->copy_f_flevel(ilevel);
+    }
+    if (!rattle) dtf_inner = step_respa[0] * force->ftm2v;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   wrapper method for end_of_step fixes which modify velocities
+------------------------------------------------------------------------- */
+
+void FixShake::correct_velocities() {}
+
+/* ----------------------------------------------------------------------
+   calculate constraining forces based on the current configuration
+   change coordinates
+------------------------------------------------------------------------- */
+
+void FixShake::correct_coordinates(int vflag) { 
+   
+  // save current forces and velocities so that you 
+  // initialise them to zero such that FixShake::unconstrained_coordinate_update has no effect 
+
+  for (int j=0; j<nlocal; j++) {
+    for (int k=0; k<3; k++) {
+
+      // store current value of forces and velocities
+
+      ftmp[j][k] = f[j][k];
+      vtmp[j][k] = v[j][k];
+
+      // set f and v to zero for SHAKE
+
+      v[j][k] = 0;
+      f[j][k] = 0;
+    }
+  }
+
+  // call SHAKE to correct the coordinates which were updated without constraints
+  // IMPORTANT: use 1 as argument and thereby enforce velocity Verlet
+
+  dtfsq   = 0.5 * update->dt * update->dt * force->ftm2v;
+  FixShake::post_force(vflag);
+
+  // integrate coordiantes: x' = xnp1 + dt^2/2m_i * f, where f is the constraining force
+  // NOTE: After this command, the coordinates geometry of the molecules will be correct! 
+
+  double dtfmsq; 
+  if (rmass) {  
+    for (int i = 0; i < nlocal; i++) {  
+      dtfmsq = dtfsq/ rmass[i];  
+      x[i][0] = x[i][0] + dtfmsq*f[i][0];  
+      x[i][1] = x[i][1] + dtfmsq*f[i][1];  
+      x[i][2] = x[i][2] + dtfmsq*f[i][2];  
+    }  
+  }  
+  else {  
+    for (int i = 0; i < nlocal; i++) {  
+      dtfmsq = dtfsq / mass[type[i]];  
+      x[i][0] = x[i][0] + dtfmsq*f[i][0];  
+      x[i][1] = x[i][1] + dtfmsq*f[i][1];  
+      x[i][2] = x[i][2] + dtfmsq*f[i][2];  
+    }  
+  }
+
+  // copy forces and velocities back
+
+  for (int j=0; j<nlocal; j++) {
+    for (int k=0; k<3; k++) {
+      f[j][k] = ftmp[j][k];
+      v[j][k] = vtmp[j][k];
+    }
+  }
+
+  if (!rattle) dtfsq = update->dt * update->dt * force->ftm2v;
+
+  // communicate changes
+  // NOTE: for compatibility xshake is temporarily set to x, such that pack/unpack_forward 
+  //       can be used for communicating the coordinates. 
+
+  double **xtmp = xshake;
+  xshake = x;
+  if (nprocs > 1) {
+    comm->forward_comm_fix(this);
+  }
+  xshake = xtmp;
+}
diff -uN src/fix_shake.h src_DFT-CES2/fix_shake.h
--- src/fix_shake.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/fix_shake.h	2025-02-11 06:42:37.177608906 +0900
@@ -0,0 +1,267 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(shake,FixShake)
+
+#else
+
+#ifndef LMP_FIX_SHAKE_H
+#define LMP_FIX_SHAKE_H
+
+#include "fix.h"
+
+namespace LAMMPS_NS {
+
+class FixShake : public Fix {
+
+ friend class FixEHEX;
+
+ public:
+  FixShake(class LAMMPS *, int, char **);
+  virtual ~FixShake();
+  virtual int setmask();
+  virtual void init();
+  void setup(int);
+  void pre_neighbor();
+  virtual void post_force(int);
+  virtual void post_force_respa(int, int, int);
+
+  virtual double memory_usage();
+  virtual void grow_arrays(int);
+  virtual void copy_arrays(int, int, int);
+  void set_arrays(int);
+  virtual void update_arrays(int, int);
+  void set_molecule(int, tagint, int, double *, double *, double *);
+
+  virtual int pack_exchange(int, double *);
+  virtual int unpack_exchange(int, double *);
+  virtual int pack_forward_comm(int, int *, double *, int, int *);
+  virtual void unpack_forward_comm(int, int, double *);
+
+  virtual void shake_end_of_step(int vflag);
+  virtual void correct_coordinates(int vflag);
+  virtual void correct_velocities();
+
+  int dof(int);
+  virtual void reset_dt();
+  void *extract(const char *, int &);
+
+ protected:
+  int vflag_post_force;                  // store the vflag of last post_force call
+  int respa;                             // 0 = vel. Verlet, 1 = respa
+  int me,nprocs;
+  int rattle;                            // 0 = SHAKE, 1 = RATTLE
+  double tolerance;                      // SHAKE tolerance
+  int max_iter;                          // max # of SHAKE iterations
+  int output_every;                      // SHAKE stat output every so often
+  bigint next_output;                    // timestep for next output
+  
+                                         // settings from input command
+  int *bond_flag,*angle_flag;            // bond/angle types to constrain
+  int *type_flag;                        // constrain bonds to these types
+  double *mass_list;                     // constrain bonds to these masses
+  int nmass;                             // # of masses in mass_list
+
+  int molecular;                         // copy of atom->molecular
+  double *bond_distance,*angle_distance; // constraint distances
+
+  int ifix_respa;                        // rRESPA fix needed by SHAKE
+  int nlevels_respa;                     // copies of needed rRESPA variables
+  int *loop_respa;
+  double *step_respa;
+
+  double **x,**v,**f;                    // local ptrs to atom class quantities
+  double **ftmp,**vtmp;                  // pointers to temporary arrays for f,v
+
+  double *mass,*rmass;
+  int *type;
+  int nlocal;
+                                         // atom-based arrays
+  int *shake_flag;                       // 0 if atom not in SHAKE cluster
+                                         // 1 = size 3 angle cluster
+                                         // 2,3,4 = size of bond-only cluster
+  tagint **shake_atom;                   // global IDs of atoms in cluster
+                                         // central atom is 1st
+                                         // lowest global ID is 1st for size 2
+  int **shake_type;                      // bondtype of each bond in cluster
+                                         // for angle cluster, 3rd value
+                                         //   is angletype
+  double **xshake;                       // unconstrained atom coords
+  int *nshake;                           // count
+
+  double dtv,dtfsq;                     // timesteps for trial move
+  double dtf_inner,dtf_innerhalf;       // timesteps for rRESPA trial move
+
+  int *list;                            // list of clusters to SHAKE
+  int nlist,maxlist;                    // size and max-size of list
+
+                                        // stat quantities
+  int *b_count,*b_count_all;            // counts for each bond type
+  double *b_ave,*b_max,*b_min;          // ave/max/min dist for each bond type
+  double *b_ave_all,*b_max_all,*b_min_all;   // MPI summing arrays
+  int *a_count,*a_count_all;            // ditto for angle types
+  double *a_ave,*a_max,*a_min;
+  double *a_ave_all,*a_max_all,*a_min_all;
+
+  class Molecule **atommols;            // atom style template pointer
+  class Molecule **onemols;             // molecule added on-the-fly
+  int nmol;
+
+  void find_clusters();
+  int masscheck(double);
+  void unconstrained_update();
+  void unconstrained_update_respa(int);
+  void shake(int);
+  void shake3(int);
+  void shake4(int);
+  void shake3angle(int);
+  void stats();
+  int bondtype_findset(int, tagint, tagint, int);
+  int angletype_findset(int, tagint, tagint, int);
+
+  // static variable for ring communication callback to access class data
+  // callback functions for ring communication
+
+  static void ring_bonds(int, char *, void *);
+  static void ring_nshake(int, char *, void *);
+  static void ring_shake(int, char *, void *);
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Cannot use fix shake with non-molecular system
+
+Your choice of atom style does not have bonds.
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Invalid bond type index for fix shake
+
+Self-explanatory.  Check the fix shake command in the input script.
+
+E: Invalid angle type index for fix shake
+
+Self-explanatory.
+
+E: Invalid atom type index for fix shake
+
+Atom types must range from 1 to Ntypes inclusive.
+
+E: Invalid atom mass for fix shake
+
+Mass specified in fix shake command must be > 0.0.
+
+E: Too many masses for fix shake
+
+The fix shake command cannot list more masses than there are atom
+types.
+
+E: Molecule template ID for fix shake does not exist
+
+Self-explanatory.
+
+W: Molecule template for fix shake has multiple molecules
+
+The fix shake command will only recognize molecules of a single
+type, i.e. the first molecule in the template.
+
+E: Fix shake molecule template must have shake info
+
+The defined molecule does not specify SHAKE information.
+
+E: More than one fix shake
+
+Only one fix shake can be defined.
+
+E: Fix shake cannot be used with minimization
+
+Cannot use fix shake while doing an energy minimization since
+it turns off bonds that should contribute to the energy.
+
+E: Shake fix must come before NPT/NPH fix
+
+NPT fix must be defined in input script after SHAKE fix, else the
+SHAKE fix contribution to the pressure virial is incorrect.
+
+E: Bond potential must be defined for SHAKE
+
+Cannot use fix shake unless bond potential is defined.
+
+E: Angle potential must be defined for SHAKE
+
+When shaking angles, an angle_style potential must be used.
+
+E: Shake angles have different bond types
+
+All 3-atom angle-constrained SHAKE clusters specified by the fix shake
+command that are the same angle type, must also have the same bond
+types for the 2 bonds in the angle.
+
+E: Shake atoms %d %d missing on proc %d at step %ld
+
+The 2 atoms in a single shake cluster specified by the fix shake
+command are not all accessible to a processor.  This probably means
+an atom has moved too far.
+
+E: Shake atoms %d %d %d missing on proc %d at step %ld
+
+The 3 atoms in a single shake cluster specified by the fix shake
+command are not all accessible to a processor.  This probably means
+an atom has moved too far.
+
+E: Shake atoms %d %d %d %d missing on proc %d at step %ld
+
+The 4 atoms in a single shake cluster specified by the fix shake
+command are not all accessible to a processor.  This probably means
+an atom has moved too far.
+
+E: Did not find fix shake partner info
+
+Could not find bond partners implied by fix shake command.  This error
+can be triggered if the delete_bonds command was used before fix
+shake, and it removed bonds without resetting the 1-2, 1-3, 1-4
+weighting list via the special keyword.
+
+E: Shake cluster of more than 4 atoms
+
+A single cluster specified by the fix shake command can have no more
+than 4 atoms.
+
+E: Shake clusters are connected
+
+A single cluster specified by the fix shake command must have a single
+central atom with up to 3 other atoms bonded to it.
+
+W: Shake determinant < 0.0
+
+The determinant of the quadratic equation being solved for a single
+cluster specified by the fix shake command is numerically suspect.  LAMMPS
+will set it to 0.0 and continue.
+
+E: Shake determinant = 0.0
+
+The determinant of the matrix being solved for a single cluster
+specified by the fix shake command is numerically invalid.
+
+*/
Common subdirectories: src/GPU and src_DFT-CES2/GPU
Common subdirectories: src/GRANULAR and src_DFT-CES2/GRANULAR
diff -uN src/grid.cpp src_DFT-CES2/grid.cpp
--- src/grid.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/grid.cpp	2025-02-11 06:42:37.279609891 +0900
@@ -0,0 +1,303 @@
+/* ----------------------------------------------------------------------
+   DFT-CES core subroutines. Written by H.-K. Lim
+   Copyright (C) 2016 M-design group @ KAIST
+------------------------------------------------------------------------- */
+
+#include "grid.h"
+#include "comm.h"
+#include "domain.h"
+#include "error.h"
+#include "fix_gridforce.h"
+#include "force.h"
+#include "memory.h"
+#include "update.h"
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include "blur.h"
+
+using namespace LAMMPS_NS;
+
+#define MAXLINE 1024
+
+/* ---------------------------------------------------------------------- */
+
+Grid::Grid(LAMMPS *lmp, int narg, char **arg) : Pointers(lmp) {
+  int me = comm->me;
+  int i;
+
+  natoms = 0;
+  atomns = NULL;
+  basis = NULL;
+  gvin = NULL;
+  gvout = NULL;
+  gvout_all = NULL;
+  cvin = NULL;
+  savedcube = NULL;
+  inputrhocube = NULL;
+
+  if (narg < 4)
+    error->all(FLERR, "Illegal grid command"); // e.g. n+1(# of input cubes) n'+5(# of output cubes) pot.cube|None rho_H.cube|None rho_O.cube hy.cube ox.cube repA.cube dipx.cube dipy.cube dipz.cube
+
+  if (strcmp(arg[2], "None") != 0) {
+    // read header until atom information
+    read_header(arg[2]);
+
+    if (gx[1] + gx[2] + gy[0] + gy[2] + gz[0] + gz[1] != 0)
+      error->all(FLERR, "Grid file is not orthorhombic"); // gx[0], gy[1], gz[2] are not zero.
+    if (me == 0) {
+      printf("Grid file will be parsed: %s\n", arg[2]);
+      printf("DFT-CES: # of atoms in grid: %d\n", natoms);
+      printf("DFT-CES: # of grid points: %d %d %d\n", gnx, gny, gnz);
+      printf("DFT-CES: grid spacing: %f %f %f Angs\n", gx[0], gy[1], gz[2]);
+    }
+    memory->grow(atomns, natoms, "grid:atomns");
+    memory->grow(basis, natoms, 3, "grid:basis");
+    memory->grow(gvin, gnx * gny * gnz, "grid:gvin");
+    // read atom and grid value information
+    read_content(arg[2]);
+  } else {
+    return;
+  }
+
+  nrhocubes = atoi(arg[0]) - 1;                    // arg[0] pot.cube rho_x.cube : n(rho cubes)+1(pot.cube)
+                                                   // parsing cube file of charge density.
+  if (strcmp(arg[3], "None") != 0) {               // int int pot.cube "the first rho cube"  at arg[3].
+                                                   // read header until atom information
+    inputrhocube = new char *[nrhocubes];          // cubefile for input QM rho cubes
+    for (int temp = 0; temp < nrhocubes; temp++) { // usually "nrhocubes" is 2.
+      inputrhocube[temp] = (char *)"empty";
+    }
+    for (int temp = 0; temp < nrhocubes; temp++) {
+      int n = strlen(arg[temp + 3] + 1);
+      inputrhocube[temp] = new char[n];
+      strcpy(inputrhocube[temp], arg[temp + 3]);
+      if (me == 0)
+        printf("Grid file will be parsed: %s\n", inputrhocube[temp]);
+    }
+    memory->grow(cvin, gnx * gny * gnz * nrhocubes, "grid:cvin");
+
+    // read atom and grid value information
+    read_chd(inputrhocube);
+  } else {
+    if (me == 0)
+      printf("charge density Grid file will not be parsed. \n");
+    return;
+  }
+  savetag = 1; // default is save
+  if (strcmp(arg[1], "0") == 0) {
+    savetag = 0; // don't save
+  }
+  if (savetag == 0) {
+    if (me == 0)
+      printf("Grid file will not be saved\n");
+  } else { // Grid file will be saved.
+
+    ncubes = atoi(arg[1]);
+    memory->grow(gvout, gnx * gny * gnz * (atoi(arg[1])), "grid:gvout"); // atoi(arg[0]) - 1 + 3 + tip4p_CES, +3 for dipx, dipy, dipz
+    if (me == 0)
+      memory->grow(gvout_all, gnx * gny * gnz * (atoi(arg[1])), "grid:gvout_all");
+
+    savedcube = new char *[ncubes];             // cubefile for save
+    for (int temp = 0; temp < ncubes; temp++) { // usually "ncubes" is 6.
+      savedcube[temp] = (char *)"empty";
+    }
+    for (int temp = 0; temp < ncubes; temp++) {
+      int n = strlen(arg[temp + nrhocubes + 3] + 1); // int(nrhocubes+1) int nrhocubes+1 "the first save cube" at arg[nrhocubes+3].
+      savedcube[temp] = new char[n];
+      strcpy(savedcube[temp], arg[temp + nrhocubes + 3]);
+      if (me == 0)
+        printf("grid will be saved in %s\n", savedcube[temp]);
+    }
+  }
+}
+/* ---------------------------------------------------------------------- */
+
+Grid::~Grid() {
+  memory->destroy(atomns);
+  memory->destroy(basis);
+  memory->destroy(gvin);
+  memory->destroy(gvout);
+  memory->destroy(gvout_all);
+  memory->destroy(cvin);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void Grid::read_header(char *filename) {
+  int me = comm->me;
+  FILE *fptr;
+  char line[MAXLINE];
+  double temp[4];
+
+  if (me == 0) {
+    fptr = fopen(filename, "r");
+    if (fptr == NULL) {
+      char str[128];
+      sprintf(str, "Cannot open grid file %s", filename);
+      error->one(FLERR, str);
+    }
+
+    fgets(line, MAXLINE, fptr);
+    fgets(line, MAXLINE, fptr); // skip first two rows
+    fgets(line, MAXLINE, fptr);
+    sscanf(line, "%d %lf %lf %lf", &natoms, &temp[0], &temp[1], &temp[2]);
+    fgets(line, MAXLINE, fptr);
+    sscanf(line, "%d %lf %lf %lf", &gnx, &gx[0], &gx[1], &gx[2]);
+    gx[0] *= 0.52917721; // bohr to angs
+    fgets(line, MAXLINE, fptr);
+    sscanf(line, "%d %lf %lf %lf", &gny, &gy[0], &gy[1], &gy[2]);
+    gy[1] *= 0.52917721;
+    fgets(line, MAXLINE, fptr);
+    sscanf(line, "%d %lf %lf %lf", &gnz, &gz[0], &gz[1], &gz[2]);
+    gz[2] *= 0.52917721;
+
+    fclose(fptr);
+  }
+
+  MPI_Bcast(&natoms, 1, MPI_INT, 0, world);
+  MPI_Bcast(&gnx, 1, MPI_INT, 0, world);
+  MPI_Bcast(&gny, 1, MPI_INT, 0, world);
+  MPI_Bcast(&gnz, 1, MPI_INT, 0, world);
+  MPI_Bcast(&gx[0], 3, MPI_DOUBLE, 0, world);
+  MPI_Bcast(&gy[0], 3, MPI_DOUBLE, 0, world);
+  MPI_Bcast(&gz[0], 3, MPI_DOUBLE, 0, world);
+}
+
+void Grid::read_content(char *filename) {
+  int me = comm->me;
+  FILE *fptr;
+  char line[MAXLINE], *str_ptr;
+  double temp;
+  int i, cnt;
+
+  if (me == 0) {
+    fptr = fopen(filename, "r");
+    for (i = 0; i < 6; i++)
+      fgets(line, MAXLINE, fptr);
+    for (i = 0; i < natoms; i++) {
+      fgets(line, MAXLINE, fptr);
+      sscanf(line, "%d %lf %lf %lf %lf", &atomns[i], &temp, &basis[i][0], &basis[i][1], &basis[i][2]);
+      basis[i][0] *= 0.52917721;
+      basis[i][1] *= 0.52917721;
+      basis[i][2] *= 0.52917721;
+    }
+    cnt = 0;
+    while (fgets(line, MAXLINE, fptr) != NULL) {
+      str_ptr = strtok(line, " ");
+      for (; str_ptr != NULL; cnt++) {
+        sscanf(str_ptr, "%lf", &gvin[cnt]);
+        gvin[cnt] *= 13.60569253; // Ry to eV
+        str_ptr = strtok(NULL, " ");
+      }
+    }
+    fclose(fptr);
+    printf("\n#######\nDFT-CES: %s has been parsed\n\n", filename);
+  }
+
+  MPI_Bcast(&atomns[0], natoms, MPI_INT, 0, world);
+  MPI_Bcast(&basis[0][0], 3 * natoms, MPI_DOUBLE, 0, world);
+  MPI_Bcast(&gvin[0], gnx * gny * gnz, MPI_DOUBLE, 0, world);
+}
+
+void Grid::read_chd(char **filename) // 
+{
+  int me = comm->me;
+  FILE *fptr;
+  char line[MAXLINE], *str_ptr;
+  int i, cnt;
+  int block = gnx * gny * gnz;
+  if (me == 0) {
+    for (int temp = 0; temp < nrhocubes; temp++) { //
+      fptr = fopen(filename[temp], "r");
+      if (fptr == NULL) {
+        char str[128];
+        sprintf(str, "Revised. Cannot open grid file %s", filename[temp]);
+        error->one(FLERR, str);
+      }
+      for (i = 0; i < 6; i++)
+        fgets(line, MAXLINE, fptr);
+      for (i = 0; i < natoms; i++) {
+        fgets(line, MAXLINE, fptr);
+      }
+      cnt = 0;
+      while (fgets(line, MAXLINE, fptr) != NULL) {
+        str_ptr = strtok(line, " ");
+        for (; str_ptr != NULL; cnt++) {
+          sscanf(str_ptr, "%lf", &cvin[block * temp + cnt]);
+          //		else if(temp ==1) sscanf(str_ptr,"%lf",&cvin[temp*gnx*gny*gnz+cnt]);
+          //		else if(temp ==2) sscanf(str_ptr,"%lf",&cvin[temp*gnx*gny*gnz+cnt]);
+          //		else if(temp ==3) sscanf(str_ptr,"%lf",&cvin[temp*gnx*gny*gnz+cnt]);
+          //		else if(temp ==4) sscanf(str_ptr,"%lf",&cvin[temp*gnx*gny*gnz+cnt]);
+          //		else if(temp ==5) sscanf(str_ptr,"%lf",&cvin[temp*gnx*gny*gnz+cnt]);
+          //		else if(temp ==6) sscanf(str_ptr,"%lf",&cvin[temp*gnx*gny*gnz+cnt]);
+          //		else if(temp ==7) sscanf(str_ptr,"%lf",&cvin[temp*gnx*gny*gnz+cnt]);
+          str_ptr = strtok(NULL, " ");
+        }
+      }
+      fclose(fptr);
+      printf("\n#######\nDFT-CES: %s has been parsed\n\n", filename[temp]);
+    }
+  } // open me == 0
+  MPI_Bcast(&cvin[0], nrhocubes * gnx * gny * gnz, MPI_DOUBLE, 0, world);
+  //  for (int temp=0;temp<nrhocubes;temp++){
+  //	  if(temp ==0) MPI_Bcast(&cvin[0],gnx*gny*gnz,MPI_DOUBLE,0,world);
+  //	  else if(temp ==1)  MPI_Bcast(&cvin1[0],gnx*gny*gnz,MPI_DOUBLE,0,world);
+  //          else if(temp ==2)  MPI_Bcast(&cvin2[0],gnx*gny*gnz,MPI_DOUBLE,0,world);
+  //          else if(temp ==3)  MPI_Bcast(&cvin3[0],gnx*gny*gnz,MPI_DOUBLE,0,world);
+  //          else if(temp ==4)  MPI_Bcast(&cvin4[0],gnx*gny*gnz,MPI_DOUBLE,0,world);
+  //  }
+}
+
+void Grid::save_grid(char **filename, int nsteps) {
+  int me = comm->me;
+  FILE *fptr;
+  int i, j, k, cnt;
+  int block;
+  block = gnx * gny * gnz;
+  MPI_Reduce(gvout, gvout_all, block * ncubes, MPI_DOUBLE, MPI_SUM, 0, world);
+  for (int temp = 0; temp < ncubes; temp++) {
+    //    if(temp ==0) MPI_Reduce(gvout0,gvout_all0,gnx*gny*gnz,MPI_DOUBLE,MPI_SUM,0,world);
+    //    else if(temp ==1) MPI_Reduce(gvout1,gvout_all1,gnx*gny*gnz,MPI_DOUBLE,MPI_SUM,0,world);
+    //    else if(temp ==2) MPI_Reduce(gvout2,gvout_all2,gnx*gny*gnz,MPI_DOUBLE,MPI_SUM,0,world);
+    //    else if(temp ==3) MPI_Reduce(gvout3,gvout_all3,gnx*gny*gnz,MPI_DOUBLE,MPI_SUM,0,world);
+    //    else if(temp ==4) MPI_Reduce(gvout4,gvout_all4,gnx*gny*gnz,MPI_DOUBLE,MPI_SUM,0,world);
+    //    else if(temp ==5) MPI_Reduce(gvout5,gvout_all5,gnx*gny*gnz,MPI_DOUBLE,MPI_SUM,0,world);
+    //    else if(temp ==6) MPI_Reduce(gvout6,gvout_all6,gnx*gny*gnz,MPI_DOUBLE,MPI_SUM,0,world);
+
+    if (me == 0) {
+      fptr = fopen(filename[temp], "w");
+      fprintf(fptr, "MDrho from DFT-CES\n");
+      fprintf(fptr, "ZYX, Bohr unit\n");
+      fprintf(fptr, "% 5d    0.000000    0.000000    0.000000\n", natoms);
+      fprintf(fptr, "% 5d% 12.6lf    0.000000    0.000000\n", gnx, gx[0] / 0.52917721);
+      fprintf(fptr, "% 5d    0.000000% 12.6lf    0.000000\n", gny, gy[1] / 0.52917721);
+      fprintf(fptr, "% 5d    0.000000    0.000000% 12.6lf\n", gnz, gz[2] / 0.52917721);
+      for (i = 0; i < natoms; i++) {
+        fprintf(fptr, "% 5d% 12.6lf% 12.6lf% 12.6lf% 12.6lf\n", atomns[i], (double)atomns[i], basis[i][0] / 0.52917721, basis[i][1] / 0.52917721, basis[i][2] / 0.52917721);
+      }
+      for (i = 0; i < gnx; i++) {
+        for (j = 0; j < gny; j++) {
+          cnt = 0;
+          for (k = 0; k < gnz; k++) {
+            fprintf(fptr, "% 13.5lE", gvout_all[block * temp + k + j * gnz + i * gnz * gny] * pow(0.52917721, 3) / (nsteps + 1));
+            //            if(temp ==0) fprintf(fptr,"% 13.5lE",gvout_all[block*temp+k+j*gnz+i*gnz*gny]*pow(0.52917721,3)/(nsteps+1));
+            //            else if(temp ==1) fprintf(fptr,"% 13.5lE",gvout_all[block*temp+k+j*gnz+i*gnz*gny]*pow(0.52917721,3)/(nsteps+1));
+            //            else if(temp ==2) fprintf(fptr,"% 13.5lE",gvout_all[block*temp+k+j*gnz+i*gnz*gny]*pow(0.52917721,3)/(nsteps+1));
+            //            else if(temp ==3) fprintf(fptr,"% 13.5lE",gvout_all[block*temp+k+j*gnz+i*gnz*gny]*pow(0.52917721,3)/(nsteps+1));
+            //            else if(temp ==4) fprintf(fptr,"% 13.5lE",gvout_all[block*temp+k+j*gnz+i*gnz*gny]*pow(0.52917721,3)/(nsteps+1));
+            //            else if(temp ==5) fprintf(fptr,"% 13.5lE",gvout_all[block*temp+k+j*gnz+i*gnz*gny]*pow(0.52917721,3)/(nsteps+1));
+            //            else if(temp ==6) fprintf(fptr,"% 13.5lE",gvout_all[block*temp+k+j*gnz+i*gnz*gny]*pow(0.52917721,3)/(nsteps+1));
+            if (cnt % 6 == 5 && k < gnz - 1)
+              fprintf(fptr, "\n");
+            cnt++;
+          }
+          fprintf(fptr, "\n");
+        }
+      }
+      fclose(fptr);
+      // printf("\n#######\nDFT-CES: MDrho.cube has been successfully saved\n\n");
+      printf("\n#######\nDFT-CES: %s has been successfully saved\n\n", filename[temp]);
+    }
+  }
+}
diff -uN src/grid.h src_DFT-CES2/grid.h
--- src/grid.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/grid.h	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,44 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   DFT-CES core subroutines. Written by H.-K. Lim
+   Copyright (C) 2016 M-design group @ KAIST
+------------------------------------------------------------------------- */
+
+#ifndef LMP_GRID_H
+#define LMP_GRID_H
+
+#include "pointers.h"
+
+namespace LAMMPS_NS {
+
+class Grid : protected Pointers {
+ public:
+  int ncubes;    		                                     // number of output cubefiles
+  int nrhocubes;    		                                     // number of input QM rho cubefiles after gaussian convolution
+  int savetag;			                                     // save CES grid or not	
+  char **savedcube;                                                  // cubefile for save
+  char **inputrhocube;                                               // cubefile for save
+  int gnx, gny, gnz;                                                 // # of grid points in 3 dim
+  double gx[3],gy[3],gz[3];                                          // grid spacing vectors of (unit: Ang)
+  int natoms;                                                        // # of atoms
+	int tip4p_CES;
+  int *atomns;                                                       // atomic numbers for each atom
+  double **basis;                                                    // cartesian coords of each atom (unit: Ang)
+                                                                     // within unit cell (0 <= coord < 1)
+  double *gvin;                                                      // grid values from QM pot (unit: Ry)
+//  double *gvout0,*gvout1,*gvout2,*gvout3,*gvout4,*gvout5,*gvout6;                    // grid values for MD rho  (unit: Ry)
+//  double *gvout_all0,*gvout_all1,*gvout_all2,*gvout_all3,*gvout_all4,*gvout_all5,*gvout_all6;// grid values for MD rho  (unit: Ry)
+  double *gvout,*gvout_all;
+//  double *cvin0,*cvin1,*cvin2,*cvin3,*cvin4;                                                      // grid values from QM rho (unit: ebohr-3)
+  double *cvin;
+  Grid(class LAMMPS *, int, char **);
+  ~Grid();
+  void read_header(char *);
+  void read_content(char *);
+  void read_chd(char **);
+  void save_grid(char **, int);
+};
+
+}
+
+#endif
+
diff -uN src/input.cpp src_DFT-CES2/input.cpp
--- src/input.cpp	2024-04-23 22:12:52.623241438 +0900
+++ src_DFT-CES2/input.cpp	2025-02-11 06:42:37.186608993 +0900
@@ -802,6 +802,9 @@
   else if (!strcmp(command,"kspace_modify")) kspace_modify();
   else if (!strcmp(command,"kspace_style")) kspace_style();
   else if (!strcmp(command,"lattice")) lattice();
+// DFT-CES start
+  else if (!strcmp(command,"grid")) grid();
+// DFT-CES end
   else if (!strcmp(command,"mass")) mass();
   else if (!strcmp(command,"min_modify")) min_modify();
   else if (!strcmp(command,"min_style")) min_style();
@@ -1620,6 +1623,13 @@
   domain->set_lattice(narg,arg);
 }
 
+// DFT-CES start
+void Input::grid()
+{
+  domain->set_grid(narg,arg);
+}
+// DFT-CES end
+
 /* ---------------------------------------------------------------------- */
 
 void Input::mass()
diff -uN src/input.h src_DFT-CES2/input.h
--- src/input.h	2024-04-23 22:12:52.674241877 +0900
+++ src_DFT-CES2/input.h	2025-02-11 06:42:37.181608945 +0900
@@ -111,6 +111,9 @@
   void kspace_modify();
   void kspace_style();
   void lattice();
+// DFT-CES start
+  void grid();
+// DFT-CES end
   void mass();
   void min_modify();
   void min_style();
Common subdirectories: src/KIM and src_DFT-CES2/KIM
Common subdirectories: src/KOKKOS and src_DFT-CES2/KOKKOS
Common subdirectories: src/KSPACE and src_DFT-CES2/KSPACE
Binary files src/lmp_mpi and src_DFT-CES2/lmp_mpi differ
Binary files src/lmp_serial and src_DFT-CES2/lmp_serial differ
Common subdirectories: src/MAKE and src_DFT-CES2/MAKE
diff -uN src/Makefile.package src_DFT-CES2/Makefile.package
--- src/Makefile.package	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/Makefile.package	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,12 @@
+# Settings for libraries used by specific LAMMPS packages
+# this file is auto-edited when those packages are included/excluded
+
+PKG_INC =   
+PKG_PATH =  
+PKG_LIB =   
+PKG_CPP_DEPENDS = 
+PKG_LINK_DEPENDS = 
+
+PKG_SYSINC =  
+PKG_SYSLIB =  
+PKG_SYSPATH = 
diff -uN src/Makefile.package.settings src_DFT-CES2/Makefile.package.settings
--- src/Makefile.package.settings	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/Makefile.package.settings	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,4 @@
+# Makefile settings generated by libraries used by specific LAMMPS packages
+# this file is auto-edited when those packages are included/excluded
+
+
Common subdirectories: src/MANYBODY and src_DFT-CES2/MANYBODY
Common subdirectories: src/MC and src_DFT-CES2/MC
Common subdirectories: src/MEAM and src_DFT-CES2/MEAM
Common subdirectories: src/MISC and src_DFT-CES2/MISC
Common subdirectories: src/MOLECULE and src_DFT-CES2/MOLECULE
Common subdirectories: src/MPIIO and src_DFT-CES2/MPIIO
Common subdirectories: src/MSCG and src_DFT-CES2/MSCG
Common subdirectories: src/Obj_mpi and src_DFT-CES2/Obj_mpi
Common subdirectories: src/Obj_serial and src_DFT-CES2/Obj_serial
Common subdirectories: src/OPT and src_DFT-CES2/OPT
diff -uN src/pair_bjdisp_coul_long.cpp src_DFT-CES2/pair_bjdisp_coul_long.cpp
--- src/pair_bjdisp_coul_long.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_bjdisp_coul_long.cpp	2025-02-11 06:42:37.253609640 +0900
@@ -0,0 +1,555 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "pair_bjdisp_coul_long.h"
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "kspace.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "math_const.h"
+#include "memory.h"
+#include "error.h"
+#include "update.h"
+
+using namespace LAMMPS_NS;
+using namespace MathConst;
+
+#define EWALD_F   1.12837917
+#define EWALD_P   0.3275911
+#define A1        0.254829592
+#define A2       -0.284496736
+#define A3        1.421413741
+#define A4       -1.453152027
+#define A5        1.061405429
+#define newb		2.1
+#define PI		  3.141592
+
+/* ---------------------------------------------------------------------- */
+
+PairBjdispCoulLong::PairBjdispCoulLong(LAMMPS *lmp) : Pair(lmp)
+{
+  ewaldflag = pppmflag = 1;
+  writedata = 1;
+  ftable = NULL;
+}
+
+/* ---------------------------------------------------------------------- */
+
+PairBjdispCoulLong::~PairBjdispCoulLong()
+{
+  if (!copymode) {
+    if (allocated) {
+      memory->destroy(setflag);
+      memory->destroy(cutsq);
+      memory->destroy(cut_lj);
+      memory->destroy(cut_ljsq);
+      memory->destroy(a);
+      memory->destroy(rho);
+      memory->destroy(c);
+      memory->destroy(rhoinv);
+      memory->destroy(buck1);
+      memory->destroy(buck2);
+      memory->destroy(offset);
+    }
+    if (ftable) free_tables();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::compute(int eflag, int vflag)
+{
+  int i,j,ii,jj,inum,jnum,itable,itype,jtype;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul,fpair,tmpx,tmpy,tmpz;
+  double fraction,table;
+  double rsq,r2inv,r6,r6inv,forcecoul,forcebuck,factor_coul,factor_lj;
+  double grij,expm2,prefactor,t,erfc;
+  double r;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = ecoul = 0.0;
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+
+  double **x = atom->x;
+  double **f = atom->f;
+  double *q = atom->q;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  int nsteps = update->nsteps;
+  double *special_coul = force->special_coul;
+  double *special_lj = force->special_lj;
+  int newton_pair = force->newton_pair;
+  double qqrd2e = force->qqrd2e;
+
+  inum = list->inum;
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        if (rsq < cut_coulsq) {
+          if (!ncoultablebits || rsq <= tabinnersq) {
+            r = sqrt(rsq);
+            grij = g_ewald * r;
+            expm2 = exp(-grij*grij);
+            t = 1.0 / (1.0 + EWALD_P*grij);
+            erfc = t * (A1+t*(A2+t*(A3+t*(A4+t*A5)))) * expm2;
+            prefactor = qqrd2e * qtmp*q[j]/r;
+            forcecoul = prefactor * (erfc + EWALD_F*grij*expm2);
+            if (factor_coul < 1.0) forcecoul -= (1.0-factor_coul)*prefactor;
+          } else {
+            union_int_float_t rsq_lookup;
+            rsq_lookup.f = rsq;
+            itable = rsq_lookup.i & ncoulmask;
+            itable >>= ncoulshiftbits;
+            fraction = (rsq_lookup.f - rtable[itable]) * drtable[itable];
+            table = ftable[itable] + fraction*dftable[itable];
+            forcecoul = qtmp*q[j] * table;
+            if (factor_coul < 1.0) {
+              table = ctable[itable] + fraction*dctable[itable];
+              prefactor = qtmp*q[j] * table;
+              forcecoul -= (1.0-factor_coul)*prefactor;
+            }
+          }
+        } else forcecoul = 0.0; //if
+
+        if (rsq < cut_ljsq[itype][jtype]) {
+          r = sqrt(rsq);
+				  r6 = rsq*rsq*rsq;
+          r6inv = 1.0/(r6+rhoinv[itype][jtype]);
+    		  forcebuck = -1*buck2[itype][jtype]*r6inv*r6inv*r6;
+        } else forcebuck = 0.0;
+        fpair = (forcecoul + factor_lj*forcebuck) * r2inv;
+
+				tmpx = delx*fpair; 
+				tmpy = dely*fpair; 
+				tmpz = delz*fpair;
+        f[i][0] += tmpx;
+        f[i][1] += tmpy;
+        f[i][2] += tmpz;
+
+        if (newton_pair || j < nlocal) {
+				  tmpx = delx*fpair; 
+				  tmpy = dely*fpair; 
+				  tmpz = delz*fpair;
+          f[j][0] -= tmpx;
+          f[j][1] -= tmpy;
+          f[j][2] -= tmpz;
+        }
+
+        if (eflag) {
+          if (rsq < cut_coulsq) {
+            if (!ncoultablebits || rsq <= tabinnersq) {
+              ecoul = prefactor*erfc;
+			}
+            else {
+              table = etable[itable] + fraction*detable[itable];
+              ecoul = qtmp*q[j] * table;
+			}
+            if (factor_coul < 1.0) ecoul -= (1.0-factor_coul)*prefactor;
+          } else ecoul = 0.0;
+          if (rsq < cut_ljsq[itype][jtype]) {
+            evdwl = -1*c[itype][jtype]*(1.0/(r6+rhoinv[itype][jtype])) -
+              offset[itype][jtype];
+            evdwl *= factor_lj;
+          } else evdwl = 0.0;
+        }
+
+        if (evflag) ev_tally(i,j,nlocal,newton_pair,
+                             evdwl,ecoul,fpair,delx,dely,delz);
+      } // rsq < cutsq[itype][jtype]
+    }// jj loop
+
+  }// ii loop
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
+
+/* ----------------------------------------------------------------------
+   allocate all arrays
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::allocate()
+{
+  allocated = 1;
+  int n = atom->ntypes;
+
+  memory->create(setflag,n+1,n+1,"pair:setflag");
+  for (int i = 1; i <= n; i++)
+    for (int j = i; j <= n; j++)
+      setflag[i][j] = 0;
+
+  memory->create(cutsq,n+1,n+1,"pair:cutsq");
+  memory->create(cut_lj,n+1,n+1,"pair:cut_lj");
+  memory->create(cut_ljsq,n+1,n+1,"pair:cut_ljsq");
+  memory->create(a,n+1,n+1,"pair:a");
+  memory->create(rho,n+1,n+1,"pair:rho");
+  memory->create(c,n+1,n+1,"pair:c");
+  memory->create(rhoinv,n+1,n+1,"pair:rhoinv"); //not rhoinv. a^6
+  memory->create(buck1,n+1,n+1,"pair:buck1");
+  memory->create(buck2,n+1,n+1,"pair:buck2");
+  memory->create(offset,n+1,n+1,"pair:offset");
+}
+
+/* ----------------------------------------------------------------------
+   global settings
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::settings(int narg, char **arg)
+{
+  if (narg < 1 || narg > 2) error->all(FLERR,"Illegal pair_style command");
+
+  cut_lj_global = force->numeric(FLERR,arg[0]);
+  if (narg == 1) cut_coul = cut_lj_global;
+  else cut_coul = force->numeric(FLERR,arg[1]);
+
+  // reset cutoffs that have been explicitly set
+
+  if (allocated) {
+    int i,j;
+    for (i = 1; i <= atom->ntypes; i++)
+      for (j = i; j <= atom->ntypes; j++)
+        if (setflag[i][j]) cut_lj[i][j] = cut_lj_global;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   set coeffs for one or more type pairs
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::coeff(int narg, char **arg)
+{
+  if (narg < 5 || narg > 6)
+    error->all(FLERR,"Incorrect args for pair coefficients");
+  if (!allocated) allocate();
+
+  int ilo,ihi,jlo,jhi;
+  force->bounds(FLERR,arg[0],atom->ntypes,ilo,ihi);
+  force->bounds(FLERR,arg[1],atom->ntypes,jlo,jhi);
+
+  double a_one = force->numeric(FLERR,arg[2]);
+  double rho_one = force->numeric(FLERR,arg[3]); // scaling factor
+  if (rho_one < 0) error->all(FLERR,"Incorrect args for pair coefficients");
+  double c_one = force->numeric(FLERR,arg[4]);
+
+  double cut_lj_one = cut_lj_global;
+  if (narg == 6) cut_lj_one = force->numeric(FLERR,arg[5]);
+
+  int count = 0;
+  for (int i = ilo; i <= ihi; i++) {
+    for (int j = MAX(jlo,i); j <= jhi; j++) {
+      a[i][j] = a_one;
+      rho[i][j] = rho_one;
+      c[i][j] = c_one*rho_one;
+      cut_lj[i][j] = cut_lj_one;
+      setflag[i][j] = 1;
+      count++;
+    }
+  }
+
+  if (count == 0) error->all(FLERR,"Incorrect args for pair coefficients");
+}
+
+/* ----------------------------------------------------------------------
+   init for one type pair i,j and corresponding j,i
+------------------------------------------------------------------------- */
+
+double PairBjdispCoulLong::init_one(int i, int j)
+{
+  if (setflag[i][j] == 0) error->all(FLERR,"All pair coeffs are not set");
+
+  double cut = MAX(cut_lj[i][j],cut_coul);
+  double unit2angs = 0.52917721; 
+  double unit2kcalmol = 13.77929 ; // Eh a0^6 to kcal/mol Angs^6
+  cut_ljsq[i][j] = cut_lj[i][j] * cut_lj[i][j];
+
+  double r0ij = pow((sqrt(2/PI)*a[i][j]/3),1./3);
+  rhoinv[i][j] = pow((newb*r0ij),6.0); 
+  buck1[i][j] = 0;
+  buck2[i][j] = 6.0*c[i][j];
+
+  if (offset_flag && (cut_lj[i][j] > 0.0)) {
+    offset[i][j] = -1*c[i][j]/(pow(cut_lj[i][j],6.0)+rhoinv[i][j]);
+  } else offset[i][j] = 0.0;
+
+  cut_ljsq[j][i] = cut_ljsq[i][j];
+  a[j][i] = a[i][j];
+  c[j][i] = c[i][j]; 
+  rhoinv[j][i] = rhoinv[i][j];
+  rho[j][i] = rho[i][j];
+  buck1[j][i] = buck1[i][j]; 
+  buck2[j][i] = buck2[i][j]; 
+  offset[j][i] = offset[i][j];
+
+  // compute I,J contribution to long-range tail correction
+  // count total # of atoms of type I and J via Allreduce
+
+  if (tail_flag) {
+    int *type = atom->type;
+    int nlocal = atom->nlocal;
+
+    double count[2],all[2];
+    count[0] = count[1] = 0.0;
+    for (int k = 0; k < nlocal; k++) {
+      if (type[k] == i) count[0] += 1.0;
+      if (type[k] == j) count[1] += 1.0;
+    }
+    MPI_Allreduce(count,all,2,MPI_DOUBLE,MPI_SUM,world);
+  }
+
+  return cut;
+}
+
+/* ----------------------------------------------------------------------
+   init specific to this pair style
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::init_style()
+{
+  cut_coulsq = cut_coul * cut_coul;
+
+  // insure use of KSpace long-range solver, set g_ewald
+
+  if (force->kspace == NULL)
+    error->all(FLERR,"Pair style requires a KSpace style");
+  g_ewald = force->kspace->g_ewald;
+
+	if (!atom->q_flag){
+    error->warning(FLERR,"Pair style bjdisp/coul/long requires atom attribute q, Proceed without long-range calculation");
+  	g_ewald = 0;
+	}
+
+  neighbor->request(this,instance_me);
+
+  // setup force tables
+
+  if (ncoultablebits) init_tables(cut_coul,NULL);
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 writes to restart file
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::write_restart(FILE *fp)
+{
+  write_restart_settings(fp);
+
+  int i,j;
+  for (i = 1; i <= atom->ntypes; i++)
+    for (j = i; j <= atom->ntypes; j++) {
+      fwrite(&setflag[i][j],sizeof(int),1,fp);
+      if (setflag[i][j]) {
+        fwrite(&a[i][j],sizeof(double),1,fp);
+        fwrite(&rho[i][j],sizeof(double),1,fp);
+        fwrite(&c[i][j],sizeof(double),1,fp);
+        fwrite(&cut_lj[i][j],sizeof(double),1,fp);
+      }
+    }
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 reads from restart file, bcasts
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::read_restart(FILE *fp)
+{
+  read_restart_settings(fp);
+
+  allocate();
+
+  int i,j;
+  int me = comm->me;
+  for (i = 1; i <= atom->ntypes; i++)
+    for (j = i; j <= atom->ntypes; j++) {
+      if (me == 0) fread(&setflag[i][j],sizeof(int),1,fp);
+      MPI_Bcast(&setflag[i][j],1,MPI_INT,0,world);
+      if (setflag[i][j]) {
+        if (me == 0) {
+          fread(&a[i][j],sizeof(double),1,fp);
+          fread(&rho[i][j],sizeof(double),1,fp);
+          fread(&c[i][j],sizeof(double),1,fp);
+          fread(&cut_lj[i][j],sizeof(double),1,fp);
+        }
+        MPI_Bcast(&a[i][j],1,MPI_DOUBLE,0,world);
+        MPI_Bcast(&rho[i][j],1,MPI_DOUBLE,0,world);
+        MPI_Bcast(&c[i][j],1,MPI_DOUBLE,0,world);
+        MPI_Bcast(&cut_lj[i][j],1,MPI_DOUBLE,0,world);
+      }
+    }
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 writes to restart file
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::write_restart_settings(FILE *fp)
+{
+  fwrite(&cut_lj_global,sizeof(double),1,fp);
+  fwrite(&cut_coul,sizeof(double),1,fp);
+  fwrite(&offset_flag,sizeof(int),1,fp);
+  fwrite(&mix_flag,sizeof(int),1,fp);
+  fwrite(&tail_flag,sizeof(int),1,fp);
+  fwrite(&ncoultablebits,sizeof(int),1,fp);
+  fwrite(&tabinner,sizeof(double),1,fp);
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 reads from restart file, bcasts
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::read_restart_settings(FILE *fp)
+{
+  if (comm->me == 0) {
+    fread(&cut_lj_global,sizeof(double),1,fp);
+    fread(&cut_coul,sizeof(double),1,fp);
+    fread(&offset_flag,sizeof(int),1,fp);
+    fread(&mix_flag,sizeof(int),1,fp);
+    fread(&tail_flag,sizeof(int),1,fp);
+    fread(&ncoultablebits,sizeof(int),1,fp);
+    fread(&tabinner,sizeof(double),1,fp);
+  }
+  MPI_Bcast(&cut_lj_global,1,MPI_DOUBLE,0,world);
+  MPI_Bcast(&cut_coul,1,MPI_DOUBLE,0,world);
+  MPI_Bcast(&offset_flag,1,MPI_INT,0,world);
+  MPI_Bcast(&mix_flag,1,MPI_INT,0,world);
+  MPI_Bcast(&tail_flag,1,MPI_INT,0,world);
+  MPI_Bcast(&ncoultablebits,1,MPI_INT,0,world);
+  MPI_Bcast(&tabinner,1,MPI_DOUBLE,0,world);
+}
+
+/* ----------------------------------------------------------------------
+   proc 0 writes to data file
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::write_data(FILE *fp)
+{
+  for (int i = 1; i <= atom->ntypes; i++)
+    fprintf(fp,"%d %g %g %g\n",i,a[i][i],rho[i][i],c[i][i]);
+}
+
+/* ----------------------------------------------------------------------
+   proc 0 writes all pairs to data file
+------------------------------------------------------------------------- */
+
+void PairBjdispCoulLong::write_data_all(FILE *fp)
+{
+  for (int i = 1; i <= atom->ntypes; i++)
+    for (int j = i; j <= atom->ntypes; j++)
+      fprintf(fp,"%d %d %g %g %g %g\n",i,j,
+              a[i][j],rho[i][j],c[i][j],cut_lj[i][j]);
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairBjdispCoulLong::single(int i, int j, int itype, int jtype,
+                                double rsq,
+                                double factor_coul, double factor_lj,
+                                double &fforce)
+{
+//  double r2inv,r6inv,r,rexp,grij,expm2,t,erfc,prefactor;
+  double r2inv,r6,r6inv,r,grij,expm2,t,erfc,prefactor;
+  double fraction,table,forcecoul,forcebuck,phicoul,phibuck;
+  int itable;
+
+  r2inv = 1.0/rsq;
+  if (rsq < cut_coulsq) {
+    if (!ncoultablebits || rsq <= tabinnersq) {
+      r = sqrt(rsq);
+      grij = g_ewald * r;
+      expm2 = exp(-grij*grij);
+      t = 1.0 / (1.0 + EWALD_P*grij);
+      erfc = t * (A1+t*(A2+t*(A3+t*(A4+t*A5)))) * expm2;
+      prefactor = force->qqrd2e * atom->q[i]*atom->q[j]/r;
+      forcecoul = prefactor * (erfc + EWALD_F*grij*expm2);
+      if (factor_coul < 1.0) forcecoul -= (1.0-factor_coul)*prefactor;
+    } else {
+      union_int_float_t rsq_lookup;
+      rsq_lookup.f = rsq;
+      itable = rsq_lookup.i & ncoulmask;
+      itable >>= ncoulshiftbits;
+      fraction = (rsq_lookup.f - rtable[itable]) * drtable[itable];
+      table = ftable[itable] + fraction*dftable[itable];
+      forcecoul = atom->q[i]*atom->q[j] * table;
+      if (factor_coul < 1.0) {
+        table = ctable[itable] + fraction*dctable[itable];
+        prefactor = atom->q[i]*atom->q[j] * table;
+        forcecoul -= (1.0-factor_coul)*prefactor;
+      }
+    }
+  } else forcecoul = 0.0;
+  if (rsq < cut_ljsq[itype][jtype]) {
+    r6 = rsq*rsq*rsq;
+    r6inv = 1.0/(r6 + rhoinv[itype][jtype]);
+    r = sqrt(rsq);
+    forcebuck = -1*buck2[itype][jtype]*r6inv*r6inv*r6;
+  } else forcebuck = 0.0;
+  fforce = (forcecoul + factor_lj*forcebuck) * r2inv;
+
+  double eng = 0.0;
+  if (rsq < cut_coulsq) {
+    if (!ncoultablebits || rsq <= tabinnersq)
+      phicoul = prefactor*erfc;
+    else {
+      table = etable[itable] + fraction*detable[itable];
+      phicoul = atom->q[i]*atom->q[j] * table;
+    }
+    if (factor_coul < 1.0) phicoul -= (1.0-factor_coul)*prefactor;
+    eng += phicoul;
+  }
+  if (rsq < cut_ljsq[itype][jtype]) {
+    phibuck = -1*c[itype][jtype]*(1.0/(r6+rhoinv[itype][jtype])) -
+      offset[itype][jtype];
+    eng += factor_lj*phibuck;
+  }
+  return eng;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void *PairBjdispCoulLong::extract(const char *str, int &dim)
+{
+  dim = 0;
+  if (strcmp(str,"cut_coul") == 0) return (void *) &cut_coul;
+  return NULL;
+}
diff -uN src/pair_bjdisp_coul_long.h src_DFT-CES2/pair_bjdisp_coul_long.h
--- src/pair_bjdisp_coul_long.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_bjdisp_coul_long.h	2025-02-11 06:42:37.253609640 +0900
@@ -0,0 +1,88 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(bjdisp/coul/long,PairBjdispCoulLong)
+
+#else
+
+#ifndef LMP_PAIR_BJDISP_COUL_LONG_H
+#define LMP_PAIR_BJDISP_COUL_LONG_H
+
+#include "pair.h"
+
+namespace LAMMPS_NS {
+
+class PairBjdispCoulLong : public Pair {
+ public:
+  PairBjdispCoulLong(class LAMMPS *);
+  virtual ~PairBjdispCoulLong();
+  virtual void compute(int, int);
+  void settings(int, char **);
+  void coeff(int, char **);
+  void init_style();
+  double init_one(int, int);
+  void write_restart(FILE *);
+  void read_restart(FILE *);
+  void write_restart_settings(FILE *);
+  void read_restart_settings(FILE *);
+  void write_data(FILE *);
+  void write_data_all(FILE *);
+  virtual double single(int, int, int, int, double, double, double, double &);
+  virtual void *extract(const char *, int &);
+
+ protected:
+  double cut_lj_global;
+  double **cut_lj,**cut_ljsq;
+  double cut_coul,cut_coulsq;
+  double **a,**rho,**c;
+  double **rhoinv,**buck1,**buck2,**offset;
+
+  double *cut_respa;
+  double g_ewald;
+
+  virtual void allocate();
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Incorrect args for pair coefficients
+
+Self-explanatory.  Check the input script or data file.
+
+E: All pair coeffs are not set
+
+All pair coefficients must be set in the data file or by the
+pair_coeff command before running a simulation.
+
+E: Pair style buck/coul/long requires atom attribute q
+
+The atom style defined does not have these attributes.
+
+E: Pair style requires a KSpace style
+
+No kspace style is defined.
+
+*/
diff -uN src/pair_bjdisp.cpp src_DFT-CES2/pair_bjdisp.cpp
--- src/pair_bjdisp.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_bjdisp.cpp	2025-02-11 06:42:37.253609640 +0900
@@ -0,0 +1,427 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Eduardo Bringa (LLNL)
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "pair_bjdisp.h"
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "math_const.h"
+#include "memory.h"
+#include "error.h"
+#include "update.h"
+
+using namespace LAMMPS_NS;
+using namespace MathConst;
+#define newb		2.1
+#define PI		  3.141592
+
+/* ---------------------------------------------------------------------- */
+
+PairBjdisp::PairBjdisp(LAMMPS *lmp) : Pair(lmp)
+{
+  writedata = 1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+PairBjdisp::~PairBjdisp()
+{
+  if (!copymode) {
+    memory->destroy(setflag);
+    memory->destroy(cutsq);
+
+    memory->destroy(cut_lj);
+    memory->destroy(cut_ljsq);
+    memory->destroy(a);
+    memory->destroy(rho);
+    memory->destroy(c);
+    memory->destroy(rhoinv);
+    memory->destroy(buck1);
+    memory->destroy(buck2);
+    memory->destroy(offset);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairBjdisp::compute(int eflag, int vflag)
+{
+  int i,j,ii,jj,inum,jnum,itype,jtype;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul,fpair,tmpx,tmpy,tmpz;
+  double rsq,r2inv,r6,r6inv,forcebuck,factor_lj;
+  double r;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = ecoul = 0.0;
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+
+  double **x = atom->x;
+  double **f = atom->f;
+  double *q = atom->q;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  int nsteps = update->nsteps;
+  double *special_lj = force->special_lj;
+  int newton_pair = force->newton_pair;
+  double qqrd2e = force->qqrd2e;
+
+  inum = list->inum;
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        r = sqrt(rsq);
+				r6 = rsq*rsq*rsq;
+        r6inv = 1.0/(r6+rhoinv[itype][jtype]);
+        forcebuck = -1*buck2[itype][jtype]*r6inv*r6inv*r6;
+			} else forcebuck = 0.0;
+
+      fpair = (factor_lj*forcebuck) * r2inv;
+			tmpx = delx*fpair; 
+			tmpy = dely*fpair; 
+			tmpz = delz*fpair;
+      f[i][0] += delx*fpair;
+      f[i][1] += dely*fpair;
+      f[i][2] += delz*fpair;
+      if (newton_pair || j < nlocal) {
+				tmpx = delx*fpair;
+				tmpy = dely*fpair;
+				tmpz = delz*fpair;
+				f[j][0] -= tmpx;
+				f[j][1] -= tmpy;
+				f[j][2] -= tmpz;
+			}
+      if (eflag) {
+        if (rsq < cutsq[itype][jtype]) {
+          evdwl = -1*c[itype][jtype]*(1.0/(r6+rhoinv[itype][jtype])) - offset[itype][jtype];
+          evdwl *= factor_lj;
+        } else evdwl = 0.0;
+      }
+			ecoul = 0.0;
+      if (evflag) ev_tally(i,j,nlocal,newton_pair,evdwl,ecoul,fpair,delx,dely,delz);
+    }
+  }
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
+
+/* ----------------------------------------------------------------------
+   allocate all arrays
+------------------------------------------------------------------------- */
+
+void PairBjdisp::allocate()
+{
+  allocated = 1;
+  int n = atom->ntypes;
+
+  memory->create(setflag,n+1,n+1,"pair:setflag");
+
+  for (int i = 1; i <= n; i++)
+    for (int j = i; j <= n; j++)
+      setflag[i][j] = 0;
+
+  memory->create(cutsq,n+1,n+1,"pair:cutsq");
+
+  memory->create(cut_lj,n+1,n+1,"pair:cut_lj");
+  memory->create(cut_ljsq,n+1,n+1,"pair:cut_ljsq");
+  memory->create(a,n+1,n+1,"pair:a");
+  memory->create(rho,n+1,n+1,"pair:rho");
+  memory->create(c,n+1,n+1,"pair:c");
+  memory->create(rhoinv,n+1,n+1,"pair:rhoinv");
+  memory->create(buck1,n+1,n+1,"pair:buck1");
+  memory->create(buck2,n+1,n+1,"pair:buck2");
+  memory->create(offset,n+1,n+1,"pair:offset");
+}
+
+/* ----------------------------------------------------------------------
+   global settings
+------------------------------------------------------------------------- */
+
+void PairBjdisp::settings(int narg, char **arg)
+{
+  if (narg < 1 || narg > 2) error->all(FLERR,"Illegal pair_style command");
+
+  cut_lj_global = force->numeric(FLERR,arg[0]);
+
+  // reset cutoffs that have been explicitly set
+
+  if (allocated) {
+    int i,j;
+    for (i = 1; i <= atom->ntypes; i++)
+      for (j = i; j <= atom->ntypes; j++)
+        if (setflag[i][j]) {
+          cut_lj[i][j] = cut_lj_global;
+        }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   set coeffs for one or more type pairs
+------------------------------------------------------------------------- */
+
+void PairBjdisp::coeff(int narg, char **arg)
+{
+  if (narg < 5 || narg > 7)
+    error->all(FLERR,"Incorrect args for pair coefficients");
+  if (!allocated) allocate();
+
+  int ilo,ihi,jlo,jhi;
+  force->bounds(FLERR,arg[0],atom->ntypes,ilo,ihi);
+  force->bounds(FLERR,arg[1],atom->ntypes,jlo,jhi);
+
+  double a_one = force->numeric(FLERR,arg[2]);
+  double rho_one = force->numeric(FLERR,arg[3]);
+  if (rho_one < 0) error->all(FLERR,"Incorrect args for pair coefficients");
+  double c_one = force->numeric(FLERR,arg[4]);
+
+  double cut_lj_one = cut_lj_global;
+
+  int count = 0;
+  for (int i = ilo; i <= ihi; i++) {
+    for (int j = MAX(jlo,i); j <= jhi; j++) {
+      a[i][j] = a_one;
+      rho[i][j] = rho_one;
+      c[i][j] = c_one*rho_one;
+      cut_lj[i][j] = cut_lj_one;
+      setflag[i][j] = 1;
+      count++;
+    }
+  }
+
+  if (count == 0) error->all(FLERR,"Incorrect args for pair coefficients");
+}
+
+/* ----------------------------------------------------------------------
+   init specific to this pair style
+------------------------------------------------------------------------- */
+
+void PairBjdisp::init_style()
+{
+  neighbor->request(this,instance_me);
+}
+
+/* ----------------------------------------------------------------------
+   init for one type pair i,j and corresponding j,i
+------------------------------------------------------------------------- */
+
+double PairBjdisp::init_one(int i, int j)
+{
+  if (setflag[i][j] == 0) error->all(FLERR,"All pair coeffs are not set");
+
+  double cut = cut_lj[i][j];
+  double unit2angs = 0.52917721; 
+  double unit2kcalmol = 13.77929 ; // Eh a0^6 to kcal/mol Angs^6
+  cut_ljsq[i][j] = cut_lj[i][j] * cut_lj[i][j];
+
+  double r0ij = pow((sqrt(2/PI)*a[i][j]/3),1./3);
+  rhoinv[i][j] = pow((newb*r0ij),6.0);
+  buck1[i][j] = 0;
+  buck2[i][j] = 6.0*c[i][j];
+
+  if (offset_flag && (cut_lj[i][j] > 0.0)) {
+    offset[i][j] = -1*c[i][j]/(pow(cut_lj[i][j],6.0)+rhoinv[i][j]);
+  } else offset[i][j] = 0.0;
+
+  cut_ljsq[j][i] = cut_ljsq[i][j];
+  a[j][i] = a[i][j];
+  c[j][i] = c[i][j];
+  rhoinv[j][i] = rhoinv[i][j];
+  rho[j][i] = rho[i][j];
+  buck1[j][i] = buck1[i][j];
+  buck2[j][i] = buck2[i][j];
+  offset[j][i] = offset[i][j];
+
+  // compute I,J contribution to long-range tail correction
+  // count total # of atoms of type I and J via Allreduce
+
+  if (tail_flag) {
+    int *type = atom->type;
+    int nlocal = atom->nlocal;
+
+    double count[2],all[2];
+    count[0] = count[1] = 0.0;
+    for (int k = 0; k < nlocal; k++) {
+      if (type[k] == i) count[0] += 1.0;
+      if (type[k] == j) count[1] += 1.0;
+    }
+    MPI_Allreduce(count,all,2,MPI_DOUBLE,MPI_SUM,world);
+	}
+
+  return cut;
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 writes to restart file
+------------------------------------------------------------------------- */
+
+void PairBjdisp::write_restart(FILE *fp)
+{
+  write_restart_settings(fp);
+
+  int i,j;
+  for (i = 1; i <= atom->ntypes; i++)
+    for (j = i; j <= atom->ntypes; j++) {
+      fwrite(&setflag[i][j],sizeof(int),1,fp);
+      if (setflag[i][j]) {
+        fwrite(&a[i][j],sizeof(double),1,fp);
+        fwrite(&rho[i][j],sizeof(double),1,fp);
+        fwrite(&c[i][j],sizeof(double),1,fp);
+        fwrite(&cut_lj[i][j],sizeof(double),1,fp);
+      }
+    }
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 reads from restart file, bcasts
+------------------------------------------------------------------------- */
+
+void PairBjdisp::read_restart(FILE *fp)
+{
+  read_restart_settings(fp);
+
+  allocate();
+
+  int i,j;
+  int me = comm->me;
+  for (i = 1; i <= atom->ntypes; i++)
+    for (j = i; j <= atom->ntypes; j++) {
+      if (me == 0) fread(&setflag[i][j],sizeof(int),1,fp);
+      MPI_Bcast(&setflag[i][j],1,MPI_INT,0,world);
+      if (setflag[i][j]) {
+        if (me == 0) {
+          fread(&a[i][j],sizeof(double),1,fp);
+          fread(&rho[i][j],sizeof(double),1,fp);
+          fread(&c[i][j],sizeof(double),1,fp);
+          fread(&cut_lj[i][j],sizeof(double),1,fp);
+        }
+        MPI_Bcast(&a[i][j],1,MPI_DOUBLE,0,world);
+        MPI_Bcast(&rho[i][j],1,MPI_DOUBLE,0,world);
+        MPI_Bcast(&c[i][j],1,MPI_DOUBLE,0,world);
+        MPI_Bcast(&cut_lj[i][j],1,MPI_DOUBLE,0,world);
+      }
+    }
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 writes to restart file
+------------------------------------------------------------------------- */
+
+void PairBjdisp::write_restart_settings(FILE *fp)
+{
+  fwrite(&cut_lj_global,sizeof(double),1,fp);
+  fwrite(&offset_flag,sizeof(int),1,fp);
+  fwrite(&mix_flag,sizeof(int),1,fp);
+  fwrite(&tail_flag,sizeof(int),1,fp);
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 reads from restart file, bcasts
+------------------------------------------------------------------------- */
+
+void PairBjdisp::read_restart_settings(FILE *fp)
+{
+  if (comm->me == 0) {
+    fread(&cut_lj_global,sizeof(double),1,fp);
+    fread(&offset_flag,sizeof(int),1,fp);
+    fread(&mix_flag,sizeof(int),1,fp);
+    fread(&tail_flag,sizeof(int),1,fp);
+  }
+  MPI_Bcast(&cut_lj_global,1,MPI_DOUBLE,0,world);
+  MPI_Bcast(&offset_flag,1,MPI_INT,0,world);
+  MPI_Bcast(&mix_flag,1,MPI_INT,0,world);
+  MPI_Bcast(&tail_flag,1,MPI_INT,0,world);
+}
+
+/* ----------------------------------------------------------------------
+   proc 0 writes to data file
+------------------------------------------------------------------------- */
+
+void PairBjdisp::write_data(FILE *fp)
+{
+  for (int i = 1; i <= atom->ntypes; i++)
+    fprintf(fp,"%d %g %g %g\n",i,a[i][i],rho[i][i],c[i][i]);
+}
+
+/* ----------------------------------------------------------------------
+   proc 0 writes all pairs to data file
+------------------------------------------------------------------------- */
+
+void PairBjdisp::write_data_all(FILE *fp)
+{
+  for (int i = 1; i <= atom->ntypes; i++)
+    for (int j = i; j <= atom->ntypes; j++)
+      fprintf(fp,"%d %d %g %g %g %g\n",i,j,
+              a[i][j],rho[i][j],c[i][j],cut_lj[i][j]);
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairBjdisp::single(int i, int j, int itype, int jtype,
+                               double rsq,
+                               double factor_lj,
+                               double &fforce)
+{
+  double r2inv,r6,r6inv,r,forcebuck,phibuck;
+
+  r2inv = 1.0/rsq;
+  if (rsq < cut_ljsq[itype][jtype]) {
+    r6 = rsq*rsq*rsq;
+    r6inv = 1.0/(r6 + rhoinv[itype][jtype]);
+    r = sqrt(rsq);
+    forcebuck = -1*buck2[itype][jtype]*r6inv*r6inv*r6;
+  } else forcebuck = 0.0;
+  fforce = (factor_lj*forcebuck) * r2inv;
+
+  double eng = 0.0;
+  if (rsq < cut_ljsq[itype][jtype]) {
+    phibuck = -1*c[itype][jtype]*(1.0/(r6+rhoinv[itype][jtype])) -
+      offset[itype][jtype];
+    eng += factor_lj*phibuck;
+  }
+  return eng;
+}
diff -uN src/pair_bjdisp.h src_DFT-CES2/pair_bjdisp.h
--- src/pair_bjdisp.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_bjdisp.h	2025-02-11 06:42:37.253609640 +0900
@@ -0,0 +1,79 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(bjdisp,PairBjdisp)
+
+#else
+
+#ifndef LMP_PAIR_BJDISP_H
+#define LMP_PAIR_BJDISP_H
+
+#include "pair.h"
+
+namespace LAMMPS_NS {
+
+class PairBjdisp : public Pair {
+ public:
+  PairBjdisp(class LAMMPS *);
+  virtual ~PairBjdisp();
+  virtual void compute(int, int);
+  virtual void settings(int, char **);
+  void coeff(int, char **);
+  virtual void init_style();
+  double init_one(int, int);
+  void write_restart(FILE *);
+  void read_restart(FILE *);
+  virtual void write_restart_settings(FILE *);
+  virtual void read_restart_settings(FILE *);
+  void write_data(FILE *);
+  void write_data_all(FILE *);
+  virtual double single(int, int, int, int, double, double, double &);
+
+ protected:
+  double cut_lj_global;
+  double **cut_lj,**cut_ljsq;
+  double **a,**rho,**c;
+  double **rhoinv,**buck1,**buck2,**offset;
+
+  virtual void allocate();
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: Illegal ... command
+
+Self-explanatory.  Check the input script syntax and compare to the
+documentation for the command.  You can use -echo screen as a
+command-line option when running LAMMPS to see the offending line.
+
+E: Incorrect args for pair coefficients
+
+Self-explanatory.  Check the input script or data file.
+
+E: Pair style buck/coul/cut requires atom attribute q
+
+The atom style defined does not have this attribute.
+
+E: All pair coeffs are not set
+
+All pair coefficients must be set in the data file or by the
+pair_coeff command before running a simulation.
+
+*/
diff -uN src/pair_buck_coul_long.cpp src_DFT-CES2/pair_buck_coul_long.cpp
--- src/pair_buck_coul_long.cpp	2024-04-23 22:12:52.617241387 +0900
+++ src_DFT-CES2/pair_buck_coul_long.cpp	2025-02-11 06:42:37.279609891 +0900
@@ -25,6 +25,7 @@
 #include "math_const.h"
 #include "memory.h"
 #include "error.h"
+#include "update.h"
 
 using namespace LAMMPS_NS;
 using namespace MathConst;
@@ -36,6 +37,8 @@
 #define A3        1.421413741
 #define A4       -1.453152027
 #define A5        1.061405429
+#define newb		2.1
+#define PI		  3.141592
 
 /* ---------------------------------------------------------------------- */
 
@@ -54,7 +57,6 @@
     if (allocated) {
       memory->destroy(setflag);
       memory->destroy(cutsq);
-
       memory->destroy(cut_lj);
       memory->destroy(cut_ljsq);
       memory->destroy(a);
@@ -74,11 +76,11 @@
 void PairBuckCoulLong::compute(int eflag, int vflag)
 {
   int i,j,ii,jj,inum,jnum,itable,itype,jtype;
-  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul,fpair;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul,fpair,tmpx,tmpy,tmpz;
   double fraction,table;
-  double rsq,r2inv,r6inv,forcecoul,forcebuck,factor_coul,factor_lj;
+  double rsq,r2inv,r6,r6inv,forcecoul,forcebuck,factor_coul,factor_lj;
   double grij,expm2,prefactor,t,erfc;
-  double r,rexp;
+  double r;
   int *ilist,*jlist,*numneigh,**firstneigh;
 
   evdwl = ecoul = 0.0;
@@ -90,6 +92,7 @@
   double *q = atom->q;
   int *type = atom->type;
   int nlocal = atom->nlocal;
+  int nsteps = update->nsteps;
   double *special_coul = force->special_coul;
   double *special_lj = force->special_lj;
   int newton_pair = force->newton_pair;
@@ -123,7 +126,6 @@
       delz = ztmp - x[j][2];
       rsq = delx*delx + dely*dely + delz*delz;
       jtype = type[j];
-
       if (rsq < cutsq[itype][jtype]) {
         r2inv = 1.0/rsq;
         if (rsq < cut_coulsq) {
@@ -154,34 +156,39 @@
 
         if (rsq < cut_ljsq[itype][jtype]) {
           r = sqrt(rsq);
-          r6inv = r2inv*r2inv*r2inv;
-          rexp = exp(-r*rhoinv[itype][jtype]);
-          forcebuck = buck1[itype][jtype]*r*rexp - buck2[itype][jtype]*r6inv;
+					r6 = rsq*rsq*rsq;
+          r6inv = 1.0/(r6+rhoinv[itype][jtype]);
+          forcebuck = -1*buck2[itype][jtype]*r6inv*r6inv*r6;
         } else forcebuck = 0.0;
-
         fpair = (forcecoul + factor_lj*forcebuck) * r2inv;
-
-        f[i][0] += delx*fpair;
-        f[i][1] += dely*fpair;
-        f[i][2] += delz*fpair;
+				tmpx = delx*fpair; 
+				tmpy = dely*fpair; 
+				tmpz = delz*fpair;
+        f[i][0] += tmpx;
+        f[i][1] += tmpy;
+        f[i][2] += tmpz;
         if (newton_pair || j < nlocal) {
-          f[j][0] -= delx*fpair;
-          f[j][1] -= dely*fpair;
-          f[j][2] -= delz*fpair;
+				  tmpx = delx*fpair; 
+				  tmpy = dely*fpair; 
+				  tmpz = delz*fpair;
+          f[j][0] -= tmpx;
+          f[j][1] -= tmpy;
+          f[j][2] -= tmpz;
         }
 
         if (eflag) {
           if (rsq < cut_coulsq) {
-            if (!ncoultablebits || rsq <= tabinnersq)
+            if (!ncoultablebits || rsq <= tabinnersq) {
               ecoul = prefactor*erfc;
+						}
             else {
               table = etable[itable] + fraction*detable[itable];
               ecoul = qtmp*q[j] * table;
-            }
+						}
             if (factor_coul < 1.0) ecoul -= (1.0-factor_coul)*prefactor;
           } else ecoul = 0.0;
           if (rsq < cut_ljsq[itype][jtype]) {
-            evdwl = a[itype][jtype]*rexp - c[itype][jtype]*r6inv -
+            evdwl = -1*c[itype][jtype]*(1.0/(r6+rhoinv[itype][jtype])) -
               offset[itype][jtype];
             evdwl *= factor_lj;
           } else evdwl = 0.0;
@@ -189,9 +196,10 @@
 
         if (evflag) ev_tally(i,j,nlocal,newton_pair,
                              evdwl,ecoul,fpair,delx,dely,delz);
-      }
-    }
-  }
+      } // rsq < cutsq[itype][jtype]
+    }// jj loop
+
+  }// ii loop
 
   if (vflag_fdotr) virial_fdotr_compute();
 }
@@ -217,7 +225,7 @@
   memory->create(a,n+1,n+1,"pair:a");
   memory->create(rho,n+1,n+1,"pair:rho");
   memory->create(c,n+1,n+1,"pair:c");
-  memory->create(rhoinv,n+1,n+1,"pair:rhoinv");
+  memory->create(rhoinv,n+1,n+1,"pair:rhoinv"); //not rhoinv. a^6 
   memory->create(buck1,n+1,n+1,"pair:buck1");
   memory->create(buck2,n+1,n+1,"pair:buck2");
   memory->create(offset,n+1,n+1,"pair:offset");
@@ -240,7 +248,7 @@
   if (allocated) {
     int i,j;
     for (i = 1; i <= atom->ntypes; i++)
-      for (j = i; j <= atom->ntypes; j++)
+      for (j = i+1; j <= atom->ntypes; j++)
         if (setflag[i][j]) cut_lj[i][j] = cut_lj_global;
   }
 }
@@ -261,7 +269,7 @@
 
   double a_one = force->numeric(FLERR,arg[2]);
   double rho_one = force->numeric(FLERR,arg[3]);
-  if (rho_one <= 0) error->all(FLERR,"Incorrect args for pair coefficients");
+  if (rho_one < 0) error->all(FLERR,"Incorrect args for pair coefficients");
   double c_one = force->numeric(FLERR,arg[4]);
 
   double cut_lj_one = cut_lj_global;
@@ -272,7 +280,7 @@
     for (int j = MAX(jlo,i); j <= jhi; j++) {
       a[i][j] = a_one;
       rho[i][j] = rho_one;
-      c[i][j] = c_one;
+      c[i][j] = c_one*rho_one;
       cut_lj[i][j] = cut_lj_one;
       setflag[i][j] = 1;
       count++;
@@ -291,23 +299,25 @@
   if (setflag[i][j] == 0) error->all(FLERR,"All pair coeffs are not set");
 
   double cut = MAX(cut_lj[i][j],cut_coul);
+  double unit2angs = 0.52917721; 
+  double unit2kcalmol = 13.77929 ; // Eh a0^6 to kcal/mol Angs^6
   cut_ljsq[i][j] = cut_lj[i][j] * cut_lj[i][j];
 
-  rhoinv[i][j] = 1.0/rho[i][j];
-  buck1[i][j] = a[i][j]/rho[i][j];
+  double r0ij = pow((sqrt(2/PI)*a[i][j]/3),1./3);
+  rhoinv[i][j] = pow((newb*r0ij),6.0); // (a1*sqrt(C8/C6)+a2)^6
+  buck1[i][j] = 0;
   buck2[i][j] = 6.0*c[i][j];
-
   if (offset_flag && (cut_lj[i][j] > 0.0)) {
-    double rexp = exp(-cut_lj[i][j]/rho[i][j]);
-    offset[i][j] = a[i][j]*rexp - c[i][j]/pow(cut_lj[i][j],6.0);
+    offset[i][j] = -1*c[i][j]/(pow(cut_lj[i][j],6.0)+rhoinv[i][j]);
   } else offset[i][j] = 0.0;
 
   cut_ljsq[j][i] = cut_ljsq[i][j];
   a[j][i] = a[i][j];
-  c[j][i] = c[i][j];
+  c[j][i] = c[i][j]; // alpha, atomic polarizability
   rhoinv[j][i] = rhoinv[i][j];
-  buck1[j][i] = buck1[i][j];
-  buck2[j][i] = buck2[i][j];
+  rho[j][i] = rho[i][j];
+  buck1[j][i] = buck1[i][j]; 
+  buck2[j][i] = buck2[i][j]; // C6 coefficient multiplied by 6
   offset[j][i] = offset[i][j];
 
   // compute I,J contribution to long-range tail correction
@@ -325,18 +335,6 @@
     }
     MPI_Allreduce(count,all,2,MPI_DOUBLE,MPI_SUM,world);
 
-    double rho1 = rho[i][j];
-    double rho2 = rho1*rho1;
-    double rho3 = rho2*rho1;
-    double rc = cut_lj[i][j];
-    double rc2 = rc*rc;
-    double rc3 = rc2*rc;
-    etail_ij = 2.0*MY_PI*all[0]*all[1]*
-      (a[i][j]*exp(-rc/rho1)*rho1*(rc2 + 2.0*rho1*rc + 2.0*rho2) -
-       c[i][j]/(3.0*rc3));
-    ptail_ij = (-1/3.0)*2.0*MY_PI*all[0]*all[1]*
-      (-a[i][j]*exp(-rc/rho1)*
-       (rc3 + 3.0*rho1*rc2 + 6.0*rho2*rc + 6.0*rho3) + 2.0*c[i][j]/rc3);
   }
 
   return cut;
@@ -486,7 +484,7 @@
                                 double factor_coul, double factor_lj,
                                 double &fforce)
 {
-  double r2inv,r6inv,r,rexp,grij,expm2,t,erfc,prefactor;
+  double r2inv,r6,r6inv,r,grij,expm2,t,erfc,prefactor;
   double fraction,table,forcecoul,forcebuck,phicoul,phibuck;
   int itable;
 
@@ -517,10 +515,10 @@
     }
   } else forcecoul = 0.0;
   if (rsq < cut_ljsq[itype][jtype]) {
-    r6inv = r2inv*r2inv*r2inv;
+    r6 = rsq*rsq*rsq;
+    r6inv = 1.0/(r6 + rhoinv[itype][jtype]);
     r = sqrt(rsq);
-    rexp = exp(-r*rhoinv[itype][jtype]);
-    forcebuck = buck1[itype][jtype]*r*rexp - buck2[itype][jtype]*r6inv;
+    forcebuck = -1*buck2[itype][jtype]*r6inv*r6inv*r6;
   } else forcebuck = 0.0;
   fforce = (forcecoul + factor_lj*forcebuck) * r2inv;
 
@@ -536,7 +534,7 @@
     eng += phicoul;
   }
   if (rsq < cut_ljsq[itype][jtype]) {
-    phibuck = a[itype][jtype]*rexp - c[itype][jtype]*r6inv -
+    phibuck = -1*c[itype][jtype]*(1.0/(r6+rhoinv[itype][jtype])) -
       offset[itype][jtype];
     eng += factor_lj*phibuck;
   }
diff -uN src/pair_eam_alloy_opt.cpp src_DFT-CES2/pair_eam_alloy_opt.cpp
--- src/pair_eam_alloy_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_eam_alloy_opt.cpp	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,34 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors:
+     James Fischer, High Performance Technologies, Inc.
+     Charles Cornwell, High Performance Technologies, Inc.
+     David Richie, Stone Ridge Technology
+     Vincent Natoli, Stone Ridge Technology
+------------------------------------------------------------------------- */
+
+#include "pair_eam_alloy_opt.h"
+
+using namespace LAMMPS_NS;
+
+/* ----------------------------------------------------------------------
+   multiple inheritance from two parent classes
+   invoke constructor of grandparent class, then of each parent
+   inherit optimized compute() from PairEAMOpt
+   inherit everything else from PairEAMAlloy
+------------------------------------------------------------------------- */
+
+PairEAMAlloyOpt::PairEAMAlloyOpt(LAMMPS *lmp) :
+  PairEAM(lmp), PairEAMAlloy(lmp), PairEAMOpt(lmp) {}
diff -uN src/pair_eam_alloy_opt.h src_DFT-CES2/pair_eam_alloy_opt.h
--- src/pair_eam_alloy_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_eam_alloy_opt.h	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,37 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(eam/alloy/opt,PairEAMAlloyOpt)
+
+#else
+
+#ifndef LMP_PAIR_EAM_ALLOY_OPT_H
+#define LMP_PAIR_EAM_ALLOY_OPT_H
+
+#include "pair_eam_alloy.h"
+#include "pair_eam_opt.h"
+
+namespace LAMMPS_NS {
+
+class PairEAMAlloyOpt : public PairEAMAlloy, public PairEAMOpt {
+ public:
+  PairEAMAlloyOpt(class LAMMPS *);
+  virtual ~PairEAMAlloyOpt() {}
+};
+
+}
+
+#endif
+#endif
diff -uN src/pair_eam_fs_opt.cpp src_DFT-CES2/pair_eam_fs_opt.cpp
--- src/pair_eam_fs_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_eam_fs_opt.cpp	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,34 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors:
+     James Fischer, High Performance Technologies, Inc.
+     Charles Cornwell, High Performance Technologies, Inc.
+     David Richie, Stone Ridge Technology
+     Vincent Natoli, Stone Ridge Technology
+------------------------------------------------------------------------- */
+
+#include "pair_eam_fs_opt.h"
+
+using namespace LAMMPS_NS;
+
+/* ----------------------------------------------------------------------
+   multiple inheritance from two parent classes
+   invoke constructor of grandparent class, then of each parent
+   inherit optimized compute() from PairEAMOpt
+   inherit everything else from PairEAMFS
+------------------------------------------------------------------------- */
+
+PairEAMFSOpt::PairEAMFSOpt(LAMMPS *lmp) :
+  PairEAM(lmp), PairEAMFS(lmp), PairEAMOpt(lmp) {}
diff -uN src/pair_eam_fs_opt.h src_DFT-CES2/pair_eam_fs_opt.h
--- src/pair_eam_fs_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_eam_fs_opt.h	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,37 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(eam/fs/opt,PairEAMFSOpt)
+
+#else
+
+#ifndef LMP_PAIR_EAM_FS_OPT_H
+#define LMP_PAIR_EAM_FS_OPT_H
+
+#include "pair_eam_fs.h"
+#include "pair_eam_opt.h"
+
+namespace LAMMPS_NS {
+
+class PairEAMFSOpt : public PairEAMFS, public PairEAMOpt {
+ public:
+  PairEAMFSOpt(class LAMMPS *);
+  virtual ~PairEAMFSOpt() {}
+};
+
+}
+
+#endif
+#endif
diff -uN src/pair_eam_opt.cpp src_DFT-CES2/pair_eam_opt.cpp
--- src/pair_eam_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_eam_opt.cpp	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,349 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors:
+     James Fischer, High Performance Technologies, Inc.
+     Charles Cornwell, High Performance Technologies, Inc.
+     David Richie, Stone Ridge Technology
+     Vincent Natoli, Stone Ridge Technology
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdlib.h>
+#include "pair_eam_opt.h"
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "memory.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairEAMOpt::PairEAMOpt(LAMMPS *lmp) : PairEAM(lmp) {}
+
+/* ---------------------------------------------------------------------- */
+
+void PairEAMOpt::compute(int eflag, int vflag)
+{
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = eflag_global = eflag_atom = 0;
+
+  if (evflag) {
+    if (eflag) {
+      if (force->newton_pair) return eval<1,1,1>();
+      else return eval<1,1,0>();
+    } else {
+      if (force->newton_pair) return eval<1,0,1>();
+      else return eval<1,0,0>();
+    }
+  } else {
+    if (force->newton_pair) return eval<0,0,1>();
+    else return eval<0,0,0>();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+template < int EVFLAG, int EFLAG, int NEWTON_PAIR >
+void PairEAMOpt::eval()
+{
+  typedef struct { double x,y,z; } vec3_t;
+
+  typedef struct {
+    double rhor0i,rhor1i,rhor2i,rhor3i;
+    double rhor0j,rhor1j,rhor2j,rhor3j;
+  } fast_alpha_t;
+
+  typedef struct {
+    double rhor4i,rhor5i,rhor6i;
+    double rhor4j,rhor5j,rhor6j;
+    double z2r0,z2r1,z2r2,z2r3,z2r4,z2r5,z2r6;
+    double _pad[3];
+  } fast_gamma_t;
+
+  int i,j,ii,jj,inum,jnum,itype,jtype;
+  double evdwl = 0.0;
+  double* _noalias coeff;
+
+  // grow energy array if necessary
+
+  if (atom->nmax > nmax) {
+    memory->sfree(rho);
+    memory->sfree(fp);
+    nmax = atom->nmax;
+    rho = (double *) memory->smalloc(nmax*sizeof(double),"pair:rho");
+    fp = (double *) memory->smalloc(nmax*sizeof(double),"pair:fp");
+  }
+
+  double** _noalias x = atom->x;
+  double** _noalias f = atom->f;
+  int* _noalias type = atom->type;
+  int nlocal = atom->nlocal;
+
+  vec3_t* _noalias xx = (vec3_t*)x[0];
+  vec3_t* _noalias ff = (vec3_t*)f[0];
+
+  double tmp_cutforcesq = cutforcesq;
+  double tmp_rdr = rdr;
+  int nr2 = nr-2;
+  int nr1 = nr-1;
+
+  inum = list->inum;
+  int* _noalias ilist = list->ilist;
+  int** _noalias firstneigh = list->firstneigh;
+  int* _noalias numneigh = list->numneigh;
+
+  int ntypes = atom->ntypes;
+  int ntypes2 = ntypes*ntypes;
+
+  fast_alpha_t* _noalias fast_alpha =
+    (fast_alpha_t*) malloc(ntypes2*(nr+1)*sizeof(fast_alpha_t));
+  for (i = 0; i < ntypes; i++) for (j = 0; j < ntypes; j++) {
+    fast_alpha_t* _noalias tab = &fast_alpha[i*ntypes*nr+j*nr];
+    if (type2rhor[i+1][j+1] >= 0) {
+      for(int m = 1; m <= nr; m++) {
+        tab[m].rhor0i =  rhor_spline[type2rhor[i+1][j+1]][m][6];
+        tab[m].rhor1i =  rhor_spline[type2rhor[i+1][j+1]][m][5];
+        tab[m].rhor2i =  rhor_spline[type2rhor[i+1][j+1]][m][4];
+        tab[m].rhor3i =  rhor_spline[type2rhor[i+1][j+1]][m][3];
+      }
+    }
+    if (type2rhor[j+1][i+1] >= 0) {
+      for(int m = 1; m <= nr; m++) {
+        tab[m].rhor0j =  rhor_spline[type2rhor[j+1][i+1]][m][6];
+        tab[m].rhor1j =  rhor_spline[type2rhor[j+1][i+1]][m][5];
+        tab[m].rhor2j =  rhor_spline[type2rhor[j+1][i+1]][m][4];
+        tab[m].rhor3j =  rhor_spline[type2rhor[j+1][i+1]][m][3];
+      }
+    }
+  }
+  fast_alpha_t* _noalias tabeight = fast_alpha;
+
+  fast_gamma_t* _noalias fast_gamma =
+    (fast_gamma_t*) malloc(ntypes2*(nr+1)*sizeof(fast_gamma_t));
+  for (i = 0; i < ntypes; i++) for (j = 0; j < ntypes; j++) {
+    fast_gamma_t* _noalias tab = &fast_gamma[i*ntypes*nr+j*nr];
+    if (type2rhor[i+1][j+1] >= 0) {
+      for(int m = 1; m <= nr; m++) {
+        tab[m].rhor4i =  rhor_spline[type2rhor[i+1][j+1]][m][2];
+        tab[m].rhor5i =  rhor_spline[type2rhor[i+1][j+1]][m][1];
+        tab[m].rhor6i =  rhor_spline[type2rhor[i+1][j+1]][m][0];
+      }
+    }
+    if (type2rhor[j+1][i+1] >= 0) {
+      for(int m = 1; m <= nr; m++) {
+        tab[m].rhor4j =  rhor_spline[type2rhor[j+1][i+1]][m][2];
+        tab[m].rhor5j =  rhor_spline[type2rhor[j+1][i+1]][m][1];
+        tab[m].rhor6j =  rhor_spline[type2rhor[j+1][i+1]][m][0];
+        tab[m].z2r6 =  z2r_spline[type2z2r[i+1][j+1]][m][0];
+      }
+    }
+    if (type2z2r[i+1][j+1] >= 0) {
+      for(int m = 1; m <= nr; m++) {
+        tab[m].z2r0 =  z2r_spline[type2z2r[i+1][j+1]][m][6];
+        tab[m].z2r1 =  z2r_spline[type2z2r[i+1][j+1]][m][5];
+        tab[m].z2r2 =  z2r_spline[type2z2r[i+1][j+1]][m][4];
+        tab[m].z2r3 =  z2r_spline[type2z2r[i+1][j+1]][m][3];
+        tab[m].z2r4 =  z2r_spline[type2z2r[i+1][j+1]][m][2];
+        tab[m].z2r5 =  z2r_spline[type2z2r[i+1][j+1]][m][1];
+        tab[m].z2r6 =  z2r_spline[type2z2r[i+1][j+1]][m][0];
+      }
+    }
+  }
+  fast_gamma_t* _noalias tabss = fast_gamma;
+
+  // zero out density
+
+  if (NEWTON_PAIR) {
+    int m = nlocal + atom->nghost;
+    for (i = 0; i < m; i++) rho[i] = 0.0;
+  } else for (i = 0; i < nlocal; i++) rho[i] = 0.0;
+
+  // rho = density at each atom
+  // loop over neighbors of my atoms
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    double xtmp = xx[i].x;
+    double ytmp = xx[i].y;
+    double ztmp = xx[i].z;
+    itype = type[i] - 1;
+    int* _noalias jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    double tmprho = rho[i];
+    fast_alpha_t* _noalias tabeighti = &tabeight[itype*ntypes*nr];
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      j &= NEIGHMASK;
+
+      double delx = xtmp - xx[j].x;
+      double dely = ytmp - xx[j].y;
+      double delz = ztmp - xx[j].z;
+      double rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq < tmp_cutforcesq) {
+        jtype = type[j] - 1;
+
+        double p = sqrt(rsq)*tmp_rdr;
+        if ( (int)p <= nr2 ) {
+          int m = (int)p + 1;
+          p -= (double)((int)p);
+          fast_alpha_t& a = tabeighti[jtype*nr+m];
+          tmprho += ((a.rhor3j*p+a.rhor2j)*p+a.rhor1j)*p+a.rhor0j;
+          if (NEWTON_PAIR || j < nlocal) {
+            rho[j] += ((a.rhor3i*p+a.rhor2i)*p+a.rhor1i)*p+a.rhor0i;
+          }
+        } else {
+          fast_alpha_t& a = tabeighti[jtype*nr+nr1];
+          tmprho += a.rhor3j+a.rhor2j+a.rhor1j+a.rhor0j;
+          if (NEWTON_PAIR || j < nlocal) {
+            rho[j] += a.rhor3i+a.rhor2i+a.rhor1i+a.rhor0i;
+          }
+        }
+      }
+    }
+    rho[i] = tmprho;
+  }
+
+  // communicate and sum densities
+
+  if (NEWTON_PAIR) comm->reverse_comm_pair(this);
+
+  // fp = derivative of embedding energy at each atom
+  // phi = embedding energy at each atom
+  // if rho > rhomax (e.g. due to close approach of two atoms),
+  //   will exceed table, so add linear term to conserve energy
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    double p = rho[i]*rdrho;
+    int m = MIN((int)p,nrho-2);
+    p -= (double)m;
+    ++m;
+    coeff = frho_spline[type2frho[type[i]]][m];
+    fp[i] = (coeff[0]*p + coeff[1])*p + coeff[2];
+    if (EFLAG) {
+      double phi = ((coeff[3]*p + coeff[4])*p + coeff[5])*p + coeff[6];
+      if (rho[i] > rhomax) phi += fp[i] * (rho[i]-rhomax);
+      phi *= scale[type[i]][type[i]];
+      if (eflag_global) eng_vdwl += phi;
+      if (eflag_atom) eatom[i] += phi;
+    }
+  }
+
+  // communicate derivative of embedding function
+
+  comm->forward_comm_pair(this);
+
+  // compute forces on each atom
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    double xtmp = xx[i].x;
+    double ytmp = xx[i].y;
+    double ztmp = xx[i].z;
+    int itype1 = type[i] - 1;
+    int* _noalias jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    double tmpfx = 0.0;
+    double tmpfy = 0.0;
+    double tmpfz = 0.0;
+
+    fast_gamma_t* _noalias tabssi = &tabss[itype1*ntypes*nr];
+    double* _noalias scale_i = scale[itype1+1]+1;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      j &= NEIGHMASK;
+
+      double delx = xtmp - xx[j].x;
+      double dely = ytmp - xx[j].y;
+      double delz = ztmp - xx[j].z;
+      double rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq < tmp_cutforcesq) {
+        jtype = type[j] - 1;
+        double r = sqrt(rsq);
+        double rhoip,rhojp,z2,z2p;
+        double p = r*tmp_rdr;
+        if ( (int)p <= nr2 ) {
+          int m = (int) p + 1;
+          p -= (double)((int) p);
+
+          fast_gamma_t& a = tabssi[jtype*nr+m];
+          rhoip = (a.rhor6i*p + a.rhor5i)*p + a.rhor4i;
+          rhojp = (a.rhor6j*p + a.rhor5j)*p + a.rhor4j;
+          z2 = ((a.z2r3*p + a.z2r2)*p + a.z2r1)*p + a.z2r0;
+          z2p = (a.z2r6*p + a.z2r5)*p + a.z2r4;
+
+        } else {
+
+          fast_gamma_t& a = tabssi[jtype*nr+nr1];
+          rhoip = a.rhor6i + a.rhor5i + a.rhor4i;
+          rhojp = a.rhor6j + a.rhor5j + a.rhor4j;
+          z2 = a.z2r3 + a.z2r2 + a.z2r1 + a.z2r0;
+          z2p = a.z2r6 + a.z2r5 + a.z2r4;
+        }
+
+        // rhoip = derivative of (density at atom j due to atom i)
+        // rhojp = derivative of (density at atom i due to atom j)
+        // phi = pair potential energy
+        // phip = phi'
+        // z2 = phi * r
+        // z2p = (phi * r)' = (phi' r) + phi
+        // psip needs both fp[i] and fp[j] terms since r_ij appears in two
+        //   terms of embed eng: Fi(sum rho_ij) and Fj(sum rho_ji)
+        //   hence embed' = Fi(sum rho_ij) rhojp + Fj(sum rho_ji) rhoip
+        // scale factor can be applied by thermodynamic integration
+
+        double recip = 1.0/r;
+        double phi = z2*recip;
+        double phip = z2p*recip - phi*recip;
+        double psip = fp[i]*rhojp + fp[j]*rhoip + phip;
+        double fpair = -scale_i[jtype]*psip*recip;
+
+        tmpfx += delx*fpair;
+        tmpfy += dely*fpair;
+        tmpfz += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          ff[j].x -= delx*fpair;
+          ff[j].y -= dely*fpair;
+          ff[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) evdwl = scale_i[jtype]*phi;
+
+        if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                             evdwl,0.0,fpair,delx,dely,delz);
+      }
+    }
+
+    ff[i].x += tmpfx;
+    ff[i].y += tmpfy;
+    ff[i].z += tmpfz;
+  }
+
+  free(fast_alpha); fast_alpha = 0;
+  free(fast_gamma); fast_gamma = 0;
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
diff -uN src/pair_eam_opt.h src_DFT-CES2/pair_eam_opt.h
--- src/pair_eam_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_eam_opt.h	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,42 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(eam/opt,PairEAMOpt)
+
+#else
+
+#ifndef LMP_PAIR_EAM_OPT_H
+#define LMP_PAIR_EAM_OPT_H
+
+#include "pair_eam.h"
+
+namespace LAMMPS_NS {
+
+// use virtual public since this class is parent in multiple inheritance
+
+class PairEAMOpt : virtual public PairEAM {
+ public:
+  PairEAMOpt(class LAMMPS *);
+  virtual ~PairEAMOpt() {}
+  void compute(int, int);
+
+ private:
+  template < int EVFLAG, int EFLAG, int NEWTON_PAIR > void eval();
+};
+
+}
+
+#endif
+#endif
diff -uN src/pair_lj_charmm_coul_long_opt.cpp src_DFT-CES2/pair_lj_charmm_coul_long_opt.cpp
--- src/pair_lj_charmm_coul_long_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_charmm_coul_long_opt.cpp	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,339 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors:
+     James Fischer, High Performance Technologies, Inc.
+     David Richie, Stone Ridge Technology
+     Vincent Natoli, Stone Ridge Technology
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdlib.h>
+#include "pair_lj_charmm_coul_long_opt.h"
+#include "atom.h"
+#include "force.h"
+#include "neigh_list.h"
+
+using namespace LAMMPS_NS;
+
+#define EWALD_F   1.12837917
+#define EWALD_P   0.3275911
+#define EWALD_A1  0.254829592
+#define EWALD_A2 -0.284496736
+#define EWALD_A3  1.421413741
+#define EWALD_A4 -1.453152027
+#define EWALD_A5  1.061405429
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCharmmCoulLongOpt::PairLJCharmmCoulLongOpt(LAMMPS *lmp) :
+  PairLJCharmmCoulLong(lmp) {}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCharmmCoulLongOpt::compute(int eflag, int vflag)
+{
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+
+  if (evflag) {
+    if (eflag) {
+      if (force->newton_pair) return eval<1,1,1>();
+      else return eval<1,1,0>();
+    } else {
+      if (force->newton_pair) return eval<1,0,1>();
+      else return eval<1,0,0>();
+    }
+  } else {
+    if (force->newton_pair) return eval<0,0,1>();
+    else return eval<0,0,0>();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+template < int EVFLAG, int EFLAG, int NEWTON_PAIR >
+void PairLJCharmmCoulLongOpt::eval()
+{
+  typedef struct { double x,y,z; } vec3_t;
+
+  typedef struct {
+    double cutsq,lj1,lj2,lj3,lj4,offset;
+    double _pad[2];
+  } fast_alpha_t;
+
+  int i,j,ii,jj,inum,jnum,itype,jtype,itable,sbindex;
+  double fraction,table;
+  double r,r2inv,r6inv,forcecoul,forcelj,factor_coul,factor_lj;
+  double grij,expm2,prefactor,t,erfc;
+  double philj,switch1,switch2;
+
+  double rsq;
+
+  double evdwl = 0.0;
+  double ecoul = 0.0;
+
+  double** _noalias x = atom->x;
+  double** _noalias f = atom->f;
+  double* _noalias q = atom->q;
+  int* _noalias type = atom->type;
+  int nlocal = atom->nlocal;
+  double* _noalias special_coul = force->special_coul;
+  double* _noalias special_lj = force->special_lj;
+  double qqrd2e = force->qqrd2e;
+
+  inum = list->inum;
+  int* _noalias ilist = list->ilist;
+  int** _noalias firstneigh = list->firstneigh;
+  int* _noalias numneigh = list->numneigh;
+
+  vec3_t* _noalias xx = (vec3_t*)x[0];
+  vec3_t* _noalias ff = (vec3_t*)f[0];
+
+  int ntypes = atom->ntypes;
+  int ntypes2 = ntypes*ntypes;
+
+  double tmp_coef1 = 1.0/denom_lj;
+  double tmp_coef2 = cut_ljsq - 3.0*cut_lj_innersq;
+
+  fast_alpha_t* _noalias fast_alpha =
+    (fast_alpha_t*)malloc(ntypes2*sizeof(fast_alpha_t));
+  for (i = 0; i < ntypes; i++) for (j = 0; j < ntypes; j++) {
+    fast_alpha_t& a = fast_alpha[i*ntypes+j];
+    a.cutsq = cutsq[i+1][j+1];
+    a.lj1 = lj1[i+1][j+1];
+    a.lj2 = lj2[i+1][j+1];
+    a.lj3 = lj3[i+1][j+1];
+    a.lj4 = lj4[i+1][j+1];
+  }
+  fast_alpha_t* _noalias tabsix = fast_alpha;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    double qtmp = q[i];
+    double xtmp = xx[i].x;
+    double ytmp = xx[i].y;
+    double ztmp = xx[i].z;
+    itype = type[i] - 1;
+    int* _noalias jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    double tmpfx = 0.0;
+    double tmpfy = 0.0;
+    double tmpfz = 0.0;
+
+    fast_alpha_t* _noalias tabsixi = (fast_alpha_t*) &tabsix[itype*ntypes];
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      sbindex = sbmask(j);
+
+      if (sbindex == 0) {
+        double delx = xtmp - xx[j].x;
+        double dely = ytmp - xx[j].y;
+        double delz = ztmp - xx[j].z;
+        rsq = delx*delx + dely*dely + delz*delz;
+        double tmp_coef3 = qtmp*q[j];
+
+        if (rsq < cut_bothsq) {
+          r2inv = 1.0/rsq;
+
+          forcecoul = 0.0;
+          if (rsq < cut_coulsq) {
+            if (!ncoultablebits || rsq <= tabinnersq) {
+              r = sqrt(rsq);
+              grij = g_ewald * r;
+              expm2 = exp(-grij*grij);
+              t = 1.0 / (1.0 + EWALD_P*grij);
+              erfc = t *
+                (EWALD_A1+t*(EWALD_A2+t*(EWALD_A3+t*(EWALD_A4+t*EWALD_A5)))) *
+                expm2;
+              prefactor = qqrd2e * tmp_coef3/r;
+              forcecoul = prefactor * (erfc + EWALD_F*grij*expm2);
+            } else {
+              union_int_float_t rsq_lookup;
+              rsq_lookup.f = rsq;
+              itable = rsq_lookup.i & ncoulmask;
+              itable >>= ncoulshiftbits;
+              fraction = (rsq_lookup.f - rtable[itable]) * drtable[itable];
+              table = ftable[itable] + fraction*dftable[itable];
+              forcecoul = tmp_coef3 * table;
+            }
+          }
+
+          forcelj = 0.0;
+          if (rsq < cut_ljsq) {
+            r6inv = r2inv*r2inv*r2inv;
+            jtype = type[j] - 1;
+            fast_alpha_t& a = tabsixi[jtype];
+            forcelj = r6inv * (a.lj1*r6inv - a.lj2);
+            if (rsq > cut_lj_innersq) {
+              switch1 = (cut_ljsq-rsq) * (cut_ljsq-rsq) *
+                (tmp_coef2 + 2.0*rsq) * tmp_coef1;
+              switch2 = 12.0*rsq * (cut_ljsq-rsq) *
+                (rsq-cut_lj_innersq) * tmp_coef1;
+              philj = r6inv * (a.lj3*r6inv - a.lj4);
+              forcelj = forcelj*switch1 + philj*switch2;
+            }
+          }
+
+          double fpair = (forcecoul + forcelj) * r2inv;
+
+          tmpfx += delx*fpair;
+          tmpfy += dely*fpair;
+          tmpfz += delz*fpair;
+          if (NEWTON_PAIR || j < nlocal) {
+            ff[j].x -= delx*fpair;
+            ff[j].y -= dely*fpair;
+            ff[j].z -= delz*fpair;
+          }
+
+          if (EFLAG) {
+            if (rsq < cut_coulsq) {
+              if (!ncoultablebits || rsq <= tabinnersq)
+                ecoul = prefactor*erfc;
+              else {
+                table = etable[itable] + fraction*detable[itable];
+                ecoul = tmp_coef3 * table;
+              }
+            } else ecoul = 0.0;
+
+            if (rsq < cut_ljsq) {
+              fast_alpha_t& a = tabsixi[jtype];
+              evdwl = r6inv*(a.lj3*r6inv-a.lj4);
+              if (rsq > cut_lj_innersq) {
+                switch1 = (cut_ljsq-rsq) * (cut_ljsq-rsq) *
+                  (tmp_coef2 + 2.0*rsq) * tmp_coef1;
+                evdwl *= switch1;
+              }
+            } else evdwl = 0.0;
+          }
+
+          if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                               evdwl,ecoul,fpair,delx,dely,delz);
+        }
+
+      } else {
+        factor_lj = special_lj[sbindex];
+        factor_coul = special_coul[sbindex];
+        j &= NEIGHMASK;
+
+        double delx = xtmp - xx[j].x;
+        double dely = ytmp - xx[j].y;
+        double delz = ztmp - xx[j].z;
+        rsq = delx*delx + dely*dely + delz*delz;
+        double tmp_coef3 = qtmp*q[j];
+
+        if (rsq < cut_bothsq) {
+          r2inv = 1.0/rsq;
+
+          forcecoul = 0.0;
+          if (rsq < cut_coulsq) {
+            if (!ncoultablebits || rsq <= tabinnersq) {
+              r = sqrt(rsq);
+              grij = g_ewald * r;
+              expm2 = exp(-grij*grij);
+              t = 1.0 / (1.0 + EWALD_P*grij);
+              erfc = t *
+                (EWALD_A1+t*(EWALD_A2+t*(EWALD_A3+t*(EWALD_A4+t*EWALD_A5)))) *
+                expm2;
+              prefactor = qqrd2e * tmp_coef3/r;
+              forcecoul = prefactor * (erfc + EWALD_F*grij*expm2);
+              if (factor_coul < 1.0) {
+                forcecoul -= (1.0-factor_coul)*prefactor;
+              }
+            } else {
+              union_int_float_t rsq_lookup;
+              rsq_lookup.f = rsq;
+              itable = rsq_lookup.i & ncoulmask;
+              itable >>= ncoulshiftbits;
+              fraction = (rsq_lookup.f - rtable[itable]) * drtable[itable];
+              table = ftable[itable] + fraction*dftable[itable];
+              forcecoul = tmp_coef3 * table;
+              if (factor_coul < 1.0) {
+                table = ctable[itable] + fraction*dctable[itable];
+                prefactor = tmp_coef3 * table;
+                forcecoul -= (1.0-factor_coul)*prefactor;
+              }
+            }
+          }
+
+          forcelj = 0.0;
+          if (rsq < cut_ljsq) {
+            r6inv = r2inv*r2inv*r2inv;
+            jtype = type[j] - 1;
+            fast_alpha_t& a = tabsixi[jtype];
+            forcelj = r6inv * (a.lj1*r6inv - a.lj2);
+            if (rsq > cut_lj_innersq) {
+              switch1 = (cut_ljsq-rsq) * (cut_ljsq-rsq) *
+                (tmp_coef2 + 2.0*rsq) * tmp_coef1;
+              switch2 = 12.0*rsq * (cut_ljsq-rsq) *
+                (rsq-cut_lj_innersq) * tmp_coef1;
+              fast_alpha_t& a = tabsixi[jtype];
+              philj = r6inv * (a.lj3*r6inv - a.lj4);
+              forcelj = forcelj*switch1 + philj*switch2;
+            }
+          }
+
+          double fpair = (forcecoul + factor_lj*forcelj) * r2inv;
+
+          tmpfx += delx*fpair;
+          tmpfy += dely*fpair;
+          tmpfz += delz*fpair;
+          if (NEWTON_PAIR || j < nlocal) {
+            ff[j].x -= delx*fpair;
+            ff[j].y -= dely*fpair;
+            ff[j].z -= delz*fpair;
+          }
+
+          if (EFLAG) {
+            if (rsq < cut_coulsq) {
+              if (!ncoultablebits || rsq <= tabinnersq)
+                ecoul = prefactor*erfc;
+              else {
+                table = etable[itable] + fraction*detable[itable];
+                ecoul = tmp_coef3 * table;
+              }
+              if (factor_coul < 1.0) ecoul -= (1.0-factor_coul)*prefactor;
+            } else ecoul = 0.0;
+
+            if (rsq < cut_ljsq) {
+              fast_alpha_t& a = tabsixi[jtype];
+              evdwl = r6inv*(a.lj3*r6inv-a.lj4);
+              if (rsq > cut_lj_innersq) {
+                switch1 = (cut_ljsq-rsq) * (cut_ljsq-rsq) *
+                  (tmp_coef2 + 2.0*rsq) * tmp_coef1;
+                evdwl *= switch1;
+              }
+              evdwl *= factor_lj;
+            } else evdwl = 0.0;
+          }
+
+          if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                               evdwl,ecoul,fpair,delx,dely,delz);
+        }
+      }
+    }
+
+    ff[i].x += tmpfx;
+    ff[i].y += tmpfy;
+    ff[i].z += tmpfz;
+  }
+
+  free(fast_alpha); fast_alpha = 0;
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
diff -uN src/pair_lj_charmm_coul_long_opt.h src_DFT-CES2/pair_lj_charmm_coul_long_opt.h
--- src/pair_lj_charmm_coul_long_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_charmm_coul_long_opt.h	2025-02-11 06:42:37.180608935 +0900
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(lj/charmm/coul/long/opt,PairLJCharmmCoulLongOpt)
+
+#else
+
+#ifndef LMP_PAIR_LJ_CHARMM_COUL_LONG_OPT_H
+#define LMP_PAIR_LJ_CHARMM_COUL_LONG_OPT_H
+
+#include "pair_lj_charmm_coul_long.h"
+
+namespace LAMMPS_NS {
+
+class PairLJCharmmCoulLongOpt : public PairLJCharmmCoulLong {
+ public:
+  PairLJCharmmCoulLongOpt(class LAMMPS *);
+  void compute(int, int);
+
+ private:
+  template < int EVFLAG, int EFLAG, int NEWTON_PAIR > void eval();
+};
+
+}
+
+#endif
+#endif
diff -uN src/pair_lj_cut_coul_long_opt.cpp src_DFT-CES2/pair_lj_cut_coul_long_opt.cpp
--- src/pair_lj_cut_coul_long_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_cut_coul_long_opt.cpp	2025-02-11 06:42:37.180608935 +0900
@@ -0,0 +1,203 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include "pair_lj_cut_coul_long_opt.h"
+#include "atom.h"
+#include "force.h"
+#include "neigh_list.h"
+
+using namespace LAMMPS_NS;
+
+#define EWALD_F   1.12837917
+#define EWALD_P   0.3275911
+#define A1        0.254829592
+#define A2       -0.284496736
+#define A3        1.421413741
+#define A4       -1.453152027
+#define A5        1.061405429
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCutCoulLongOpt::PairLJCutCoulLongOpt(LAMMPS *lmp) : PairLJCutCoulLong(lmp)
+{
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCutCoulLongOpt::compute(int eflag, int vflag)
+{
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+
+  if (!ncoultablebits) {
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) return eval<1,1,1,0>();
+        else return eval<1,1,0,0>();
+      } else {
+        if (force->newton_pair) return eval<1,0,1,0>();
+        else return eval<1,0,0,0>();
+      }
+    } else {
+      if (force->newton_pair) return eval<0,0,1,0>();
+      else return eval<0,0,0,0>();
+    }
+  } else {
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) return eval<1,1,1,1>();
+        else return eval<1,1,0,1>();
+      } else {
+        if (force->newton_pair) return eval<1,0,1,1>();
+        else return eval<1,0,0,1>();
+      }
+    } else {
+      if (force->newton_pair) return eval<0,0,1,1>();
+      else return eval<0,0,0,1>();
+    }
+  }
+}
+
+
+template < const int EVFLAG, const int EFLAG,
+           const int NEWTON_PAIR, const int CTABLE >
+void PairLJCutCoulLongOpt::eval()
+{
+  int i,ii,j,jj,inum,jnum,itype,jtype,itable;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul,fpair;
+  double fraction,table;
+  double r,r2inv,r6inv,forcecoul,forcelj,factor_coul,factor_lj;
+  double grij,expm2,prefactor,t,erfc;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+  double rsq;
+
+  evdwl = ecoul = 0.0;
+
+  double **x = atom->x;
+  double **f = atom->f;
+  double *q = atom->q;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  double *special_coul = force->special_coul;
+  double *special_lj = force->special_lj;
+  double qqrd2e = force->qqrd2e;
+  double fxtmp,fytmp,fztmp;
+
+  inum = list->inum;
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp = fytmp = fztmp = 0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+
+        if (rsq < cut_coulsq) {
+          if (!CTABLE || rsq <= tabinnersq) {
+            r = sqrt(rsq);
+            grij = g_ewald * r;
+            expm2 = exp(-grij*grij);
+            t = 1.0 / (1.0 + EWALD_P*grij);
+            erfc = t * (A1+t*(A2+t*(A3+t*(A4+t*A5)))) * expm2;
+            prefactor = qqrd2e * qtmp*q[j]/r;
+            forcecoul = prefactor * (erfc + EWALD_F*grij*expm2);
+            if (factor_coul < 1.0) forcecoul -= (1.0-factor_coul)*prefactor;
+          } else {
+            union_int_float_t rsq_lookup;
+            rsq_lookup.f = rsq;
+            itable = rsq_lookup.i & ncoulmask;
+            itable >>= ncoulshiftbits;
+            fraction = (rsq_lookup.f - rtable[itable]) * drtable[itable];
+            table = ftable[itable] + fraction*dftable[itable];
+            forcecoul = qtmp*q[j] * table;
+            if (factor_coul < 1.0) {
+              table = ctable[itable] + fraction*dctable[itable];
+              prefactor = qtmp*q[j] * table;
+              forcecoul -= (1.0-factor_coul)*prefactor;
+            }
+          }
+        } else forcecoul = 0.0;
+
+        if (rsq < cut_ljsq[itype][jtype]) {
+          r6inv = r2inv*r2inv*r2inv;
+          forcelj = r6inv * (lj1[itype][jtype]*r6inv - lj2[itype][jtype]);
+        } else forcelj = 0.0;
+
+        fpair = (forcecoul + factor_lj*forcelj) * r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j][0] -= delx*fpair;
+          f[j][1] -= dely*fpair;
+          f[j][2] -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          if (rsq < cut_coulsq) {
+            if (!CTABLE || rsq <= tabinnersq)
+              ecoul = prefactor*erfc;
+            else {
+              table = etable[itable] + fraction*detable[itable];
+              ecoul = qtmp*q[j] * table;
+            }
+            if (factor_coul < 1.0) ecoul -= (1.0-factor_coul)*prefactor;
+          } else ecoul = 0.0;
+
+          if (rsq < cut_ljsq[itype][jtype]) {
+            evdwl = r6inv*(lj3[itype][jtype]*r6inv-lj4[itype][jtype]) -
+              offset[itype][jtype];
+            evdwl *= factor_lj;
+          } else evdwl = 0.0;
+        }
+
+        if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                             evdwl,ecoul,fpair,delx,dely,delz);
+      }
+    }
+    f[i][0] += fxtmp;
+    f[i][1] += fytmp;
+    f[i][2] += fztmp;
+  }
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
+
+/* ---------------------------------------------------------------------- */
diff -uN src/pair_lj_cut_coul_long_opt.h src_DFT-CES2/pair_lj_cut_coul_long_opt.h
--- src/pair_lj_cut_coul_long_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_cut_coul_long_opt.h	2025-02-11 06:42:37.180608935 +0900
@@ -0,0 +1,41 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(lj/cut/coul/long/opt,PairLJCutCoulLongOpt)
+
+#else
+
+#ifndef LMP_PAIR_LJ_CUT_COUL_LONG_OPT_H
+#define LMP_PAIR_LJ_CUT_COUL_LONG_OPT_H
+
+#include "pair_lj_cut_coul_long.h"
+
+namespace LAMMPS_NS {
+
+class PairLJCutCoulLongOpt : public PairLJCutCoulLong {
+ public:
+  PairLJCutCoulLongOpt(class LAMMPS *);
+  virtual void compute(int, int);
+
+ protected:
+  template <const int EVFLAG, const int EFLAG,
+            const int NEWTON_PAIR, const int CTABLE >
+  void eval();
+};
+
+}
+
+#endif
+#endif
diff -uN src/pair_lj_cut_opt.cpp src_DFT-CES2/pair_lj_cut_opt.cpp
--- src/pair_lj_cut_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_cut_opt.cpp	2025-02-11 06:42:37.180608935 +0900
@@ -0,0 +1,201 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors:
+     James Fischer, High Performance Technologies, Inc.
+     David Richie, Stone Ridge Technology
+     Vincent Natoli, Stone Ridge Technology
+------------------------------------------------------------------------- */
+
+#include <stdlib.h>
+#include "pair_lj_cut_opt.h"
+#include "atom.h"
+#include "force.h"
+#include "neigh_list.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCutOpt::PairLJCutOpt(LAMMPS *lmp) : PairLJCut(lmp) {}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCutOpt::compute(int eflag, int vflag)
+{
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+
+  if (evflag) {
+    if (eflag) {
+      if (force->newton_pair) return eval<1,1,1>();
+      else return eval<1,1,0>();
+    } else {
+      if (force->newton_pair) return eval<1,0,1>();
+      else return eval<1,0,0>();
+    }
+  } else {
+    if (force->newton_pair) return eval<0,0,1>();
+    else return eval<0,0,0>();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+template < int EVFLAG, int EFLAG, int NEWTON_PAIR >
+void PairLJCutOpt::eval()
+{
+  typedef struct { double x,y,z; } vec3_t;
+
+  typedef struct {
+    double cutsq,lj1,lj2,lj3,lj4,offset;
+    double _pad[2];
+  } fast_alpha_t;
+
+  int i,j,ii,jj,inum,jnum,itype,jtype,sbindex;
+  double factor_lj;
+  double evdwl = 0.0;
+
+  double** _noalias x = atom->x;
+  double** _noalias f = atom->f;
+  int* _noalias type = atom->type;
+  int nlocal = atom->nlocal;
+  double* _noalias special_lj = force->special_lj;
+
+  inum = list->inum;
+  int* _noalias ilist = list->ilist;
+  int** _noalias firstneigh = list->firstneigh;
+  int* _noalias numneigh = list->numneigh;
+
+  vec3_t* _noalias xx = (vec3_t*)x[0];
+  vec3_t* _noalias ff = (vec3_t*)f[0];
+
+  int ntypes = atom->ntypes;
+  int ntypes2 = ntypes*ntypes;
+
+  fast_alpha_t* _noalias fast_alpha =
+    (fast_alpha_t*) malloc(ntypes2*sizeof(fast_alpha_t));
+  for (i = 0; i < ntypes; i++) for (j = 0; j < ntypes; j++) {
+    fast_alpha_t& a = fast_alpha[i*ntypes+j];
+    a.cutsq = cutsq[i+1][j+1];
+    a.lj1 = lj1[i+1][j+1];
+    a.lj2 = lj2[i+1][j+1];
+    a.lj3 = lj3[i+1][j+1];
+    a.lj4 = lj4[i+1][j+1];
+    a.offset = offset[i+1][j+1];
+  }
+  fast_alpha_t* _noalias tabsix = fast_alpha;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    double xtmp = xx[i].x;
+    double ytmp = xx[i].y;
+    double ztmp = xx[i].z;
+    itype = type[i] - 1;
+    int* _noalias jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    double tmpfx = 0.0;
+    double tmpfy = 0.0;
+    double tmpfz = 0.0;
+
+    fast_alpha_t* _noalias tabsixi = (fast_alpha_t*)&tabsix[itype*ntypes];
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      sbindex = sbmask(j);
+
+      if (sbindex == 0) {
+        double delx = xtmp - xx[j].x;
+        double dely = ytmp - xx[j].y;
+        double delz = ztmp - xx[j].z;
+        double rsq = delx*delx + dely*dely + delz*delz;
+
+        jtype = type[j] - 1;
+
+        fast_alpha_t& a = tabsixi[jtype];
+
+        if (rsq < a.cutsq) {
+          double r2inv = 1.0/rsq;
+          double r6inv = r2inv*r2inv*r2inv;
+          double forcelj = r6inv * (a.lj1*r6inv - a.lj2);
+          double fpair = forcelj*r2inv;
+
+          tmpfx += delx*fpair;
+          tmpfy += dely*fpair;
+          tmpfz += delz*fpair;
+          if (NEWTON_PAIR || j < nlocal) {
+            ff[j].x -= delx*fpair;
+            ff[j].y -= dely*fpair;
+            ff[j].z -= delz*fpair;
+          }
+
+          if (EFLAG) evdwl = r6inv*(a.lj3*r6inv-a.lj4) - a.offset;
+
+          if (EVFLAG)
+            ev_tally(i,j,nlocal,NEWTON_PAIR,
+                     evdwl,0.0,fpair,delx,dely,delz);
+        }
+
+      } else {
+        factor_lj = special_lj[sbindex];
+        j &= NEIGHMASK;
+
+        double delx = xtmp - xx[j].x;
+        double dely = ytmp - xx[j].y;
+        double delz = ztmp - xx[j].z;
+        double rsq = delx*delx + dely*dely + delz*delz;
+
+        int jtype1 = type[j];
+        jtype = jtype1 - 1;
+
+        fast_alpha_t& a = tabsixi[jtype];
+        if (rsq < a.cutsq) {
+          double r2inv = 1.0/rsq;
+          double r6inv = r2inv*r2inv*r2inv;
+          fast_alpha_t& a = tabsixi[jtype];
+          double forcelj = r6inv * (a.lj1*r6inv - a.lj2);
+          double fpair = factor_lj*forcelj*r2inv;
+
+          tmpfx += delx*fpair;
+          tmpfy += dely*fpair;
+          tmpfz += delz*fpair;
+          if (NEWTON_PAIR || j < nlocal) {
+            ff[j].x -= delx*fpair;
+            ff[j].y -= dely*fpair;
+            ff[j].z -= delz*fpair;
+          }
+
+          if (EFLAG) {
+            evdwl = r6inv*(a.lj3*r6inv-a.lj4) - a.offset;
+            evdwl *= factor_lj;
+          }
+
+          if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                               evdwl,0.0,fpair,delx,dely,delz);
+        }
+      }
+    }
+
+    ff[i].x += tmpfx;
+    ff[i].y += tmpfy;
+    ff[i].z += tmpfz;
+  }
+
+  free(fast_alpha); fast_alpha = 0;
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
diff -uN src/pair_lj_cut_opt.h src_DFT-CES2/pair_lj_cut_opt.h
--- src/pair_lj_cut_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_cut_opt.h	2025-02-11 06:42:37.173608868 +0900
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(lj/cut/opt,PairLJCutOpt)
+
+#else
+
+#ifndef LMP_PAIR_LJ_CUT_OPT_H
+#define LMP_PAIR_LJ_CUT_OPT_H
+
+#include "pair_lj_cut.h"
+
+namespace LAMMPS_NS {
+
+class PairLJCutOpt : public PairLJCut {
+ public:
+  PairLJCutOpt(class LAMMPS *);
+  void compute(int, int);
+
+ private:
+  template < int EVFLAG, int EFLAG, int NEWTON_PAIR > void eval();
+};
+
+}
+
+#endif
+#endif
diff -uN src/pair_lj_cut_tip4p_long_opt.cpp src_DFT-CES2/pair_lj_cut_tip4p_long_opt.cpp
--- src/pair_lj_cut_tip4p_long_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_cut_tip4p_long_opt.cpp	2025-02-11 06:42:37.173608868 +0900
@@ -0,0 +1,481 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   OPT version: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include "pair_lj_cut_tip4p_long_opt.h"
+#include "atom.h"
+#include "domain.h"
+#include "force.h"
+#include "error.h"
+#include "memory.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+
+using namespace LAMMPS_NS;
+
+#define EWALD_F   1.12837917
+#define EWALD_P   0.3275911
+#define A1        0.254829592
+#define A2       -0.284496736
+#define A3        1.421413741
+#define A4       -1.453152027
+#define A5        1.061405429
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCutTIP4PLongOpt::PairLJCutTIP4PLongOpt(LAMMPS *lmp) :
+  PairLJCutTIP4PLong(lmp)
+{
+  single_enable = 0;
+  respa_enable = 0;
+
+  // TIP4P cannot compute virial as F dot r
+  // due to finding bonded H atoms which are not near O atom
+
+  no_virial_fdotr_compute = 1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCutTIP4PLongOpt::compute(int eflag, int vflag)
+{
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+
+  const int nlocal = atom->nlocal;
+  const int nall = nlocal + atom->nghost;
+
+  // reallocate hneigh & newsite if necessary
+  // initialize hneigh[0] to -1 on steps when reneighboring occurred
+  // initialize hneigh[2] to 0 every step
+
+  if (atom->nmax > nmax) {
+    nmax = atom->nmax;
+    memory->destroy(hneigh);
+    memory->create(hneigh,nmax,3,"pair:hneigh");
+    memory->destroy(newsite);
+    memory->create(newsite,nmax,3,"pair:newsite");
+  }
+
+  int i;
+  if (neighbor->ago == 0)
+    for (i = 0; i < nall; i++) hneigh[i][0] = -1;
+  for (i = 0; i < nall; i++) hneigh[i][2] = 0;
+
+
+  if (!ncoultablebits) {
+    if (evflag) {
+      if (eflag) {
+        if (vflag) return eval<1,1,1,1>();
+        else return eval<1,1,1,0>();
+      } else {
+        if (vflag) return eval<1,1,0,1>();
+        else return eval<1,1,0,0>();
+      }
+    } else return eval<1,0,0,0>();
+  } else {
+    if (evflag) {
+      if (eflag) {
+        if (vflag) return eval<0,1,1,1>();
+        else return eval<0,1,1,0>();
+      } else {
+        if (vflag) return eval<0,1,0,1>();
+        else return eval<0,1,0,0>();
+      }
+    } else return eval<0,0,0,0>();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+template < const int CTABLE, const int EVFLAG,
+           const int EFLAG, const int VFLAG>
+void PairLJCutTIP4PLongOpt::eval()
+{
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul;
+  double fraction,table;
+  double r,rsq,r2inv,r6inv,forcecoul,forcelj,cforce;
+  double factor_coul,factor_lj;
+  double grij,expm2,prefactor,t,erfc;
+  double v[6];
+  double fdx,fdy,fdz,fOx,fOy,fOz,fHx,fHy,fHz;
+  const double *x1,*x2,*xH1,*xH2;
+
+  int *ilist,*jlist,*numneigh,**firstneigh;
+  int i,j,ii,jj,inum,jnum,itype,jtype,itable,key;
+  int n,vlist[6];
+  int iH1,iH2,jH1,jH2;
+
+  evdwl = ecoul = 0.0;
+
+  const double * const * const x = atom->x;
+  double * const * const f = atom->f;
+  const double * const q = atom->q;
+  const tagint * const tag = atom->tag;
+  const int * const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * const special_coul = force->special_coul;
+  const double * const special_lj = force->special_lj;
+  const double qqrd2e = force->qqrd2e;
+  const double cut_coulsqplus = (cut_coul+2.0*qdist) * (cut_coul+2.0*qdist);
+
+  double fxtmp,fytmp,fztmp;
+
+  inum = list->inum;
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    itype = type[i];
+
+    // if atom I = water O, set x1 = offset charge site
+    // else x1 = x of atom I
+
+    if (itype == typeO) {
+      if (hneigh[i][0] < 0) {
+        iH1 = atom->map(tag[i] + 1);
+        iH2 = atom->map(tag[i] + 2);
+        hneigh[i][2] = 1;
+        if (iH1 == -1 || iH2 == -1)
+          error->one(FLERR,"TIP4P hydrogen is missing");
+        if (atom->type[iH1] != typeH || atom->type[iH2] != typeH)
+          error->one(FLERR,"TIP4P hydrogen has incorrect atom type");
+        // set iH1,iH2 to closest image to O
+        iH1 = domain->closest_image(i,iH1);
+        iH2 = domain->closest_image(i,iH2);
+        compute_newsite_opt(x[i],x[iH1],x[iH2],newsite[i]);
+        hneigh[i][0] = iH1;
+        hneigh[i][1] = iH2;
+        hneigh[i][2] = 1;
+
+      } else {
+        iH1 = hneigh[i][0];
+        iH2 = hneigh[i][1];
+        if (hneigh[i][2] == 0) {
+          hneigh[i][2] = 1;
+          compute_newsite_opt(x[i],x[iH1],x[iH2],newsite[i]);
+        }
+      }
+      x1 = newsite[i];
+    } else x1 = x[i];
+
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      // LJ interaction based on true rsq
+
+      if (rsq < cut_ljsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        r6inv = r2inv*r2inv*r2inv;
+        forcelj = r6inv * (lj1[itype][jtype]*r6inv - lj2[itype][jtype]);
+        forcelj *= factor_lj * r2inv;
+
+        fxtmp += delx*forcelj;
+        fytmp += dely*forcelj;
+        fztmp += delz*forcelj;
+        f[j][0] -= delx*forcelj;
+        f[j][1] -= dely*forcelj;
+        f[j][2] -= delz*forcelj;
+
+        if (EFLAG) {
+          evdwl = r6inv*(lj3[itype][jtype]*r6inv-lj4[itype][jtype]) -
+            offset[itype][jtype];
+          evdwl *= factor_lj;
+        } else evdwl = 0.0;
+
+        if (EVFLAG) ev_tally(i,j,nlocal,/* newton_pair = */ 1,
+                             evdwl,0.0,forcelj,delx,dely,delz);
+      }
+
+      // adjust rsq and delxyz for off-site O charge(s) if necessary
+      // but only if they are within reach
+
+      if (rsq < cut_coulsqplus) {
+        if (itype == typeO || jtype == typeO) {
+
+          // if atom J = water O, set x2 = offset charge site
+          // else x2 = x of atom J
+
+          if (jtype == typeO) {
+            if (hneigh[j][0] < 0) {
+              jH1 = atom->map(tag[j] + 1);
+              jH2 = atom->map(tag[j] + 2);
+              hneigh[j][2] = 1;
+              if (jH1 == -1 || jH2 == -1)
+                error->one(FLERR,"TIP4P hydrogen is missing");
+              if (atom->type[jH1] != typeH || atom->type[jH2] != typeH)
+                error->one(FLERR,"TIP4P hydrogen has incorrect atom type");
+              // set jH1,jH2 to closest image to O
+              jH1 = domain->closest_image(j,jH1);
+              jH2 = domain->closest_image(j,jH2);
+              compute_newsite_opt(x[j],x[jH1],x[jH2],newsite[j]);
+              hneigh[j][0] = jH1;
+              hneigh[j][1] = jH2;
+              hneigh[j][2] = 1;
+
+            } else {
+              jH1 = hneigh[j][0];
+              jH2 = hneigh[j][1];
+              if (hneigh[j][2] == 0) {
+                hneigh[j][2] = 1;
+                compute_newsite_opt(x[j],x[jH1],x[jH2],newsite[j]);
+              }
+            }
+            x2 = newsite[j];
+          } else x2 = x[j];
+
+          delx = x1[0] - x2[0];
+          dely = x1[1] - x2[1];
+          delz = x1[2] - x2[2];
+          rsq = delx*delx + dely*dely + delz*delz;
+        }
+
+        // Coulombic interaction based on modified rsq
+
+        if (rsq < cut_coulsq) {
+          r2inv = 1 / rsq;
+          if (CTABLE || rsq <= tabinnersq) {
+            r = sqrt(rsq);
+            grij = g_ewald * r;
+            expm2 = exp(-grij*grij);
+            t = 1.0 / (1.0 + EWALD_P*grij);
+            erfc = t * (A1+t*(A2+t*(A3+t*(A4+t*A5)))) * expm2;
+            prefactor = qqrd2e * qtmp*q[j]/r;
+            forcecoul = prefactor * (erfc + EWALD_F*grij*expm2);
+            if (factor_coul < 1.0) {
+              forcecoul -= (1.0-factor_coul)*prefactor;
+            }
+          } else {
+            union_int_float_t rsq_lookup;
+            rsq_lookup.f = rsq;
+            itable = rsq_lookup.i & ncoulmask;
+            itable >>= ncoulshiftbits;
+            fraction = (rsq_lookup.f - rtable[itable]) * drtable[itable];
+            table = ftable[itable] + fraction*dftable[itable];
+            forcecoul = qtmp*q[j] * table;
+            if (factor_coul < 1.0) {
+              table = ctable[itable] + fraction*dctable[itable];
+              prefactor = qtmp*q[j] * table;
+              forcecoul -= (1.0-factor_coul)*prefactor;
+            }
+          }
+
+          cforce = forcecoul * r2inv;
+
+          // if i,j are not O atoms, force is applied directly
+          // if i or j are O atoms, force is on fictitious atom & partitioned
+          // force partitioning due to Feenstra, J Comp Chem, 20, 786 (1999)
+          // f_f = fictitious force, fO = f_f (1 - 2 alpha), fH = alpha f_f
+          // preserves total force and torque on water molecule
+          // virial = sum(r x F) where each water's atoms are near xi and xj
+          // vlist stores 2,4,6 atoms whose forces contribute to virial
+
+          if (EVFLAG) {
+            n = 0;
+            key = 0;
+          }
+
+          if (itype != typeO) {
+            fxtmp += delx * cforce;
+            fytmp += dely * cforce;
+            fztmp += delz * cforce;
+
+            if (VFLAG) {
+              v[0] = x[i][0] * delx * cforce;
+              v[1] = x[i][1] * dely * cforce;
+              v[2] = x[i][2] * delz * cforce;
+              v[3] = x[i][0] * dely * cforce;
+              v[4] = x[i][0] * delz * cforce;
+              v[5] = x[i][1] * delz * cforce;
+            }
+            if (EVFLAG) vlist[n++] = i;
+
+          } else {
+            if (EVFLAG) key += 1;
+
+            fdx = delx*cforce;
+            fdy = dely*cforce;
+            fdz = delz*cforce;
+
+            fOx = fdx*(1-alpha);
+            fOy = fdy*(1-alpha);
+            fOz = fdz*(1-alpha);
+
+            fHx = 0.5 * alpha * fdx;
+            fHy = 0.5 * alpha * fdy;
+            fHz = 0.5 * alpha * fdz;
+
+            fxtmp += fOx;
+            fytmp += fOy;
+            fztmp += fOz;
+
+            f[iH1][0] += fHx;
+            f[iH1][1] += fHy;
+            f[iH1][2] += fHz;
+
+            f[iH2][0] += fHx;
+            f[iH2][1] += fHy;
+            f[iH2][2] += fHz;
+
+            if (VFLAG) {
+              xH1 = x[iH1];
+              xH2 = x[iH2];
+              v[0] = x[i][0]*fOx + xH1[0]*fHx + xH2[0]*fHx;
+              v[1] = x[i][1]*fOy + xH1[1]*fHy + xH2[1]*fHy;
+              v[2] = x[i][2]*fOz + xH1[2]*fHz + xH2[2]*fHz;
+              v[3] = x[i][0]*fOy + xH1[0]*fHy + xH2[0]*fHy;
+              v[4] = x[i][0]*fOz + xH1[0]*fHz + xH2[0]*fHz;
+              v[5] = x[i][1]*fOz + xH1[1]*fHz + xH2[1]*fHz;
+            }
+            if (EVFLAG) {
+              vlist[n++] = i;
+              vlist[n++] = iH1;
+              vlist[n++] = iH2;
+            }
+          }
+
+          if (jtype != typeO) {
+            f[j][0] -= delx * cforce;
+            f[j][1] -= dely * cforce;
+            f[j][2] -= delz * cforce;
+
+            if (VFLAG) {
+              v[0] -= x[j][0] * delx * cforce;
+              v[1] -= x[j][1] * dely * cforce;
+              v[2] -= x[j][2] * delz * cforce;
+              v[3] -= x[j][0] * dely * cforce;
+              v[4] -= x[j][0] * delz * cforce;
+              v[5] -= x[j][1] * delz * cforce;
+            }
+            if (EVFLAG) vlist[n++] = j;
+
+          } else {
+            if (EVFLAG) key += 2;
+
+            fdx = -delx*cforce;
+            fdy = -dely*cforce;
+            fdz = -delz*cforce;
+
+            fOx = fdx*(1-alpha);
+            fOy = fdy*(1-alpha);
+            fOz = fdz*(1-alpha);
+
+            fHx = 0.5 * alpha * fdx;
+            fHy = 0.5 * alpha * fdy;
+            fHz = 0.5 * alpha * fdz;
+
+            f[j][0] += fOx;
+            f[j][1] += fOy;
+            f[j][2] += fOz;
+
+            f[jH1][0] += fHx;
+            f[jH1][1] += fHy;
+            f[jH1][2] += fHz;
+
+            f[jH2][0] += fHx;
+            f[jH2][1] += fHy;
+            f[jH2][2] += fHz;
+
+            if (VFLAG) {
+              xH1 = x[jH1];
+              xH2 = x[jH2];
+              v[0] += x[j][0]*fOx + xH1[0]*fHx + xH2[0]*fHx;
+              v[1] += x[j][1]*fOy + xH1[1]*fHy + xH2[1]*fHy;
+              v[2] += x[j][2]*fOz + xH1[2]*fHz + xH2[2]*fHz;
+              v[3] += x[j][0]*fOy + xH1[0]*fHy + xH2[0]*fHy;
+              v[4] += x[j][0]*fOz + xH1[0]*fHz + xH2[0]*fHz;
+              v[5] += x[j][1]*fOz + xH1[1]*fHz + xH2[1]*fHz;
+            }
+            if (EVFLAG) {
+              vlist[n++] = j;
+              vlist[n++] = jH1;
+              vlist[n++] = jH2;
+            }
+          }
+
+          if (EFLAG) {
+            if (CTABLE || rsq <= tabinnersq)
+              ecoul = prefactor*erfc;
+            else {
+              table = etable[itable] + fraction*detable[itable];
+              ecoul = qtmp*q[j] * table;
+            }
+            if (factor_coul < 1.0) ecoul -= (1.0-factor_coul)*prefactor;
+          } else ecoul = 0.0;
+          if (EVFLAG) ev_tally_tip4p(key,vlist,v,ecoul,alpha);
+        }
+      }
+    }
+    f[i][0] += fxtmp;
+    f[i][1] += fytmp;
+    f[i][2] += fztmp;
+  }
+}
+
+/* ----------------------------------------------------------------------
+  compute position xM of fictitious charge site for O atom and 2 H atoms
+  return it as xM
+------------------------------------------------------------------------- */
+
+void PairLJCutTIP4PLongOpt::compute_newsite_opt(const double * xO,
+                                                    const double * xH1,
+                                                    const double * xH2,
+                                                    double * xM) const
+{
+  double delx1 = xH1[0] - xO[0];
+  double dely1 = xH1[1] - xO[1];
+  double delz1 = xH1[2] - xO[2];
+
+  double delx2 = xH2[0] - xO[0];
+  double dely2 = xH2[1] - xO[1];
+  double delz2 = xH2[2] - xO[2];
+
+  const double prefac = alpha * 0.5;
+  xM[0] = xO[0] + prefac * (delx1 + delx2);
+  xM[1] = xO[1] + prefac * (dely1 + dely2);
+  xM[2] = xO[2] + prefac * (delz1 + delz2);
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairLJCutTIP4PLongOpt::memory_usage()
+{
+  double bytes = PairLJCutTIP4PLong::memory_usage();
+
+  return bytes;
+}
diff -uN src/pair_lj_cut_tip4p_long_opt.h src_DFT-CES2/pair_lj_cut_tip4p_long_opt.h
--- src/pair_lj_cut_tip4p_long_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_cut_tip4p_long_opt.h	2025-02-11 06:42:37.174608877 +0900
@@ -0,0 +1,59 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(lj/cut/tip4p/long/opt,PairLJCutTIP4PLongOpt)
+
+#else
+
+#ifndef LMP_PAIR_LJ_CUT_TIP4P_LONG_OPT_H
+#define LMP_PAIR_LJ_CUT_TIP4P_LONG_OPT_H
+
+#include "pair_lj_cut_tip4p_long.h"
+
+namespace LAMMPS_NS {
+
+  class PairLJCutTIP4PLongOpt : public PairLJCutTIP4PLong {
+ public:
+    PairLJCutTIP4PLongOpt(class LAMMPS *);
+    virtual ~PairLJCutTIP4PLongOpt() {};
+
+  virtual void compute(int, int);
+  virtual double memory_usage();
+
+ protected:
+  template < const int, const int, const int, const int >
+  void eval();
+  void compute_newsite_opt(const double *, const double *,
+                           const double *, double *) const;
+};
+
+}
+
+#endif
+#endif
+
+/* ERROR/WARNING messages:
+
+E: TIP4P hydrogen is missing
+
+The TIP4P pairwise computation failed to find the correct H atom
+within a water molecule.
+
+E: TIP4P hydrogen has incorrect atom type
+
+The TIP4P pairwise computation found an H atom whose type does not
+agree with the specified H type.
+
+*/
diff -uN src/pair_lj_long_coul_long_opt.cpp src_DFT-CES2/pair_lj_long_coul_long_opt.cpp
--- src/pair_lj_long_coul_long_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_long_coul_long_opt.cpp	2025-02-11 06:42:37.174608877 +0900
@@ -0,0 +1,880 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   OPT version: Wayne Mitchell (Loyola University New Orleans)
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include "pair_lj_long_coul_long_opt.h"
+#include "atom.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "math_vector.h"
+
+using namespace LAMMPS_NS;
+
+#define EWALD_F   1.12837917
+#define EWALD_P   0.3275911
+#define A1        0.254829592
+#define A2       -0.284496736
+#define A3        1.421413741
+#define A4       -1.453152027
+#define A5        1.061405429
+
+/* ---------------------------------------------------------------------- */
+
+PairLJLongCoulLongOpt::PairLJLongCoulLongOpt(LAMMPS *lmp) : PairLJLongCoulLong(lmp)
+{
+  respa_enable = 1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJLongCoulLongOpt::compute(int eflag, int vflag)
+{
+
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+  int order1 = ewald_order&(1<<1), order6 = ewald_order&(1<<6);
+
+  if (order6) {
+    if (order1) {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,0,1,1>();
+              else return eval<1,1,0,0,0,1,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,0,1,1>();
+              else return eval<1,0,0,0,0,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,0,1,1>();
+            else return eval<0,0,0,0,0,1,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,0,1,1>();
+              else return eval<1,1,0,1,0,1,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,0,1,1>();
+              else return eval<1,0,0,1,0,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,0,1,1>();
+            else return eval<0,0,0,1,0,1,1>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,1,1,1>();
+              else return eval<1,1,0,0,1,1,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,1,1,1>();
+              else return eval<1,0,0,0,1,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,1,1,1>();
+            else return eval<0,0,0,0,1,1,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,1,1,1>();
+              else return eval<1,1,0,1,1,1,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,1,1,1>();
+              else return eval<1,0,0,1,1,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,1,1,1>();
+            else return eval<0,0,0,1,1,1,1>();
+          }
+        }
+      }
+    } else {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,0,0,1>();
+              else return eval<1,1,0,0,0,0,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,0,0,1>();
+              else return eval<1,0,0,0,0,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,0,0,1>();
+            else return eval<0,0,0,0,0,0,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,0,0,1>();
+              else return eval<1,1,0,1,0,0,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,0,0,1>();
+              else return eval<1,0,0,1,0,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,0,0,1>();
+            else return eval<0,0,0,1,0,0,1>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,1,0,1>();
+              else return eval<1,1,0,0,1,0,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,1,0,1>();
+              else return eval<1,0,0,0,1,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,1,0,1>();
+            else return eval<0,0,0,0,1,0,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,1,0,1>();
+              else return eval<1,1,0,1,1,0,1>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,1,0,1>();
+              else return eval<1,0,0,1,1,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,1,0,1>();
+            else return eval<0,0,0,1,1,0,1>();
+          }
+        }
+      }
+    }
+  } else {
+    if (order1) {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,0,1,0>();
+              else return eval<1,1,0,0,0,1,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,0,1,0>();
+              else return eval<1,0,0,0,0,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,0,1,0>();
+            else return eval<0,0,0,0,0,1,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,0,1,0>();
+              else return eval<1,1,0,1,0,1,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,0,1,0>();
+              else return eval<1,0,0,1,0,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,0,1,0>();
+            else return eval<0,0,0,1,0,1,0>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,1,1,0>();
+              else return eval<1,1,0,0,1,1,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,1,1,0>();
+              else return eval<1,0,0,0,1,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,1,1,0>();
+            else return eval<0,0,0,0,1,1,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,1,1,0>();
+              else return eval<1,1,0,1,1,1,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,1,1,0>();
+              else return eval<1,0,0,1,1,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,1,1,0>();
+            else return eval<0,0,0,1,1,1,0>();
+          }
+        }
+      }
+    } else {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,0,0,0>();
+              else return eval<1,1,0,0,0,0,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,0,0,0>();
+              else return eval<1,0,0,0,0,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,0,0,0>();
+            else return eval<0,0,0,0,0,0,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,0,0,0>();
+              else return eval<1,1,0,1,0,0,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,0,0,0>();
+              else return eval<1,0,0,1,0,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,0,0,0>();
+            else return eval<0,0,0,1,0,0,0>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,0,1,0,0>();
+              else return eval<1,1,0,0,1,0,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,0,1,0,0>();
+              else return eval<1,0,0,0,1,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,0,1,0,0>();
+            else return eval<0,0,0,0,1,0,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval<1,1,1,1,1,0,0>();
+              else return eval<1,1,0,1,1,0,0>();
+            } else {
+              if (force->newton_pair) return eval<1,0,1,1,1,0,0>();
+              else return eval<1,0,0,1,1,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval<0,0,1,1,1,0,0>();
+            else return eval<0,0,0,1,1,0,0>();
+          }
+        }
+      }
+    }
+  }
+}
+
+void PairLJLongCoulLongOpt::compute_outer(int eflag, int vflag)
+{
+
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+  int order1 = ewald_order&(1<<1), order6 = ewald_order&(1<<6);
+
+  if (order6) {
+    if (order1) {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,0,1,1>();
+              else return eval_outer<1,1,0,0,0,1,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,0,1,1>();
+              else return eval_outer<1,0,0,0,0,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,0,1,1>();
+            else return eval_outer<0,0,0,0,0,1,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,0,1,1>();
+              else return eval_outer<1,1,0,1,0,1,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,0,1,1>();
+              else return eval_outer<1,0,0,1,0,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,0,1,1>();
+            else return eval_outer<0,0,0,1,0,1,1>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,1,1,1>();
+              else return eval_outer<1,1,0,0,1,1,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,1,1,1>();
+              else return eval_outer<1,0,0,0,1,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,1,1,1>();
+            else return eval_outer<0,0,0,0,1,1,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,1,1,1>();
+              else return eval_outer<1,1,0,1,1,1,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,1,1,1>();
+              else return eval_outer<1,0,0,1,1,1,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,1,1,1>();
+            else return eval_outer<0,0,0,1,1,1,1>();
+          }
+        }
+      }
+    } else {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,0,0,1>();
+              else return eval_outer<1,1,0,0,0,0,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,0,0,1>();
+              else return eval_outer<1,0,0,0,0,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,0,0,1>();
+            else return eval_outer<0,0,0,0,0,0,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,0,0,1>();
+              else return eval_outer<1,1,0,1,0,0,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,0,0,1>();
+              else return eval_outer<1,0,0,1,0,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,0,0,1>();
+            else return eval_outer<0,0,0,1,0,0,1>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,1,0,1>();
+              else return eval_outer<1,1,0,0,1,0,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,1,0,1>();
+              else return eval_outer<1,0,0,0,1,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,1,0,1>();
+            else return eval_outer<0,0,0,0,1,0,1>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,1,0,1>();
+              else return eval_outer<1,1,0,1,1,0,1>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,1,0,1>();
+              else return eval_outer<1,0,0,1,1,0,1>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,1,0,1>();
+            else return eval_outer<0,0,0,1,1,0,1>();
+          }
+        }
+      }
+    }
+  } else {
+    if (order1) {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,0,1,0>();
+              else return eval_outer<1,1,0,0,0,1,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,0,1,0>();
+              else return eval_outer<1,0,0,0,0,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,0,1,0>();
+            else return eval_outer<0,0,0,0,0,1,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,0,1,0>();
+              else return eval_outer<1,1,0,1,0,1,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,0,1,0>();
+              else return eval_outer<1,0,0,1,0,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,0,1,0>();
+            else return eval_outer<0,0,0,1,0,1,0>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,1,1,0>();
+              else return eval_outer<1,1,0,0,1,1,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,1,1,0>();
+              else return eval_outer<1,0,0,0,1,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,1,1,0>();
+            else return eval_outer<0,0,0,0,1,1,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,1,1,0>();
+              else return eval_outer<1,1,0,1,1,1,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,1,1,0>();
+              else return eval_outer<1,0,0,1,1,1,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,1,1,0>();
+            else return eval_outer<0,0,0,1,1,1,0>();
+          }
+        }
+      }
+    } else {
+      if (!ndisptablebits) {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,0,0,0>();
+              else return eval_outer<1,1,0,0,0,0,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,0,0,0>();
+              else return eval_outer<1,0,0,0,0,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,0,0,0>();
+            else return eval_outer<0,0,0,0,0,0,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,0,0,0>();
+              else return eval_outer<1,1,0,1,0,0,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,0,0,0>();
+              else return eval_outer<1,0,0,1,0,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,0,0,0>();
+            else return eval_outer<0,0,0,1,0,0,0>();
+          }
+        }
+      } else {
+        if (!ncoultablebits) {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,0,1,0,0>();
+              else return eval_outer<1,1,0,0,1,0,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,0,1,0,0>();
+              else return eval_outer<1,0,0,0,1,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,0,1,0,0>();
+            else return eval_outer<0,0,0,0,1,0,0>();
+          }
+        } else {
+          if (evflag) {
+            if (eflag) {
+              if (force->newton_pair) return eval_outer<1,1,1,1,1,0,0>();
+              else return eval_outer<1,1,0,1,1,0,0>();
+            } else {
+              if (force->newton_pair) return eval_outer<1,0,1,1,1,0,0>();
+              else return eval_outer<1,0,0,1,1,0,0>();
+            }
+          } else {
+            if (force->newton_pair) return eval_outer<0,0,1,1,1,0,0>();
+            else return eval_outer<0,0,0,1,1,0,0>();
+          }
+        }
+      }
+    }
+  }
+}
+
+
+template < const int EVFLAG, const int EFLAG,
+           const int NEWTON_PAIR, const int CTABLE, const int LJTABLE, const int ORDER1, const int ORDER6 >
+void PairLJLongCoulLongOpt::eval()
+{
+  double evdwl,ecoul,fpair;
+  evdwl = ecoul = 0.0;
+
+  double **x = atom->x, *x0 = x[0];
+  double **f = atom->f, *f0 = f[0], *fi = f0;
+  double *q = atom->q;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  double *special_coul = force->special_coul;
+  double *special_lj = force->special_lj;
+  double qqrd2e = force->qqrd2e;
+
+  int i, j;
+  int *ineigh, *ineighn, *jneigh, *jneighn, typei, typej, ni;
+  double qi = 0.0, qri = 0.0;
+  double *cutsqi, *cut_ljsqi, *lj1i, *lj2i, *lj3i, *lj4i, *offseti;
+  double rsq, r2inv, force_coul, force_lj;
+  double g2 = g_ewald_6*g_ewald_6, g6 = g2*g2*g2, g8 = g6*g2;
+  vector xi, d;
+
+  ineighn = (ineigh = list->ilist)+list->inum;
+
+  for (; ineigh<ineighn; ++ineigh) {                        // loop over my atoms
+    i = *ineigh; fi = f0+3*i;
+    if (ORDER1) qri = (qi = q[i])*qqrd2e;                // initialize constants
+    offseti = offset[typei = type[i]];
+    lj1i = lj1[typei]; lj2i = lj2[typei]; lj3i = lj3[typei]; lj4i = lj4[typei];
+    cutsqi = cutsq[typei]; cut_ljsqi = cut_ljsq[typei];
+    memcpy(xi, x0+(i+(i<<1)), sizeof(vector));
+    jneighn = (jneigh = list->firstneigh[i])+list->numneigh[i];
+
+    for (; jneigh<jneighn; ++jneigh) {                        // loop over neighbors
+      j = *jneigh;
+      ni = sbmask(j);
+      j &= NEIGHMASK;
+
+      { register double *xj = x0+(j+(j<<1));
+        d[0] = xi[0] - xj[0];                                // pair vector
+        d[1] = xi[1] - xj[1];
+        d[2] = xi[2] - xj[2]; }
+
+      if ((rsq = vec_dot(d, d)) >= cutsqi[typej = type[j]]) continue;
+      r2inv = 1.0/rsq;
+
+      if (ORDER1 && (rsq < cut_coulsq)) {                // coulombic
+        if (!CTABLE || rsq <= tabinnersq) {        // series real space
+          register double r = sqrt(rsq), x = g_ewald*r;
+          register double s = qri*q[j], t = 1.0/(1.0+EWALD_P*x);
+          if (ni == 0) {
+            s *= g_ewald*exp(-x*x);
+            force_coul = (t *= ((((t*A5+A4)*t+A3)*t+A2)*t+A1)*s/x)+EWALD_F*s;
+            if (EFLAG) ecoul = t;
+          }
+          else {                                        // special case
+            r = s*(1.0-special_coul[ni])/r; s *= g_ewald*exp(-x*x);
+            force_coul = (t *= ((((t*A5+A4)*t+A3)*t+A2)*t+A1)*s/x)+EWALD_F*s-r;
+            if (EFLAG) ecoul = t-r;
+          }
+        }                                                // table real space
+        else {
+          register union_int_float_t t;
+          t.f = rsq;
+          register const int k = (t.i & ncoulmask)>>ncoulshiftbits;
+          register double f = (rsq-rtable[k])*drtable[k], qiqj = qi*q[j];
+          if (ni == 0) {
+            force_coul = qiqj*(ftable[k]+f*dftable[k]);
+            if (EFLAG) ecoul = qiqj*(etable[k]+f*detable[k]);
+          }
+          else {                                        // special case
+            t.f = (1.0-special_coul[ni])*(ctable[k]+f*dctable[k]);
+            force_coul = qiqj*(ftable[k]+f*dftable[k]-t.f);
+            if (EFLAG) ecoul = qiqj*(etable[k]+f*detable[k]-t.f);
+          }
+        }
+      }
+      else force_coul = ecoul = 0.0;
+
+      if (rsq < cut_ljsqi[typej]) {                        // lj
+        if (ORDER6) {                                        // long-range lj
+          if(!LJTABLE || rsq <= tabinnerdispsq) {				// series real space
+            register double rn = r2inv*r2inv*r2inv;
+            register double x2 = g2*rsq, a2 = 1.0/x2;
+            x2 = a2*exp(-x2)*lj4i[typej];
+            if (ni == 0) {
+              force_lj =
+              (rn*=rn)*lj1i[typej]-g8*(((6.0*a2+6.0)*a2+3.0)*a2+1.0)*x2*rsq;
+              if (EFLAG)
+                evdwl = rn*lj3i[typej]-g6*((a2+1.0)*a2+0.5)*x2;
+            }
+            else {                                        // special case
+              register double f = special_lj[ni], t = rn*(1.0-f);
+              force_lj = f*(rn *= rn)*lj1i[typej]-
+              g8*(((6.0*a2+6.0)*a2+3.0)*a2+1.0)*x2*rsq+t*lj2i[typej];
+              if (EFLAG)
+                evdwl = f*rn*lj3i[typej]-g6*((a2+1.0)*a2+0.5)*x2+t*lj4i[typej];
+            }
+          }
+          else {						// table real space
+            register union_int_float_t disp_t;
+            disp_t.f = rsq;
+            register const int disp_k = (disp_t.i & ndispmask)>>ndispshiftbits;
+            register double f_disp = (rsq-rdisptable[disp_k])*drdisptable[disp_k];
+            register double rn = r2inv*r2inv*r2inv;
+            if (ni == 0) {
+              force_lj = (rn*=rn)*lj1i[typej]-(fdisptable[disp_k]+f_disp*dfdisptable[disp_k])*lj4i[typej];
+              if (EFLAG) evdwl = rn*lj3i[typej]-(edisptable[disp_k]+f_disp*dedisptable[disp_k])*lj4i[typej];
+            }
+            else {					// special case
+              register double f = special_lj[ni], t = rn*(1.0-f);
+              force_lj = f*(rn *= rn)*lj1i[typej]-(fdisptable[disp_k]+f_disp*dfdisptable[disp_k])*lj4i[typej]+t*lj2i[typej];
+              if (EFLAG) evdwl = f*rn*lj3i[typej]-(edisptable[disp_k]+f_disp*dedisptable[disp_k])*lj4i[typej]+t*lj4i[typej];
+            }
+          }
+        }
+        else {                                                // cut lj
+          register double rn = r2inv*r2inv*r2inv;
+          if (ni == 0) {
+            force_lj = rn*(rn*lj1i[typej]-lj2i[typej]);
+            if (EFLAG) evdwl = rn*(rn*lj3i[typej]-lj4i[typej])-offseti[typej];
+          }
+          else {                                        // special case
+            register double f = special_lj[ni];
+            force_lj = f*rn*(rn*lj1i[typej]-lj2i[typej]);
+            if (EFLAG)
+              evdwl = f * (rn*(rn*lj3i[typej]-lj4i[typej])-offseti[typej]);
+          }
+        }
+      }
+      else force_lj = evdwl = 0.0;
+
+      fpair = (force_coul+force_lj)*r2inv;
+
+      if (NEWTON_PAIR || j < nlocal) {
+        register double *fj = f0+(j+(j<<1)), f;
+        fi[0] += f = d[0]*fpair; fj[0] -= f;
+        fi[1] += f = d[1]*fpair; fj[1] -= f;
+        fi[2] += f = d[2]*fpair; fj[2] -= f;
+      }
+      else {
+        fi[0] += d[0]*fpair;
+        fi[1] += d[1]*fpair;
+        fi[2] += d[2]*fpair;
+      }
+
+      if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                           evdwl,ecoul,fpair,d[0],d[1],d[2]);
+    }
+  }
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+template < const int EVFLAG, const int EFLAG,
+           const int NEWTON_PAIR, const int CTABLE, const int LJTABLE, const int ORDER1, const int ORDER6 >
+void PairLJLongCoulLongOpt::eval_outer()
+{
+  double evdwl,ecoul,fvirial,fpair;
+  evdwl = ecoul = 0.0;
+
+  double **x = atom->x, *x0 = x[0];
+  double **f = atom->f, *f0 = f[0], *fi = f0;
+  double *q = atom->q;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  double *special_coul = force->special_coul;
+  double *special_lj = force->special_lj;
+  int newton_pair = force->newton_pair;
+  double qqrd2e = force->qqrd2e;
+
+  int i, j;
+  int *ineigh, *ineighn, *jneigh, *jneighn, typei, typej, ni, respa_flag;
+  double qi = 0.0, qri = 0.0;
+  double *cutsqi, *cut_ljsqi, *lj1i, *lj2i, *lj3i, *lj4i, *offseti;
+  double rsq, r2inv, force_coul, force_lj;
+  double g2 = g_ewald_6*g_ewald_6, g6 = g2*g2*g2, g8 = g6*g2;
+  double respa_lj = 0.0, respa_coul = 0.0, frespa = 0.0;
+  vector xi, d;
+
+  double cut_in_off = cut_respa[2];
+  double cut_in_on = cut_respa[3];
+
+  double cut_in_diff = cut_in_on - cut_in_off;
+  double cut_in_off_sq = cut_in_off*cut_in_off;
+  double cut_in_on_sq = cut_in_on*cut_in_on;
+
+  ineighn = (ineigh = listouter->ilist)+listouter->inum;
+
+  for (; ineigh<ineighn; ++ineigh) {                        // loop over my atoms
+    i = *ineigh; fi = f0+3*i;
+    if (ORDER1) qri = (qi = q[i])*qqrd2e;                // initialize constants
+    offseti = offset[typei = type[i]];
+    lj1i = lj1[typei]; lj2i = lj2[typei]; lj3i = lj3[typei]; lj4i = lj4[typei];
+    cutsqi = cutsq[typei]; cut_ljsqi = cut_ljsq[typei];
+    memcpy(xi, x0+(i+(i<<1)), sizeof(vector));
+    jneighn = (jneigh = listouter->firstneigh[i])+listouter->numneigh[i];
+
+    for (; jneigh<jneighn; ++jneigh) {                        // loop over neighbors
+      j = *jneigh;
+      ni = sbmask(j);
+      j &= NEIGHMASK;
+
+      { register double *xj = x0+(j+(j<<1));
+        d[0] = xi[0] - xj[0];                                // pair vector
+        d[1] = xi[1] - xj[1];
+        d[2] = xi[2] - xj[2]; }
+
+      if ((rsq = vec_dot(d, d)) >= cutsqi[typej = type[j]]) continue;
+      r2inv = 1.0/rsq;
+
+      frespa = 1.0;                                       // check whether and how to compute respa corrections
+      respa_coul = 0;
+      respa_lj = 0;
+      respa_flag = rsq < cut_in_on_sq ? 1 : 0;
+      if (respa_flag && (rsq > cut_in_off_sq)) {
+        register double rsw = (sqrt(rsq)-cut_in_off)/cut_in_diff;
+        frespa = 1-rsw*rsw*(3.0-2.0*rsw);
+      }
+
+      if (ORDER1 && (rsq < cut_coulsq)) {                // coulombic
+        if (!CTABLE || rsq <= tabinnersq) {        // series real space
+          register double r = sqrt(rsq), s = qri*q[j];
+          if (respa_flag)                                // correct for respa
+            respa_coul = ni == 0 ? frespa*s/r : frespa*s/r*special_coul[ni];
+          register double x = g_ewald*r, t = 1.0/(1.0+EWALD_P*x);
+          if (ni == 0) {
+            s *= g_ewald*exp(-x*x);
+            force_coul = (t *= ((((t*A5+A4)*t+A3)*t+A2)*t+A1)*s/x)+EWALD_F*s-respa_coul;
+            if (EFLAG) ecoul = t;
+          }
+          else {                                        // correct for special
+            r = s*(1.0-special_coul[ni])/r; s *= g_ewald*exp(-x*x);
+            force_coul = (t *= ((((t*A5+A4)*t+A3)*t+A2)*t+A1)*s/x)+EWALD_F*s-r-respa_coul;
+            if (EFLAG) ecoul = t-r;
+          }
+        }                                                // table real space
+        else {
+          if (respa_flag) {
+            register double r = sqrt(rsq), s = qri*q[j];
+            respa_coul = ni == 0 ? frespa*s/r : frespa*s/r*special_coul[ni];
+          }
+          register union_int_float_t t;
+          t.f = rsq;
+          register const int k = (t.i & ncoulmask) >> ncoulshiftbits;
+          register double f = (rsq-rtable[k])*drtable[k], qiqj = qi*q[j];
+          if (ni == 0) {
+            force_coul = qiqj*(ftable[k]+f*dftable[k]);
+            if (EFLAG) ecoul = qiqj*(etable[k]+f*detable[k]);
+          }
+          else {                                        // correct for special
+            t.f = (1.0-special_coul[ni])*(ctable[k]+f*dctable[k]);
+            force_coul = qiqj*(ftable[k]+f*dftable[k]-t.f);
+            if (EFLAG) {
+              t.f = (1.0-special_coul[ni])*(ptable[k]+f*dptable[k]);
+              ecoul = qiqj*(etable[k]+f*detable[k]-t.f);
+            }
+          }
+        }
+      }
+
+      else force_coul = respa_coul = ecoul = 0.0;
+
+      if (rsq < cut_ljsqi[typej]) {                        // lennard-jones
+        register double rn = r2inv*r2inv*r2inv;
+        if (respa_flag) respa_lj = ni == 0 ?                 // correct for respa
+            frespa*rn*(rn*lj1i[typej]-lj2i[typej]) :
+            frespa*rn*(rn*lj1i[typej]-lj2i[typej])*special_lj[ni];
+        if (ORDER6) {                                        // long-range form
+          if (!LJTABLE || rsq <= tabinnerdispsq) {
+            register double x2 = g2*rsq, a2 = 1.0/x2;
+            x2 = a2*exp(-x2)*lj4i[typej];
+            if (ni == 0) {
+              force_lj =
+                (rn*=rn)*lj1i[typej]-g8*(((6.0*a2+6.0)*a2+3.0)*a2+1.0)*x2*rsq-respa_lj;
+              if (EFLAG) evdwl = rn*lj3i[typej]-g6*((a2+1.0)*a2+0.5)*x2;
+            }
+            else {                                        // correct for special
+              register double f = special_lj[ni], t = rn*(1.0-f);
+              force_lj = f*(rn *= rn)*lj1i[typej]-
+                g8*(((6.0*a2+6.0)*a2+3.0)*a2+1.0)*x2*rsq+t*lj2i[typej]-respa_lj;
+              if (EFLAG)
+                evdwl = f*rn*lj3i[typej]-g6*((a2+1.0)*a2+0.5)*x2+t*lj4i[typej];
+            }
+          }
+          else {						// table real space
+            register union_int_float_t disp_t;
+            disp_t.f = rsq;
+            register const int disp_k = (disp_t.i & ndispmask)>>ndispshiftbits;
+            register double f_disp = (rsq-rdisptable[disp_k])*drdisptable[disp_k];
+            register double rn = r2inv*r2inv*r2inv;
+            if (ni == 0) {
+              force_lj = (rn*=rn)*lj1i[typej]-(fdisptable[disp_k]+f_disp*dfdisptable[disp_k])*lj4i[typej]-respa_lj;
+              if (EFLAG) evdwl = rn*lj3i[typej]-(edisptable[disp_k]+f_disp*dedisptable[disp_k])*lj4i[typej];
+            }
+            else {					// special case
+              register double f = special_lj[ni], t = rn*(1.0-f);
+              force_lj = f*(rn *= rn)*lj1i[typej]-(fdisptable[disp_k]+f_disp*dfdisptable[disp_k])*lj4i[typej]+t*lj2i[typej]-respa_lj;
+              if (EFLAG) evdwl = f*rn*lj3i[typej]-(edisptable[disp_k]+f_disp*dedisptable[disp_k])*lj4i[typej]+t*lj4i[typej];
+            }
+          }
+        }
+        else {                                                // cut form
+          if (ni == 0) {
+            force_lj = rn*(rn*lj1i[typej]-lj2i[typej])-respa_lj;
+            if (EFLAG) evdwl = rn*(rn*lj3i[typej]-lj4i[typej])-offseti[typej];
+          }
+          else {                                        // correct for special
+            register double f = special_lj[ni];
+            force_lj = f*rn*(rn*lj1i[typej]-lj2i[typej])-respa_lj;
+            if (EFLAG)
+              evdwl = f*(rn*(rn*lj3i[typej]-lj4i[typej])-offseti[typej]);
+          }
+        }
+      }
+      else force_lj = respa_lj = evdwl = 0.0;
+
+      fpair = (force_coul+force_lj)*r2inv;
+
+      if (NEWTON_PAIR || j < nlocal) {
+        register double *fj = f0+(j+(j<<1)), f;
+        fi[0] += f = d[0]*fpair; fj[0] -= f;
+        fi[1] += f = d[1]*fpair; fj[1] -= f;
+        fi[2] += f = d[2]*fpair; fj[2] -= f;
+      }
+      else {
+        fi[0] += d[0]*fpair;
+        fi[1] += d[1]*fpair;
+        fi[2] += d[2]*fpair;
+      }
+
+      if (EVFLAG) {
+        fvirial = (force_coul + force_lj + respa_coul + respa_lj)*r2inv;
+        ev_tally(i,j,nlocal,newton_pair,
+                 evdwl,ecoul,fvirial,d[0],d[1],d[2]);
+      }
+    }
+  }
+}
diff -uN src/pair_lj_long_coul_long_opt.h src_DFT-CES2/pair_lj_long_coul_long_opt.h
--- src/pair_lj_long_coul_long_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_lj_long_coul_long_opt.h	2025-02-11 06:42:37.174608877 +0900
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(lj/long/coul/long/opt,PairLJLongCoulLongOpt)
+
+#else
+
+#ifndef LMP_PAIR_LJ_LONG_COUL_LONG_OPT_H
+#define LMP_PAIR_LJ_LONG_COUL_LONG_OPT_H
+
+#include "pair_lj_long_coul_long.h"
+
+namespace LAMMPS_NS {
+
+class PairLJLongCoulLongOpt : public PairLJLongCoulLong {
+ public:
+  PairLJLongCoulLongOpt(class LAMMPS *);
+  virtual void compute(int, int);
+  virtual void compute_outer(int,int);
+
+ protected:
+  template <const int EVFLAG, const int EFLAG,
+    const int NEWTON_PAIR, const int CTABLE, const int LJTABLE,
+    const int ORDER1, const int ORDER6 >
+  void eval();
+
+  template <const int EVFLAG, const int EFLAG,
+    const int NEWTON_PAIR, const int CTABLE, const int LJTABLE,
+    const int ORDER1, const int ORDER6 >
+  void eval_outer();
+};
+
+}
+
+#endif
+#endif
diff -uN src/pair_morse_opt.cpp src_DFT-CES2/pair_morse_opt.cpp
--- src/pair_morse_opt.cpp	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_morse_opt.cpp	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,198 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors:
+     James Fischer, High Performance Technologies, Inc.
+     David Richie, Stone Ridge Technology
+     Vincent Natoli, Stone Ridge Technology
+------------------------------------------------------------------------- */
+
+#include <math.h>
+#include <stdlib.h>
+#include "pair_morse_opt.h"
+#include "atom.h"
+#include "force.h"
+#include "neigh_list.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairMorseOpt::PairMorseOpt(LAMMPS *lmp) : PairMorse(lmp) {}
+
+/* ---------------------------------------------------------------------- */
+
+void PairMorseOpt::compute(int eflag, int vflag)
+{
+  if (eflag || vflag) ev_setup(eflag,vflag);
+  else evflag = vflag_fdotr = 0;
+
+  if (evflag) {
+    if (eflag) {
+      if (force->newton_pair) return eval<1,1,1>();
+      else return eval<1,1,0>();
+    } else {
+      if (force->newton_pair) return eval<1,0,1>();
+      else return eval<1,0,0>();
+    }
+  } else {
+    if (force->newton_pair) return eval<0,0,1>();
+    else return eval<0,0,0>();
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+template < int EVFLAG, int EFLAG, int NEWTON_PAIR >
+void PairMorseOpt::eval()
+{
+  typedef struct { double x,y,z; } vec3_t;
+
+  typedef struct {
+    double cutsq,r0,alpha,morse1,d0,offset;
+    double _pad[2];
+  } fast_alpha_t;
+
+  int i,j,ii,jj,inum,jnum,itype,jtype,sbindex;
+  double factor_lj;
+  double evdwl = 0.0;
+
+  double** _noalias x = atom->x;
+  double** _noalias f = atom->f;
+  int* _noalias type = atom->type;
+  int nlocal = atom->nlocal;
+  double* _noalias special_lj = force->special_lj;
+
+  inum = list->inum;
+  int* _noalias ilist = list->ilist;
+  int** _noalias firstneigh = list->firstneigh;
+  int* _noalias numneigh = list->numneigh;
+
+  vec3_t* _noalias xx = (vec3_t*)x[0];
+  vec3_t* _noalias ff = (vec3_t*)f[0];
+
+  int ntypes = atom->ntypes;
+  int ntypes2 = ntypes*ntypes;
+
+  fast_alpha_t* _noalias fast_alpha =
+    (fast_alpha_t*) malloc(ntypes2*sizeof(fast_alpha_t));
+  for (i = 0; i < ntypes; i++) for (j = 0; j < ntypes; j++) {
+    fast_alpha_t& a = fast_alpha[i*ntypes+j];
+    a.cutsq = cutsq[i+1][j+1];
+    a.r0 = r0[i+1][j+1];
+    a.alpha = alpha[i+1][j+1];
+    a.morse1 = morse1[i+1][j+1];
+    a.d0 = d0[i+1][j+1];
+    a.offset = offset[i+1][j+1];
+  }
+  fast_alpha_t* _noalias tabsix = fast_alpha;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    double xtmp = xx[i].x;
+    double ytmp = xx[i].y;
+    double ztmp = xx[i].z;
+    itype = type[i] - 1;
+    int* _noalias jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+    double tmpfx = 0.0;
+    double tmpfy = 0.0;
+    double tmpfz = 0.0;
+
+    fast_alpha_t* _noalias tabsixi = (fast_alpha_t*)&tabsix[itype*ntypes];
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      sbindex = sbmask(j);
+
+      if (sbindex == 0) {
+        double delx = xtmp - xx[j].x;
+        double dely = ytmp - xx[j].y;
+        double delz = ztmp - xx[j].z;
+        double rsq = delx*delx + dely*dely + delz*delz;
+
+        jtype = type[j] - 1;
+
+        fast_alpha_t& a = tabsixi[jtype];
+        if (rsq < a.cutsq) {
+          double r = sqrt(rsq);
+          double dr = r - a.r0;
+          double dexp = exp(-a.alpha * dr);
+          double fpair = a.morse1 * (dexp*dexp - dexp) / r;
+
+          tmpfx += delx*fpair;
+          tmpfy += dely*fpair;
+          tmpfz += delz*fpair;
+          if (NEWTON_PAIR || j < nlocal) {
+            ff[j].x -= delx*fpair;
+            ff[j].y -= dely*fpair;
+            ff[j].z -= delz*fpair;
+          }
+
+          if (EFLAG) evdwl = a.d0 * (dexp*dexp - 2.0*dexp) - a.offset;
+
+          if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                               evdwl,0.0,fpair,delx,dely,delz);
+        }
+
+      } else {
+        factor_lj = special_lj[sbindex];
+        j &= NEIGHMASK;
+
+        double delx = xtmp - xx[j].x;
+        double dely = ytmp - xx[j].y;
+        double delz = ztmp - xx[j].z;
+        double rsq = delx*delx + dely*dely + delz*delz;
+
+        jtype = type[j] - 1;
+
+        fast_alpha_t& a = tabsixi[jtype];
+        if (rsq < a.cutsq) {
+          double r = sqrt(rsq);
+          double dr = r - a.r0;
+          double dexp = exp(-a.alpha * dr);
+          double fpair = factor_lj * a.morse1 * (dexp*dexp - dexp) / r;
+
+          tmpfx += delx*fpair;
+          tmpfy += dely*fpair;
+          tmpfz += delz*fpair;
+          if (NEWTON_PAIR || j < nlocal) {
+            ff[j].x -= delx*fpair;
+            ff[j].y -= dely*fpair;
+            ff[j].z -= delz*fpair;
+          }
+
+          if (EFLAG) {
+            evdwl = a.d0 * (dexp*dexp - 2.0*dexp) - a.offset;
+            evdwl *= factor_lj;
+          }
+
+          if (EVFLAG) ev_tally(i,j,nlocal,NEWTON_PAIR,
+                               evdwl,0.0,fpair,delx,dely,delz);
+        }
+      }
+    }
+
+    ff[i].x += tmpfx;
+    ff[i].y += tmpfy;
+    ff[i].z += tmpfz;
+  }
+
+  free(fast_alpha); fast_alpha = 0;
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
diff -uN src/pair_morse_opt.h src_DFT-CES2/pair_morse_opt.h
--- src/pair_morse_opt.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/pair_morse_opt.h	2025-02-11 06:42:37.179608926 +0900
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+
+PairStyle(morse/opt,PairMorseOpt)
+
+#else
+
+#ifndef LMP_PAIR_MORSE_OPT_H
+#define LMP_PAIR_MORSE_OPT_H
+
+#include "pair_morse.h"
+
+namespace LAMMPS_NS {
+
+class PairMorseOpt : public PairMorse {
+ public:
+  PairMorseOpt(class LAMMPS *);
+  void compute(int, int);
+
+ private:
+  template < int EVFLAG, int EFLAG, int NEWTON_PAIR > void eval();
+};
+
+}
+
+#endif
+#endif
Common subdirectories: src/PERI and src_DFT-CES2/PERI
Common subdirectories: src/POEMS and src_DFT-CES2/POEMS
diff -uN src/pppm.cpp src_DFT-CES2/pppm.cpp
--- src/pppm.cpp	2024-04-23 22:12:52.677241903 +0900
+++ src_DFT-CES2/pppm.cpp	2025-02-11 06:42:37.178608916 +0900
@@ -85,6 +85,14 @@
   triclinic = domain->triclinic;
 
   accuracy_relative = fabs(force->numeric(FLERR,arg[0]));
+	if (narg != 3) {
+  z_plate = 0; 
+  q_plate = 0;
+	}
+	else{
+  z_plate = force->numeric(FLERR,arg[1]);
+  q_plate = force->numeric(FLERR,arg[2]);
+	}
 
   nfactors = 3;
   factors = new int[nfactors];
@@ -2955,38 +2963,75 @@
 {
   // compute local contribution to global dipole moment
 
+	//printf("hey\n");
   double *q = atom->q;
   double **x = atom->x;
   double zprd = domain->zprd;
   int nlocal = atom->nlocal;
+  double *xi;
+  double xM[3];
+  int iH1,iH2;
 
+  double qsum_plate; // including charge plate
+  qsum_plate = qsum + q_plate;
   double dipole = 0.0;
-  for (int i = 0; i < nlocal; i++) dipole += q[i]*x[i][2];
+	if(tip4pflag){
+  for (int i = 0; i < nlocal; i++) {
+		// find_M
+    if (atom->type[i] == typeO) {
+      find_M(i,iH1,iH2,xM);
+      xi = xM;
+		} else xi = x[i];
+		dipole += q[i]*xi[2];
+	}
+	}
+	else{
+	 for (int i = 0; i < nlocal; i++) {
+			// find_M
+			dipole += q[i]*x[i][2];
+		}
+	}
+			
 
   // sum local contributions to get global dipole moment
 
   double dipole_all;
   MPI_Allreduce(&dipole,&dipole_all,1,MPI_DOUBLE,MPI_SUM,world);
-
+  dipole_all += q_plate * z_plate * zprd; // Add dipole of the charge plate from QM
   // need to make non-neutral systems and/or
   //  per-atom energy translationally invariant
 
   double dipole_r2 = 0.0;
   if (eflag_atom || fabs(qsum) > SMALL) {
-    for (int i = 0; i < nlocal; i++)
-      dipole_r2 += q[i]*x[i][2]*x[i][2];
 
+	if(tip4pflag){
+  for (int i = 0; i < nlocal; i++) {
+		// find_M
+    if (atom->type[i] == typeO) {
+      find_M(i,iH1,iH2,xM);
+      xi = xM;
+		} else xi = x[i];
+		dipole_r2 += q[i]*xi[2]*xi[2];
+	}
+	}
+	else{
+	 for (int i = 0; i < nlocal; i++) {
+			// find_M
+			dipole_r2 += q[i]*x[i][2]*x[i][2];
+		}
+	}
     // sum local contributions
 
     double tmp;
     MPI_Allreduce(&dipole_r2,&tmp,1,MPI_DOUBLE,MPI_SUM,world);
     dipole_r2 = tmp;
+    dipole_r2 += q_plate * z_plate * z_plate * zprd * zprd; // Add dipole_r2 of the charge plate from QM
   }
 
   // compute corrections
 
   const double e_slabcorr = MY_2PI*(dipole_all*dipole_all -
-    qsum*dipole_r2 - qsum*qsum*zprd*zprd/12.0)/volume;
+    qsum_plate*dipole_r2 - qsum_plate*qsum_plate*zprd*zprd/12.0)/volume;
   const double qscale = qqrd2e * scale;
 
   if (eflag_global) energy += qscale * e_slabcorr;
@@ -2997,7 +3042,7 @@
     double efact = qscale * MY_2PI/volume;
     for (int i = 0; i < nlocal; i++)
       eatom[i] += efact * q[i]*(x[i][2]*dipole_all - 0.5*(dipole_r2 +
-        qsum*x[i][2]*x[i][2]) - qsum*zprd*zprd/12.0);
+        qsum_plate*x[i][2]*x[i][2]) - qsum_plate*zprd*zprd/12.0);
   }
 
   // add on force corrections
@@ -3005,7 +3050,24 @@
   double ffact = qscale * (-4.0*MY_PI/volume);
   double **f = atom->f;
 
-  for (int i = 0; i < nlocal; i++) f[i][2] += ffact * q[i]*(dipole_all - qsum*x[i][2]);
+	if (tip4pflag){
+	  for (int i = 0; i < nlocal; i++) {
+	    if (atom->type[i] == typeO) {
+	      find_M(i,iH1,iH2,xM);
+				xi = xM;
+			} else xi = x[i];
+	    double fzi_corr = ffact * q[i]*(dipole_all - qsum_plate*xi[2]);
+	    if (atom->type[i] == typeO) {
+	      f[i][2] += fzi_corr*(1 - alpha);
+	      f[iH1][2] += 0.5*alpha*fzi_corr;
+	      f[iH2][2] += 0.5*alpha*fzi_corr;
+	    }
+	    else f[i][2] += fzi_corr;
+	  }
+	}
+	else {
+	  for (int i = 0; i < nlocal; i++) f[i][2] += ffact * q[i]*(dipole_all - qsum_plate*x[i][2]);
+	}
 }
 
 /* ----------------------------------------------------------------------
@@ -3531,3 +3593,113 @@
   const double ffact = qscale * (-4.0*MY_PI/volume);
   f2group[2] += ffact * (qsum_A*dipole_B - qsum_B*dipole_A);
 }
+
+/*
+ TIP4P slab correct
+ */
+void PPPM::find_M(int i, int &iH1, int &iH2, double *xM)
+{
+  double **x = atom->x;
+
+  iH1 = atom->map(atom->tag[i] + 1);
+  iH2 = atom->map(atom->tag[i] + 2);
+
+  if (iH1 == -1 || iH2 == -1) error->one(FLERR,"TIP4P hydrogen is missing");
+  if (atom->type[iH1] != typeH || atom->type[iH2] != typeH)
+    error->one(FLERR,"TIP4P hydrogen has incorrect atom type");
+
+  if (triclinic) {
+
+    // need to use custom code to find the closest image for triclinic,
+    // since local atoms are in lambda coordinates, but ghosts are not.
+
+    int *sametag = atom->sametag;
+    double xo[3],xh1[3],xh2[3];
+
+    domain->lamda2x(x[i],xo);
+    domain->lamda2x(x[iH1],xh1);
+    domain->lamda2x(x[iH2],xh2);
+
+    double delx = xo[0] - xh1[0];
+    double dely = xo[1] - xh1[1];
+    double delz = xo[2] - xh1[2];
+    double rsqmin = delx*delx + dely*dely + delz*delz;
+    double rsq;
+    int closest = iH1;
+
+    while (sametag[iH1] >= 0) {
+      iH1 = sametag[iH1];
+      delx = xo[0] - x[iH1][0];
+      dely = xo[1] - x[iH1][1];
+      delz = xo[2] - x[iH1][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      if (rsq < rsqmin) {
+        rsqmin = rsq;
+        closest = iH1;
+        xh1[0] = x[iH1][0];
+        xh1[1] = x[iH1][1];
+        xh1[2] = x[iH1][2];
+      }
+    }
+    iH1 = closest;
+
+    closest = iH2;
+    delx = xo[0] - xh2[0];
+    dely = xo[1] - xh2[1];
+    delz = xo[2] - xh2[2];
+    rsqmin = delx*delx + dely*dely + delz*delz;
+
+    while (sametag[iH2] >= 0) {
+      iH2 = sametag[iH2];
+      delx = xo[0] - x[iH2][0];
+      dely = xo[1] - x[iH2][1];
+      delz = xo[2] - x[iH2][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      if (rsq < rsqmin) {
+        rsqmin = rsq;
+        closest = iH2;
+        xh2[0] = x[iH2][0];
+        xh2[1] = x[iH2][1];
+        xh2[2] = x[iH2][2];
+      }
+    }
+    iH2 = closest;
+
+    // finally compute M in real coordinates ...
+
+    double delx1 = xh1[0] - xo[0];
+    double dely1 = xh1[1] - xo[1];
+    double delz1 = xh1[2] - xo[2];
+
+    double delx2 = xh2[0] - xo[0];
+    double dely2 = xh2[1] - xo[1];
+    double delz2 = xh2[2] - xo[2];
+
+    xM[0] = xo[0] + alpha * 0.5 * (delx1 + delx2);
+    xM[1] = xo[1] + alpha * 0.5 * (dely1 + dely2);
+    xM[2] = xo[2] + alpha * 0.5 * (delz1 + delz2);
+
+    // ... and convert M to lamda space for PPPM
+
+    domain->x2lamda(xM,xM);
+
+  } else {
+
+    // set iH1,iH2 to index of closest image to O
+
+    iH1 = domain->closest_image(i,iH1);
+    iH2 = domain->closest_image(i,iH2);
+
+    double delx1 = x[iH1][0] - x[i][0];
+    double dely1 = x[iH1][1] - x[i][1];
+    double delz1 = x[iH1][2] - x[i][2];
+
+    double delx2 = x[iH2][0] - x[i][0];
+    double dely2 = x[iH2][1] - x[i][1];
+    double delz2 = x[iH2][2] - x[i][2];
+
+    xM[0] = x[i][0] + alpha * 0.5 * (delx1 + delx2);
+    xM[1] = x[i][1] + alpha * 0.5 * (dely1 + dely2);
+    xM[2] = x[i][2] + alpha * 0.5 * (delz1 + delz2);
+  }
+}
diff -uN src/pppm.h src_DFT-CES2/pppm.h
--- src/pppm.h	2024-04-23 22:12:52.616241378 +0900
+++ src_DFT-CES2/pppm.h	2025-02-11 06:42:37.213609254 +0900
@@ -194,6 +194,9 @@
     double s = sx*sy*sz;
     return s*s;
   };
+ private:
+  void find_M(int, int &, int &, double *);
+  double z_plate,q_plate;
 };
 
 }
Common subdirectories: src/PYTHON and src_DFT-CES2/PYTHON
Common subdirectories: src/QEQ and src_DFT-CES2/QEQ
Common subdirectories: src/REAX and src_DFT-CES2/REAX
Common subdirectories: src/REPLICA and src_DFT-CES2/REPLICA
Common subdirectories: src/RIGID and src_DFT-CES2/RIGID
diff -uN src/run.cpp src_DFT-CES2/run.cpp
--- src/run.cpp	2024-04-23 22:12:52.668241825 +0900
+++ src_DFT-CES2/run.cpp	2025-02-11 06:42:37.178608916 +0900
@@ -24,6 +24,9 @@
 #include "input.h"
 #include "timer.h"
 #include "error.h"
+// DFT-CES start
+#include "grid.h"
+// DFT-CES end
 
 using namespace LAMMPS_NS;
 
@@ -182,6 +185,10 @@
     timer->barrier_start();
     update->integrate->run(nsteps);
     timer->barrier_stop();
+// DFT-CES start
+      if(domain->grid->natoms != 0 && domain->grid->savetag != 0) domain->grid->save_grid(domain->grid->savedcube,nsteps);
+// DFT-CES end
+
 
     update->integrate->cleanup();
 
Common subdirectories: src/SHOCK and src_DFT-CES2/SHOCK
Common subdirectories: src/SNAP and src_DFT-CES2/SNAP
Common subdirectories: src/SRD and src_DFT-CES2/SRD
Common subdirectories: src/STUBS and src_DFT-CES2/STUBS
diff -uN src/style_angle.h src_DFT-CES2/style_angle.h
--- src/style_angle.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_angle.h	2025-02-11 06:42:37.281609910 +0900
@@ -0,0 +1,9 @@
+#include "angle_charmm.h"
+#include "angle_cosine.h"
+#include "angle_cosine_delta.h"
+#include "angle_cosine_periodic.h"
+#include "angle_cosine_squared.h"
+#include "angle_harmonic.h"
+#include "angle_hybrid.h"
+#include "angle_table.h"
+#include "angle_zero.h"
diff -uN src/style_atom.h src_DFT-CES2/style_atom.h
--- src/style_atom.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_atom.h	2025-02-11 06:42:37.214609263 +0900
@@ -0,0 +1,13 @@
+#include "atom_vec_angle.h"
+#include "atom_vec_atomic.h"
+#include "atom_vec_body.h"
+#include "atom_vec_bond.h"
+#include "atom_vec_charge.h"
+#include "atom_vec_ellipsoid.h"
+#include "atom_vec_full.h"
+#include "atom_vec_hybrid.h"
+#include "atom_vec_line.h"
+#include "atom_vec_molecular.h"
+#include "atom_vec_sphere.h"
+#include "atom_vec_template.h"
+#include "atom_vec_tri.h"
diff -uN src/style_bond.h src_DFT-CES2/style_bond.h
--- src/style_bond.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_bond.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,9 @@
+#include "bond_fene.h"
+#include "bond_fene_expand.h"
+#include "bond_harmonic.h"
+#include "bond_hybrid.h"
+#include "bond_morse.h"
+#include "bond_nonlinear.h"
+#include "bond_quartic.h"
+#include "bond_table.h"
+#include "bond_zero.h"
diff -uN src/style_command.h src_DFT-CES2/style_command.h
--- src/style_command.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_command.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,22 @@
+#include "balance.h"
+#include "change_box.h"
+#include "create_atoms.h"
+#include "create_bonds.h"
+#include "create_box.h"
+#include "delete_atoms.h"
+#include "delete_bonds.h"
+#include "displace_atoms.h"
+#include "info.h"
+#include "minimize.h"
+#include "read_data.h"
+#include "read_dump.h"
+#include "read_restart.h"
+#include "replicate.h"
+#include "rerun.h"
+#include "run.h"
+#include "set.h"
+#include "velocity.h"
+#include "write_coeff.h"
+#include "write_data.h"
+#include "write_dump.h"
+#include "write_restart.h"
diff -uN src/style_compute.h src_DFT-CES2/style_compute.h
--- src/style_compute.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_compute.h	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,67 @@
+#include "compute_angle.h"
+#include "compute_angle_local.h"
+#include "compute_angmom_chunk.h"
+#include "compute_bond.h"
+#include "compute_bond_local.h"
+#include "compute_centro_atom.h"
+#include "compute_chunk_atom.h"
+#include "compute_cluster_atom.h"
+#include "compute_cna_atom.h"
+#include "compute_com.h"
+#include "compute_com_chunk.h"
+#include "compute_contact_atom.h"
+#include "compute_coord_atom.h"
+#include "compute_dihedral.h"
+#include "compute_dihedral_local.h"
+#include "compute_dipole_chunk.h"
+#include "compute_displace_atom.h"
+#include "compute_erotate_rigid.h"
+#include "compute_erotate_sphere.h"
+#include "compute_erotate_sphere_atom.h"
+#include "compute_force_tally.h"
+#include "compute_global_atom.h"
+#include "compute_group_group.h"
+#include "compute_gyration.h"
+#include "compute_gyration_chunk.h"
+#include "compute_heat_flux.h"
+#include "compute_heat_flux_tally.h"
+#include "compute_hexorder_atom.h"
+#include "compute_improper.h"
+#include "compute_improper_local.h"
+#include "compute_inertia_chunk.h"
+#include "compute_ke.h"
+#include "compute_ke_atom.h"
+#include "compute_ke_rigid.h"
+#include "compute_msd.h"
+#include "compute_msd_chunk.h"
+#include "compute_omega_chunk.h"
+#include "compute_orientorder_atom.h"
+#include "compute_pair.h"
+#include "compute_pair_local.h"
+#include "compute_pe.h"
+#include "compute_pe_atom.h"
+#include "compute_pe_mol_tally.h"
+#include "compute_pe_tally.h"
+#include "compute_pressure.h"
+#include "compute_property_atom.h"
+#include "compute_property_chunk.h"
+#include "compute_property_local.h"
+#include "compute_rdf.h"
+#include "compute_reduce.h"
+#include "compute_reduce_region.h"
+#include "compute_rigid_local.h"
+#include "compute_slice.h"
+#include "compute_stress_atom.h"
+#include "compute_stress_tally.h"
+#include "compute_temp.h"
+#include "compute_temp_chunk.h"
+#include "compute_temp_com.h"
+#include "compute_temp_deform.h"
+#include "compute_temp_partial.h"
+#include "compute_temp_profile.h"
+#include "compute_temp_ramp.h"
+#include "compute_temp_region.h"
+#include "compute_temp_sphere.h"
+#include "compute_torque_chunk.h"
+#include "compute_vacf.h"
+#include "compute_vcm_chunk.h"
diff -uN src/style_dihedral.h src_DFT-CES2/style_dihedral.h
--- src/style_dihedral.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_dihedral.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,8 @@
+#include "dihedral_charmm.h"
+#include "dihedral_charmmfsw.h"
+#include "dihedral_harmonic.h"
+#include "dihedral_helix.h"
+#include "dihedral_hybrid.h"
+#include "dihedral_multi_harmonic.h"
+#include "dihedral_opls.h"
+#include "dihedral_zero.h"
diff -uN src/style_dump.h src_DFT-CES2/style_dump.h
--- src/style_dump.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_dump.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,8 @@
+#include "dump_atom.h"
+#include "dump_cfg.h"
+#include "dump_custom.h"
+#include "dump_dcd.h"
+#include "dump_image.h"
+#include "dump_local.h"
+#include "dump_movie.h"
+#include "dump_xyz.h"
diff -uN src/style_fix.h src_DFT-CES2/style_fix.h
--- src/style_fix.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_fix.h	2025-02-11 06:42:37.183608964 +0900
@@ -0,0 +1,86 @@
+#include "fix_adapt.h"
+#include "fix_addforce.h"
+#include "fix_ave_atom.h"
+#include "fix_ave_chunk.h"
+#include "fix_ave_correlate.h"
+#include "fix_ave_histo.h"
+#include "fix_ave_histo_weight.h"
+#include "fix_ave_time.h"
+#include "fix_aveforce.h"
+#include "fix_balance.h"
+#include "fix_box_relax.h"
+#include "fix_cmap.h"
+#include "fix_controller.h"
+#include "fix_deform.h"
+#include "fix_deprecated.h"
+#include "fix_drag.h"
+#include "fix_dt_reset.h"
+#include "fix_ehex.h"
+#include "fix_enforce2d.h"
+#include "fix_external.h"
+#include "fix_gravity.h"
+#include "fix_gridforce.h"
+#include "fix_group.h"
+#include "fix_halt.h"
+#include "fix_heat.h"
+#include "fix_indent.h"
+#include "fix_langevin.h"
+#include "fix_lineforce.h"
+#include "fix_minimize.h"
+#include "fix_momentum.h"
+#include "fix_move.h"
+#include "fix_nph.h"
+#include "fix_nph_sphere.h"
+#include "fix_npt.h"
+#include "fix_npt_sphere.h"
+#include "fix_nve.h"
+#include "fix_nve_limit.h"
+#include "fix_nve_noforce.h"
+#include "fix_nve_sphere.h"
+#include "fix_nvt.h"
+#include "fix_nvt_sllod.h"
+#include "fix_nvt_sphere.h"
+#include "fix_planeforce.h"
+#include "fix_press_berendsen.h"
+#include "fix_print.h"
+#include "fix_property_atom.h"
+#include "fix_qeq_comb.h"
+#include "fix_rattle.h"
+#include "fix_read_restart.h"
+#include "fix_recenter.h"
+#include "fix_respa.h"
+#include "fix_restrain.h"
+#include "fix_rigid.h"
+#include "fix_rigid_nph.h"
+#include "fix_rigid_nph_small.h"
+#include "fix_rigid_npt.h"
+#include "fix_rigid_npt_small.h"
+#include "fix_rigid_nve.h"
+#include "fix_rigid_nve_small.h"
+#include "fix_rigid_nvt.h"
+#include "fix_rigid_nvt_small.h"
+#include "fix_rigid_small.h"
+#include "fix_setforce.h"
+#include "fix_shake.h"
+#include "fix_shear_history.h"
+#include "fix_spring.h"
+#include "fix_spring_chunk.h"
+#include "fix_spring_rg.h"
+#include "fix_spring_self.h"
+#include "fix_store.h"
+#include "fix_store_force.h"
+#include "fix_store_state.h"
+#include "fix_temp_berendsen.h"
+#include "fix_temp_csld.h"
+#include "fix_temp_csvr.h"
+#include "fix_temp_rescale.h"
+#include "fix_tmd.h"
+#include "fix_tune_kspace.h"
+#include "fix_vector.h"
+#include "fix_viscous.h"
+#include "fix_wall_harmonic.h"
+#include "fix_wall_lj1043.h"
+#include "fix_wall_lj126.h"
+#include "fix_wall_lj93.h"
+#include "fix_wall_reflect.h"
+#include "fix_wall_region.h"
diff -uN src/style_improper.h src_DFT-CES2/style_improper.h
--- src/style_improper.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_improper.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,5 @@
+#include "improper_cvff.h"
+#include "improper_harmonic.h"
+#include "improper_hybrid.h"
+#include "improper_umbrella.h"
+#include "improper_zero.h"
diff -uN src/style_integrate.h src_DFT-CES2/style_integrate.h
--- src/style_integrate.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_integrate.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,2 @@
+#include "respa.h"
+#include "verlet.h"
diff -uN src/style_kspace.h src_DFT-CES2/style_kspace.h
--- src/style_kspace.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_kspace.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,10 @@
+#include "ewald.h"
+#include "ewald_disp.h"
+#include "msm.h"
+#include "msm_cg.h"
+#include "pppm.h"
+#include "pppm_cg.h"
+#include "pppm_disp.h"
+#include "pppm_disp_tip4p.h"
+#include "pppm_stagger.h"
+#include "pppm_tip4p.h"
diff -uN src/style_minimize.h src_DFT-CES2/style_minimize.h
--- src/style_minimize.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_minimize.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,5 @@
+#include "min_cg.h"
+#include "min_fire.h"
+#include "min_hftn.h"
+#include "min_quickmin.h"
+#include "min_sd.h"
diff -uN src/style_nbin.h src_DFT-CES2/style_nbin.h
--- src/style_nbin.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_nbin.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1 @@
+#include "nbin_standard.h"
diff -uN src/style_npair.h src_DFT-CES2/style_npair.h
--- src/style_npair.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_npair.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,35 @@
+#include "npair_copy.h"
+#include "npair_full_bin.h"
+#include "npair_full_bin_atomonly.h"
+#include "npair_full_bin_ghost.h"
+#include "npair_full_multi.h"
+#include "npair_full_nsq.h"
+#include "npair_full_nsq_ghost.h"
+#include "npair_half_bin_atomonly_newton.h"
+#include "npair_half_bin_newtoff.h"
+#include "npair_half_bin_newtoff_ghost.h"
+#include "npair_half_bin_newton.h"
+#include "npair_half_bin_newton_tri.h"
+#include "npair_half_multi_newtoff.h"
+#include "npair_half_multi_newton.h"
+#include "npair_half_multi_newton_tri.h"
+#include "npair_half_nsq_newtoff.h"
+#include "npair_half_nsq_newtoff_ghost.h"
+#include "npair_half_nsq_newton.h"
+#include "npair_half_respa_bin_newtoff.h"
+#include "npair_half_respa_bin_newton.h"
+#include "npair_half_respa_bin_newton_tri.h"
+#include "npair_half_respa_nsq_newtoff.h"
+#include "npair_half_respa_nsq_newton.h"
+#include "npair_half_size_bin_newtoff.h"
+#include "npair_half_size_bin_newton.h"
+#include "npair_half_size_bin_newton_tri.h"
+#include "npair_half_size_nsq_newtoff.h"
+#include "npair_half_size_nsq_newton.h"
+#include "npair_halffull_newtoff.h"
+#include "npair_halffull_newton.h"
+#include "npair_skip.h"
+#include "npair_skip_respa.h"
+#include "npair_skip_size.h"
+#include "npair_skip_size_off2on.h"
+#include "npair_skip_size_off2on_oneside.h"
diff -uN src/style_nstencil.h src_DFT-CES2/style_nstencil.h
--- src/style_nstencil.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_nstencil.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,20 @@
+#include "nstencil_full_bin_2d.h"
+#include "nstencil_full_bin_3d.h"
+#include "nstencil_full_ghost_bin_2d.h"
+#include "nstencil_full_ghost_bin_3d.h"
+#include "nstencil_full_multi_2d.h"
+#include "nstencil_full_multi_3d.h"
+#include "nstencil_half_bin_2d_newtoff.h"
+#include "nstencil_half_bin_2d_newton.h"
+#include "nstencil_half_bin_2d_newton_tri.h"
+#include "nstencil_half_bin_3d_newtoff.h"
+#include "nstencil_half_bin_3d_newton.h"
+#include "nstencil_half_bin_3d_newton_tri.h"
+#include "nstencil_half_ghost_bin_2d_newtoff.h"
+#include "nstencil_half_ghost_bin_3d_newtoff.h"
+#include "nstencil_half_multi_2d_newtoff.h"
+#include "nstencil_half_multi_2d_newton.h"
+#include "nstencil_half_multi_2d_newton_tri.h"
+#include "nstencil_half_multi_3d_newtoff.h"
+#include "nstencil_half_multi_3d_newton.h"
+#include "nstencil_half_multi_3d_newton_tri.h"
diff -uN src/style_ntopo.h src_DFT-CES2/style_ntopo.h
--- src/style_ntopo.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_ntopo.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,12 @@
+#include "ntopo_angle_all.h"
+#include "ntopo_angle_partial.h"
+#include "ntopo_angle_template.h"
+#include "ntopo_bond_all.h"
+#include "ntopo_bond_partial.h"
+#include "ntopo_bond_template.h"
+#include "ntopo_dihedral_all.h"
+#include "ntopo_dihedral_partial.h"
+#include "ntopo_dihedral_template.h"
+#include "ntopo_improper_all.h"
+#include "ntopo_improper_partial.h"
+#include "ntopo_improper_template.h"
diff -uN src/style_pair.h src_DFT-CES2/style_pair.h
--- src/style_pair.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_pair.h	2025-02-11 06:42:37.253609640 +0900
@@ -0,0 +1,91 @@
+#include "pair_adp.h"
+#include "pair_airebo.h"
+#include "pair_airebo_morse.h"
+#include "pair_beck.h"
+#include "pair_bjdisp.h"
+#include "pair_bjdisp_coul_long.h"
+#include "pair_bop.h"
+#include "pair_born.h"
+#include "pair_born_coul_dsf.h"
+#include "pair_born_coul_long.h"
+#include "pair_born_coul_msm.h"
+#include "pair_born_coul_wolf.h"
+#include "pair_buck.h"
+#include "pair_buck_coul_cut.h"
+#include "pair_buck_coul_long.h"
+#include "pair_buck_coul_msm.h"
+#include "pair_buck_long_coul_long.h"
+#include "pair_comb.h"
+#include "pair_comb3.h"
+#include "pair_coul_cut.h"
+#include "pair_coul_debye.h"
+#include "pair_coul_dsf.h"
+#include "pair_coul_long.h"
+#include "pair_coul_msm.h"
+#include "pair_coul_streitz.h"
+#include "pair_coul_wolf.h"
+#include "pair_dpd.h"
+#include "pair_dpd_tstat.h"
+#include "pair_eam.h"
+#include "pair_eam_alloy.h"
+#include "pair_eam_alloy_opt.h"
+#include "pair_eam_fs.h"
+#include "pair_eam_fs_opt.h"
+#include "pair_eam_opt.h"
+#include "pair_eim.h"
+#include "pair_gauss.h"
+#include "pair_gw.h"
+#include "pair_gw_zbl.h"
+#include "pair_hbond_dreiding_lj.h"
+#include "pair_hbond_dreiding_morse.h"
+#include "pair_hybrid.h"
+#include "pair_hybrid_overlay.h"
+#include "pair_lcbop.h"
+#include "pair_lj96_cut.h"
+#include "pair_lj_charmm_coul_charmm.h"
+#include "pair_lj_charmm_coul_charmm_implicit.h"
+#include "pair_lj_charmm_coul_long.h"
+#include "pair_lj_charmm_coul_long_opt.h"
+#include "pair_lj_charmm_coul_msm.h"
+#include "pair_lj_charmmfsw_coul_charmmfsh.h"
+#include "pair_lj_charmmfsw_coul_long.h"
+#include "pair_lj_cubic.h"
+#include "pair_lj_cut.h"
+#include "pair_lj_cut_coul_cut.h"
+#include "pair_lj_cut_coul_debye.h"
+#include "pair_lj_cut_coul_dsf.h"
+#include "pair_lj_cut_coul_long.h"
+#include "pair_lj_cut_coul_long_opt.h"
+#include "pair_lj_cut_coul_msm.h"
+#include "pair_lj_cut_opt.h"
+#include "pair_lj_cut_tip4p_cut.h"
+#include "pair_lj_cut_tip4p_long.h"
+#include "pair_lj_cut_tip4p_long_opt.h"
+#include "pair_lj_expand.h"
+#include "pair_lj_gromacs.h"
+#include "pair_lj_gromacs_coul_gromacs.h"
+#include "pair_lj_long_coul_long.h"
+#include "pair_lj_long_coul_long_opt.h"
+#include "pair_lj_long_tip4p_long.h"
+#include "pair_lj_smooth.h"
+#include "pair_lj_smooth_linear.h"
+#include "pair_mie_cut.h"
+#include "pair_morse.h"
+#include "pair_morse_opt.h"
+#include "pair_nb3b_harmonic.h"
+#include "pair_polymorphic.h"
+#include "pair_rebo.h"
+#include "pair_soft.h"
+#include "pair_sw.h"
+#include "pair_table.h"
+#include "pair_tersoff.h"
+#include "pair_tersoff_mod.h"
+#include "pair_tersoff_mod_c.h"
+#include "pair_tersoff_zbl.h"
+#include "pair_tip4p_cut.h"
+#include "pair_tip4p_long.h"
+#include "pair_vashishta.h"
+#include "pair_vashishta_table.h"
+#include "pair_yukawa.h"
+#include "pair_zbl.h"
+#include "pair_zero.h"
diff -uN src/style_reader.h src_DFT-CES2/style_reader.h
--- src/style_reader.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_reader.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,2 @@
+#include "reader_native.h"
+#include "reader_xyz.h"
diff -uN src/style_region.h src_DFT-CES2/style_region.h
--- src/style_region.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/style_region.h	2025-02-11 06:42:37.182608955 +0900
@@ -0,0 +1,8 @@
+#include "region_block.h"
+#include "region_cone.h"
+#include "region_cylinder.h"
+#include "region_intersect.h"
+#include "region_plane.h"
+#include "region_prism.h"
+#include "region_sphere.h"
+#include "region_union.h"
diff -uN src/tagmodels.c src_DFT-CES2/tagmodels.c
--- src/tagmodels.c	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/tagmodels.c	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,41 @@
+#include "stdlib.h"
+#include "tagmodels.h"
+
+int potCopywoValue(tag_Models **in, tag_Models **out)
+{
+	int i;
+	*out = (tag_Models *)malloc(sizeof(tag_Models));
+	(*out)->nAtoms = (*in)->nAtoms;
+	(*out)->cellParams[0] = (*in)->cellParams[0];
+	(*out)->cellParams[1] = (*in)->cellParams[1];
+	(*out)->cellParams[2] = (*in)->cellParams[2];
+	(*out)->pGrid[0] = (*in)->pGrid[0];
+	(*out)->pGrid[1] = (*in)->pGrid[1];
+	(*out)->pGrid[2] = (*in)->pGrid[2];
+	(*out)->atomN = (int *)malloc(sizeof(int) * (*in)->nAtoms);
+	(*out)->posX = (double *)malloc(sizeof(double) * (*in)->nAtoms);
+	(*out)->posY = (double *)malloc(sizeof(double) * (*in)->nAtoms);
+	(*out)->posZ = (double *)malloc(sizeof(double) * (*in)->nAtoms);
+
+	for (i = 0; i < (*in)->nAtoms; i++)
+	{
+		(*out)->atomN[i] = (*in)->atomN[i];
+		(*out)->posX[i] = (*in)->posX[i];
+		(*out)->posY[i] = (*in)->posY[i];
+		(*out)->posZ[i] = (*in)->posZ[i];
+	}
+
+	(*out)->pValue = (double *)malloc((*in)->pGrid[0] * (*in)->pGrid[1] * (*in)->pGrid[2] * sizeof(double));
+
+	return 0;
+}
+
+int potFree(tag_Models **in)
+{
+	free((*in)->pValue);
+	free((*in)->atomN);
+	free((*in)->posX);
+	free((*in)->posY);
+	free((*in)->posZ);
+	free(*in);
+}
diff -uN src/tagmodels.h src_DFT-CES2/tagmodels.h
--- src/tagmodels.h	1970-01-01 09:00:00.000000000 +0900
+++ src_DFT-CES2/tagmodels.h	2025-02-11 06:42:37.178608916 +0900
@@ -0,0 +1,19 @@
+#ifndef _TAGMODELS_H
+#define _TAGMODELS_H
+
+typedef struct
+{ //LOCPOT parsing data structure
+	double cellParams[3];
+	int nAtoms;
+	int pGrid[3]; //grid x, y, z
+	int *atomN;
+	double *posX;
+	double *posY;
+	double *posZ;
+	double *pValue;
+} tag_Models;
+
+int potCopywoValue(tag_Models **in, tag_Models **out);
+int potFree(tag_Models **in);
+
+#endif
Common subdirectories: src/USER-ATC and src_DFT-CES2/USER-ATC
Common subdirectories: src/USER-AWPMD and src_DFT-CES2/USER-AWPMD
Common subdirectories: src/USER-CGDNA and src_DFT-CES2/USER-CGDNA
Common subdirectories: src/USER-CGSDK and src_DFT-CES2/USER-CGSDK
Common subdirectories: src/USER-COLVARS and src_DFT-CES2/USER-COLVARS
Common subdirectories: src/USER-DIFFRACTION and src_DFT-CES2/USER-DIFFRACTION
Common subdirectories: src/USER-DPD and src_DFT-CES2/USER-DPD
Common subdirectories: src/USER-DRUDE and src_DFT-CES2/USER-DRUDE
Common subdirectories: src/USER-EFF and src_DFT-CES2/USER-EFF
Common subdirectories: src/USER-FEP and src_DFT-CES2/USER-FEP
Common subdirectories: src/USER-H5MD and src_DFT-CES2/USER-H5MD
Common subdirectories: src/USER-INTEL and src_DFT-CES2/USER-INTEL
Common subdirectories: src/USER-LB and src_DFT-CES2/USER-LB
Common subdirectories: src/USER-MANIFOLD and src_DFT-CES2/USER-MANIFOLD
Common subdirectories: src/USER-MEAMC and src_DFT-CES2/USER-MEAMC
Common subdirectories: src/USER-MGPT and src_DFT-CES2/USER-MGPT
Common subdirectories: src/USER-MISC and src_DFT-CES2/USER-MISC
Common subdirectories: src/USER-MOLFILE and src_DFT-CES2/USER-MOLFILE
Common subdirectories: src/USER-NETCDF and src_DFT-CES2/USER-NETCDF
Common subdirectories: src/USER-OMP and src_DFT-CES2/USER-OMP
Common subdirectories: src/USER-PHONON and src_DFT-CES2/USER-PHONON
Common subdirectories: src/USER-QMMM and src_DFT-CES2/USER-QMMM
Common subdirectories: src/USER-QTB and src_DFT-CES2/USER-QTB
Common subdirectories: src/USER-QUIP and src_DFT-CES2/USER-QUIP
Common subdirectories: src/USER-REAXC and src_DFT-CES2/USER-REAXC
Common subdirectories: src/USER-SMD and src_DFT-CES2/USER-SMD
Common subdirectories: src/USER-SMTBQ and src_DFT-CES2/USER-SMTBQ
Common subdirectories: src/USER-SPH and src_DFT-CES2/USER-SPH
Common subdirectories: src/USER-TALLY and src_DFT-CES2/USER-TALLY
Common subdirectories: src/USER-VTK and src_DFT-CES2/USER-VTK
Common subdirectories: src/VORONOI and src_DFT-CES2/VORONOI
